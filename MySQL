# MySQL



## 資料庫

- 資料庫 : DateBase
- 概念 : 資料倉庫 軟體 安裝在作業系統上
- 作用 : 存儲資料 管理資料



## 資料庫分類

- 關聯型資料庫 (SQL)
  - MySQL , oracle , Sql Server , DB2 , SQLlite
  - 根據表與表之間 , 行與列之間的關係進行資料的儲存
- 非關聯型資料庫 (NoSQL)  Not Only 
  - Redis , MongoDB
  - 非關聯性資料庫 , 對象儲存 , 通過對象自身的屬性決定操作



#### DBMS (資料庫管理系統)

- 資料庫管理軟體 有效管理資料 維護與獲取資料
- MySQL 數據庫管理系統



## MySQL簡介

#### 安裝測試

![擷取_2021_12_03_21_00_27_956](https://i.imgur.com/vW6kLAa.png)





## 連接資料庫

命令行連接

所有的語句都要使用 ; 結尾

```mysql
-- 連接數據庫mysql
-uroot -p123456  
-- 建立新的資料庫
create database dataname;
-- 查看所有的資料庫
show databases;
-- 切換資料庫 use 資料庫名
use databasesname
-- 查看資料庫中所有的表格
show tables;
-- 顯示資料庫中 表格的結構 describe 表格名
describe student;
-- 顯示資料庫 表格中的數據  
select * from `student`;
-- 退出連接
exit;

-- 單行註解
/*
多行註解
*/
```



資料庫語言 CRUD 增刪改查

DDL 定義

DML 操作

DQL 查詢

DCL 控制



## 資料庫的列類型

```
數值
```

- tinyint	   	十分小的數據     一個字元
- smallint        較小的數據         兩個字元
- mediumint  中等大小的數據  三個字元
- **int                 標準的數據          四個字元  常用**
- bigint            較大的數據          八個字元
- float              浮點數                  四個字元
- double         浮點數                  八個字元
- decimal        字串形式的浮點數   金融計算時 一般使用此類型



```
字串
```

- char			字串固定大小的  0~255
- **varchar      可辨字串    0 ~ 65535  常用的變數   對應String**
- tinytext      微型文本    2^8 - 1
- text             文本串       2^16 - 1      保存大文本



```
時間日期
```

java.util.Date



- data    YYYY-MM-DD 日期格式
- time    HH: mm: ss 時間格式
- **datatime   YYYY-MM-DD HH: mm: ss 最常用的時間格式**
- **timestamp  時間章  1970.1.1到現在的毫秒數   較常用**
- year    年份表示



```
null
```

- 沒有值 未知
- 盡量不要使用NULL進行運算 , 結果為NULL



## 資料庫的欄位屬性

- Unsigned : 
  - 無號數  不能聲明為負數
  - 聲明該列不能宣告為負數
- zerofill : 
  - 0填充
  - 不足的位數 使用0填充  int(3) , 5 --> 005
- selfadd : 
  - 自動在上一條的記錄的數值+1
  - 通常用來設計唯一的 PRIMARY KEY   index 必須是整數類型
  - 可以自定義設計 PRIMARY KEY 的起始值和步進
- not null
  - 假設設置為 not null  如果不賦予值 就會出現錯誤
  - NULL 如果不填寫值 預設為null
- 預設值 : 
  - 設置預設的值
  - 如果不指定該列的值 則會有預設的值



```
/* 每一個表格都必須存在五個欄位 表示一個紀錄存在意義*/

id primary key
`version`  樂觀鎖
is_delete  偽刪除
gmt_create 創建時間
gmt_update 修改時間
```



## 建立資料庫表格

```mysql
create table if not exists `member`(
	`id` int not null auto_increment comment '學號',
	`name` varchar(30) not null  default '空' comment '姓名',
    `pwd` varchar(20) not null default '12345' comment'密碼',
    `gender` varchar(6) not null  default 'male' comment'性別',
    `birthday` datetime default null comment '出生日期',
    `address` varchar(100) default null comment'住址',
    `email` varchar(50) default null comment'信箱',
    Primary key (`id`)
)engine=INNODB default char set=utf8;
```

#### 格式

```mysql
create table [if not exists] `表格名稱`(
	`欄位名稱` 類型[屬性] [索引] [註解], 
	`欄位名稱` 類型[屬性] [索引] [註解],
	`欄位名稱` 類型[屬性] [索引] [註解]
)[表格類型][字元設置][註解];
```



#### 顯示資料庫 表格的原始碼

```mysql
-- 查看創建資料庫的程式碼
show create database name;
-- 查看創建表格的程式碼
show create table name; 
-- 查看表格的結構
desc student;
```



## 資料表的類型

```mysql
-- 資料庫的引擎
INNODB 預設使用
MYISAM 過去使用
```



|            | MYISAM | INNODB        |
| ---------- | ------ | ------------- |
| 事務支持   | 不支持 | 支持          |
| 數據行鎖定 | 不支持 | 支持          |
| 外鍵約束   | 不支持 | 支持          |
| 全文索引   | 支持   | 不支持        |
| 表空間大小 | 較小   | 較大 約為兩倍 |

常規的使用操作 :

- MYISAM 節約空間 速度較快
- INNODB 安全性較高 事務的處理 多表多用戶操作



```
物理空間存在的位置
```

所有的資料庫文件都存在data目錄下

本質還是文件的形式

MySQL引擎在物理文件上的區別

- InnoDB 在資料庫表中只有一個 *.frm文件, 以及上級目錄下的ibdata1文件
- MYISAM對應文件
  - *.frm -   表結構的定義文件
  - *.MYD - 數據文件 (data)
  - *.MYI -   索引文件 (index)



```
設置資料庫表格的字元集編碼
```

```mysql
char set=utf8 
```

不設置的話 會是MySQL默認的字元集編碼 (不支持中文)

在my.ini 中配置的預設編碼

```mysql
Character-set-server=utf8
```



## 修改刪除表格

```
修改
```

```mysql
-- 修改表格名  alter table 舊名 rename as 新名
alter table `member` rename as member22;
-- 增加表格的欄位 alter table 表格名 add 欄位名稱 屬性
alter table `member` add age int;
-- 修改表格的欄位 (重命名, 修改約束)
-- alter table 表格名 modify 欄位名 屬性
alter table `member` modify age varchar(11); -- 修改約束
-- alter table 表格名 change 舊名 新名 屬性
alter table `member` change age age1 int(11); -- 欄位重命名 也可以重新設定約束
-- 刪除表格的欄位
-- alter table 表格名 drop 欄位名;
 alter table `member` drop age;
```



```
刪除
```

```mysql
-- 刪除表格 (如果表格存在)
drop table if exists `member`;
```

所有的創建和刪除盡量加上判斷

注意點 : 

- 所有的欄位名使用 ` 引用
- 註解 /*  */  --
- sql關鍵字無關大小寫
- 所有的符號全部用英文



## MySQL 數據管理

#### 外鍵

- 一般不得使用外鍵與級聯 外鍵的概念須在應用層解決
- 因為每次刪除或是更新時都必須考慮外鍵 導致開發困難 測試數據時麻煩

```
方式一 創建表格時 增加約束 (麻煩 複雜)
```

```mysql
create table `grade`(
	`gradeid` int(10) not null auto_increment comment'年級id',
      `gradename` varchar(50) not null comment '年級名稱',
      primary key (`gradeid`)
)engine = InnoDB default char set=utf8;

-- 學生表的 gradeid 欄位 要去引用年級表的gradeid
-- 定義外鍵 key
-- 給這個外鍵添加約束 (執行引用)  references 引用
 create table if not exists `student`(
	`id` int not null auto_increment comment '學號',
	`name` varchar(30) not null  default '空' comment '姓名',
    `gradeid` int(10) not null comment '學生年級',
    Primary key (`id`),
    -- 綁定
    key `FK_gradeid` (`gradeid`),
    -- 約束
    constraint `FK_gradeid` foreign key (`gradeid`) references `grade`(`gradeid`)
)engine=INNODB default char set=utf8;
```



```
方式二
```

```mysql
-- 創建表格時 沒有外鍵關係
alter table `student`
add constraint `FK_gradeid` foreign key(`gradid`) references `grage`(`gradeid`);
-- alter table 表格名
-- add constraint 約束名 foreign key(作為外鍵的列) references 表格(欄位名)
```

以上操作為物理外鍵 資料庫級別的外鍵 不建議使用  避免資料庫過多造成困擾



- 資料庫就是單純的表 只用ˋ來存數據 只有行(數據)和列(欄位)
- 我們想使用多張表格的數據 想使用外鍵 (程式去實現)



#### DML語言 (重要)

資料庫意義 : 資料儲存 資料管理

DML語言 : 資料操作語言

- Insert
- updata
- delete



#### 添加

```mysql
insert
-- 插入語句 (添加)
-- insert into 表明 ([欄位名1,欄位名2,..]) values('值1'),('值2'),('值3'),(...)
```

```mysql
create table `grade`(
	`gradeid` int(10) not null auto_increment comment'年級id',
      `gradename` varchar(50) not null comment '年級名稱',
	`pwd` varchar(20) not null default '12345' comment'密碼',
      `gender` varchar(6) not null  default 'male' comment'性別',
      primary key (`gradeid`)
)engine = InnoDB default char set=utf8;


insert into `grade`(`gradename`) values('大四');
insert into `grade`(`gradename`) values('大五');
-- 由於主鍵自增 可以省略主鍵 (如果不寫表格的欄位 會自動匹配)
-- 一般寫插入語句 一定要數據與欄位對應
-- 插入多個欄位
insert into `grade`(`gradename`) values('大二'),('大一');
-- insert into 表格名 ('欄位名','欄位名'..) values (對應欄位的資料類型)
insert into `grade`(`gradename`,`pwd`,`gender`) values('高三','asdfg','female');

-- 不寫欄位 需要自行加入primary key
insert into `grade` values(3,'高二','zxcvb','female');
```

注意事項 : 

- 欄位間使用 , 隔開
- 欄位是可以省略的 但是資料要一一對應
- 可以同時插入多條數據 values 後面的值須要使用 , 隔開



#### 修改

```mysql
update 修改對象 (條件)  set原來的值 = 新的值
-- 語法 updata 表格名 set column_name = value , column_name = value where (條件)
```

```mysql
-- 修改 
-- 指定當gradeid = 1的時候
update `grade` set `gradename`='大五' where gradeid = 1;

-- 修改多個屬性 使用 , 間隔
update `grade` set `gradename`='大六' , `pwd`='aaaaa' where gradeid = 1;  
```

條件 : where 子句

- id 等於某個數值 大於某個數值  在某個區間內修改

| 操作符              | 含義     | 範圍          | 結果  |
| ------------------- | -------- | ------------- | ----- |
| =                   | 等於     | 5 = 6         | false |
| <> 或 !=            | 不等於   | 5 <> 6        | true  |
| >                   |          |               |       |
| <                   |          |               |       |
| <=                  |          |               |       |
| >=                  |          |               |       |
| between ... and ... | 某個範圍 | [2,5]         |       |
| AND                 | 和 &&    | 5>1 and 1 > 2 | false |
| OR                  | 或 \|\|  | 5>1 or 1 > 2  | true  |

```mysql
-- 通過多個條件訂為數據
updata `grade` set gradename = 'sss' where `gradename`='AA' AND gender='male'
```

語法 : updata 表格名 set column_name = value,[column_name = value...] where[條件]

注意:

- column_name 是數據庫的列 盡量要使用
- 條件 篩選的條件 , 如果沒有指定 則會修改所有的列
- value 是一個具體的值 也可以是變數
- 多個設置的屬性間 使用 , 隔開



#### 刪除

```mysql
delete
語法: delete from 表格名 [where 條件]
```

```mysql
-- 刪除資料 (避免這樣寫 有些系統會限制不能這麼做 會全部刪除)
DELETE FROM `data`
-- 刪除指定數據
DELETE FROM `data` where id = 1;
```



```mysql
TRUNCATE命令
```

作用 : 完全清鏗一個資料庫表格 表格的結構和索引約束不變

```mysql
-- 清空 grate表格
truncate `grate`;
```



```
delete和truncate區別
```

- 相同處 : 都能刪除數據 都不會刪除表格的結構
- 不同處 :
  - truncate 重新設置 自增列 計數器會歸0
  - truncate 不會影響事務

```mysql
-- 刪除表格 此種作法不會影響自動增量 下次輸入會從下一個增量值開始
delete from `test` where id < 10;

-- 使用truncate 自動增量也會一起歸0
truncate table `test`;
```

delete刪除的問題 : 刪除完畢 重起資料庫 現象

- InnoDB : 自增列表會從1開始 (儲存在記憶體中,計數斷電即消失)
- MyISAM : 繼續從上一個自增量開始 (存在文件中 不會消失)



## DQL 查詢資料 (重點)

#### DQL

(Data Query LANGUAGE : 資料查詢語言)

- 所有的查詢操作都使用他 select
- 簡單的查詢 複雜的查詢都可以使用
- 資料庫中最核心的語言 最重要的部分
- 使用頻率最高的語句



#### select語法

```mysql
select[ALL | distinct]
{* | table.* | [table.field1[as alias1][.table.field2[as alias2]][...]]}
from table_name[as table_alias]
	[left | right | inner join table_name2] -- 聯合查詢
	[where ...] -- 指定結果須滿足的條件
	[group by ...] -- 指定結果按照哪幾個欄位分組
	[having] -- 過濾分組的記錄必須滿足的次要條件
	[order by ...] -- 指定查詢記錄按一個或多個條件排序
	-- 指定查詢的記錄從哪條至哪條
	[limit {[offset.]row_count | row_countOFFSET offset}];
```



#### 指定查詢欄位

```mysql
-- 列出表格 所有欄位 所有資料
select * from `grade`;
-- 查詢指定欄位  select 欄位名,欄位名 from 表格名
select `gradeid`,`gradename` from grade;
-- 別名 給結果另外定義一個名字  也可以給表格名定義新名字
-- as 可省略 但是要加上 space
select `gradeid` as `學號`,`gradename` as `年級` from grade;
-- 函數 Concat(a,b)
select concat('學號: ',gradeid) as 新學號 from grade;
```

語法 : select 欄位 .... from 表格名

```
有的時候 欄位的名字不是這麼直覺 可以用as用一個新名字表示
```



#### 去重複 distinct

- 作用 : 去除select查詢出來的結果中重複的數據 只顯示一條

```mysql
-- 查詢 grade表格中 所有的欄位
select * from grade;
-- 查詢grade表格中 score欄位
select `score` from grade;
-- 發現重複數據 去重複
select distinct `score` from grade;
```



```
資料庫的列 (表達式)
```

```mysql
-- 查詢系統版本 (函數)
select version();
-- 計算 (表達式)
select 100*3-2 as result;
-- 查詢自增的步長 (變量)
select @@auto_increment_increment;
-- 所有成績+1分
select `score`+1 as `成績` from grade;
```



資料庫中的表達式 : 文本值 , 列 , Null , 函數 , 計算表達式 , 系統變量

select 表達式 from 表格名



#### where 條件子句

作用 : 對數據中符合條件的值進行動作

條件由一個或多個表達式組成 結果 布林值

```
邏輯運算符
```

| 運算符   | 語法            | 描述   |
| -------- | --------------- | ------ |
| and  &&  | a and b  a && b | 邏輯及 |
| or  \|\| | a or b   a\|\|b | 邏輯或 |
| Not      | not a      ! a  | 邏輯非 |

配合mysql的語法  盡量使用英文字母

```mysql
--  where --
select score from grade;
-- 查詢分數 在 xx ~ yy 之間
select score from grade  where score >= 60 and score <= 80;
-- 模糊查詢 (區間)
select score from grade  where score between 60 and 80;
-- 除了 學號不等於 xx 之外的成績
select gradeid,score from grade  where gradeid != 3; 
-- != not 
select gradeid,score from grade  where not gradeid = 3; 
```



#### 模糊查詢

- 比較運算符

| 運算符      | 語法              | 描述                                         |
| ----------- | ----------------- | -------------------------------------------- |
| is null     | a is null         | 如果操作符為null 結果為true                  |
| is not null | a is not null     | 如果操作符為not null 結果為true              |
| between     | a between b and c | 若a在b和c之間 結果為true                     |
| Like        | a like b          | SQL匹配 如果a匹配b 結果為true                |
| In          | a in(a1,a2,a3)    | 假設a在a1 或者a2 其中的某一個值中 結果為true |

```mysql
-- 模糊查詢 --

-- like結合 %(代表0到任一個字元)  _(代表一個字元)
-- 查詢學號 學號中 2開頭的學號
select `gradeid`,`score` from grade where gradeid like '2%';
-- 查詢學號 學號中 2後面有一個位數的學號
select `gradeid`,`score` from grade where gradeid like '2_';
-- 查詢學號 學號中 2後面有兩個位數的學號
select `gradeid`,`score` from grade where gradeid like '2__';
-- 查詢學號 學號中 包含至少一個2的學號
select `gradeid`,`score` from grade where gradeid like '%2%';

--  in 具體的一個或是多個值 --
-- 查詢 指定欄位中 一個區間的元素
select `gradeid`,`score` from grade where gradeid in (2,3);  -- 2 ~ 3 包含

-- null  not null --
-- 查詢欄位為null  查詢score is null的元素
select `gradeid`,`score` from grade where score is null ;
-- 查詢欄位為null  查詢score is not null的元素
select `gradeid`,`score` from grade where score is not null ;
```



#### 聯表查詢 (交集問題)

![Visual_SQL_JOINS_V2](https://i.imgur.com/2zX58hv.png)



```mysql
-- join on 連接查詢
-- where   等值查詢

-- student和result產生了 studentNo的交集 
-- 必須選擇其中一方為主的student元素 去進行之後的匹配
select s.studentNo,studentName,SumjectNo,StudentResult
-- 重命名 student -> s result -> r 
-- from student 加入 inner join result的表格一起搜尋 
from student as s
inner join result as r
-- 判斷student 和 result交集的元素 返回
on s.studentNo = r.studentNo;

-- right join
select s.studentNo,studentName,SumjectNo,StudentResult
from student s
right join result t
on s.studentNo = r.studentNo;


-- left join
select s.studentNo,studentName,SumjectNo,StudentResult
from student s
left join result t
on s.studentNo = r.studentNo;


-- 要查詢哪些數據 select ..
-- 從哪幾個表格中查詢 from 表明 xxx join 連接的表格 on 交集的條件
-- 假設存在一種多張表格的查詢 先查詢兩張後慢慢的連接
```

| 操作       | 描述                                      |
| ---------- | ----------------------------------------- |
| inner join | 如果表格中至少有一個匹配 則返回行         |
| left join  | 會從左表中返回所有的值 即使右表中沒有匹配 |
| right join | 會從右表中返回所有的值 即使左表中沒有匹配 |

- inner join 內部連接 
  - 內部合併查詢指令 可以取回兩個資料表都共同存在合併欄位的資料
  - 也就是 兩個資料表都有在on關鍵字所指定的欄位的值

```mysql
-- 語法
select 想搜尋的欄位(資料表A & B都可) 
from [資料表A] 
inner Join [資料表B] 
on [資料表A].[關聯鍵] = [資料表B].[關聯鍵]
```

- left join 左外部合併查詢
  - 合併兩個資料表中 取回左邊資料表的所有記錄 就算在右邊資料表沒有存在合併欄位的值 顯示結果會以左邊資料表為主

```mysql
-- 語法
select 想搜尋的欄位(資料表A & B都可) 
from [資料表A] 
left Join [資料表B] 
on [資料表A].[關聯鍵] = [資料表B].[關聯鍵]
```

- Right join 右外部合併查詢
  - 合併兩個資料表中 取回右邊資料表的所有記錄 就算左邊資料表沒有存在合併欄位的值 顯示結果以右邊資料表為主

```mysql
-- 語法
select 想搜尋的欄位(資料表A & B都可) 
from [資料表A] right 
Join [資料表B] 
on [資料表A].[關聯鍵] = [資料表B].[關聯鍵]
```



#### on 與 where

```mysql
-- 標準查詢關鍵字執行順序
from -> where -> group by -> having -> order by
```

- on後面的篩選條件主要針對的是關聯表
- 對於主表的篩選條件應放在where後面 不應該放在on後面
- 對於關聯表要區分對待 如果是要條件查詢後才連線 應該把查詢件放置於on後 
  - 如果是想在連線完畢後才篩顯 就應把條件放置於where後
- 對於關聯表我們可以先做子查詢在座join



```
select  A.ID as AID, B1.ID as BID  
from A 
leftjoin  ( select B.ID from B  where B.ID <3 )B1 
on A.ID = B1.ID  

select  A.ID as AID, B.ID as BID  
from A 
left join B 
on A.ID = B.ID and  B.ID<3
```



#### 自連接

- 自己的表格和自己的表格連接 核心 : 一張表格拆為兩張一樣的表格即可


```mysql
create table `category`(
	`categoryid` int(10) unsigned not null auto_increment comment '主題id',
      `pid` int(10) not null comment '父id',
      `categoryName` varchar(50) not null comment '主題名字',
      primary key (`categoryid`)
)engine=InnoDB auto_increment=9 default charset=utf8;

insert into `category` (`categoryid`,`pid`,`categoryName`) 
value ('2','1','訊息技術'),
('3','1','軟體開發'),
('4','3','資料庫'),
('5','1','美術設計'),
('6','3','web開發'),
('7','5','ps技術'),
('8','2','辦公訊息');
```



父類

| category | categoryName |
| -------- | ------------ |
| 2        | 訊息技術     |
| 3        | 軟體開發     |
| 5        | 美術設計     |

子類

| pid  | catgoryid | categoryName |
| ---- | --------- | ------------ |
| 3    | 4         | 資料庫       |
| 2    | 8         | 辦公訊息     |
| 3    | 6         | web開發      |
| 5    | 7         | ps技術       |



操作 : 查詢父類對應子類關係

| 父類     | 子類     |
| -------- | -------- |
| 訊息技術 | 辦公訊息 |
| 軟體開發 | 資料庫   |
| 軟體開發 | web開發  |
| 美術設計 | ps技術   |

```mysql
-- 查詢父子訊息  把一張表看為兩個一模一樣的表

select a.`categoryName` as `父`, b.`categoryName` as `子`
from `category` as a , `category` as b
where a.`categoryid` = b.`pid`;
```



## 分頁和排序

```
排序
```

```mysql
-- 分頁 limit 和 排序 order by --

-- 排序 : 升序ASC , 降序 DESC
-- order by 通過哪一個欄位排序 怎麼排
-- 根據查詢的結果 成績排序 降序

-- 避免模糊查詢 選定一個表格查詢 s.
select s.`studentNo`,`studentName`,`subjectName`,`studentResult`
from student s
inner join `result` r
-- 選擇 s r 中相同學號進行回傳
on s.studentNo = r.studentNo
-- 選擇科目名稱為 datastructure 的資料進行回傳
where subjectName = `datastructure`
-- order by 依照studentResult結果進行升序排序
order by studentResult ASC
```



```
分頁
```

```mysql
-- 分頁 每個分頁只顯示五條數據
-- 語法 : limit 起始位置 ~ 當前頁面的大小
-- 網頁應用 : 當前頁面 總共的頁數 頁面大小
-- limit 0,5 1~5條數據
-- limit 1,5 2~6條數據
select s.`studentNo`,`studentName`,`subjectName`,`studentResult`
from student s
inner join `result` r
on s.studentNo = r.studentNo
where subjectName = `datastructure`
order by studentResult ASC
limit 0,5;
-- 第一頁 0 , 5
-- 第二頁 5 , 5
-- 第三頁 10 , 5
-- 第N頁  (N-1 * pageSize , pagesize
-- pageSize : 頁面大小
-- (n-1)* pageSize:起始值
-- n : 當前頁
-- 數據總數 / 頁面大小 + 無條件進位 = 總頁數
```

語法 : limit(查詢起始下標,pageSize)



#### 子查詢 (不常被使用)

- where
  - 本質 : 在where語句中嵌入一個子查詢語句

```mysql
-- where --
-- 查詢 datastructure 的所有考試結果 (學號 科目編號 成績) 降序排列

-- 方法一 連接查詢
-- 產生模糊查詢 需要標記查詢的表
select `studentNo`,r.`subjectNo`,`studentResult`
from `result` r
-- 連接subject表
inner join `subject` sub
on r.subjectNo = sub.subjectNo
where subjectName = 'datastructure-1'
-- 降序
order by studentResult desc;

-- 方法二 子查詢 (由內而外尋找)
-- 由內 先處理了 subject表格的subjectName
-- 向外 再處理了 result 中的subjectName比較
select `studentNo`,`studentNo`,`studentResult`
from `result`
-- 比較結果 如果 上面找尋的studentNo 與 內部尋找的結果相等
where subjectNo = (
-- 先從內部尋找 從subject表格中尋找subjectNo 且subjectNo的值須為'datastructure'
	select subjectNo from `subject`
      where subjectName = 'datastructure-1'
)
order by studentResult desc;
```

子查詢應用 : 當目前的表中沒有辦法得到相對應的數據  使用子查詢先找出關聯性

```mysql
-- 尋找同樣結果的inner join查詢
select s.studentNo,studentName
from student s
inner join result r
-- 比對兩者相同的subjectNo
on s.studentNo = r.studentNo
inner join `subject` sub 
-- 比對兩者相同的subjectNo
on s.`subjectNo` = sub.`subjectNo`
-- 先刪除除了 math-2 的資料
where `subjectName` = 'math-2' and studentResult >= 80;


-- 分數不小於80的學生 學號和姓名
select distinct `studentNo`,`studentName`
from student s
inner join result r
on r.studentNo = s.studentNo
where `studentResult` >= 80; 


-- 在以上的基礎增加科目 尋找math-2的編號 (subjectname = math-2)
select distinct `studentNo`,`studentName`
from student s
inner join result r
-- 尋找 兩個表格中相等的學號
on r.studentNo = s.studentNo
-- 尋找分數大於80 且 科目名 = math-2的學號
where `studentResult` >= 80 and `subjectNo`   = (
-- 科目的資訊要從subject尋找 選擇出subjectName = 'math-2'的資料
-- 回傳的資料為 科目名為 math-2 的subjectNo
	select `subjectNo`
      from `subject`
      where `subjectName` = 'math-2'
)

-- 再改造 (由內到外) --
select studentNo,studentName from student where studentNo in(
-- where尋找 studentNo 而 studentNo需要是高於80分的結果
	select studentNo from where studentResult>80 and subjectNo = (
-- where尋找 subjectNo 而 subjectNo的名稱要是 math-2
    	select subjectNo from `subject` where `subjectName` = 'math-2'
    )
)
```



## MySQL函數

#### 常用函數

```mysql
-- 常用函數 -- 
-- 數學運算
select abs(-8); -- 絕對值
select ceiling(9.4); -- 向上取整
select floor(9.4); -- 向下取整
select rand(); -- 返回一個0~1之間的隨機數
select sign(-10); -- 判斷一個數的符號 正數返回1 負數返回-1
 
-- 字串函數 --
select char_length('asdfgh'); -- 字串長度 
select concat('asdfgh','dfgh','1234'); -- 字串拼接
-- 從第一個位址移除兩個元素後 從第一個位址放入替換的字串 跟程式語言的起始位址有些不同
select insert('ABCDEF',1,2,'XYZ'); 
select lower('ABCDefg'); -- 轉小寫
select upper('ABCDefg'); -- 轉大寫
-- 返回第一次出現字串的索引 == 2 找不到則為0
select instr('ABCD','BC'); 
select replace('abcdefAAgg','AA','CC'); -- 替換出現的指定字串
select substr('ABCDEFGHIJ',4,6); -- 返回指定子字串 從第4個開始往後6個
select reverse('abcde'); -- 反轉
 
-- 時間日期函數 --
select current_data(); -- 獲取目前日期
select curdate(); -- 獲取目前日期
select now(); -- 獲取目前時間
select location(); -- 本地時間
select sysdate(); -- 系統時間
 
select year(now()); 
select month(now()); 
select day(now()); 
select minute(now()); 
select second(now()); 
 
-- 系統 --
select system_user();
select user();
select version();
```



#### 聚合函數(常用)

| 函數名稱 | 描述   |
| -------- | ------ |
| count()  | 計數   |
| sum()    | 求和   |
| avg()    | 平均值 |
| max()    | 最大值 |
| min()    | 最小值 |

```mysql
-- 聚合函數 -- 
-- 統計表中的數據
select count(`borndate`) from student; -- count 指定列 忽略所有的null
select count(*) from result; -- count(*) 不會忽略null值 本質 計算行數
select count(1) from result; -- count(1) 不會忽略null值 本質 計算行數

select sum(`studentResult`) as 總和 from result;
select avg(`studentResult`) as 平均分 from result;
select max(`studentResult`) as 最高分 from result;
select min(`studentResult`) as 最低分 from result;
```



```
分組與過濾
```

```mysql
-- 查詢不同課程的平均分 最高分 最低分 且平均分大於80
-- 核心 : 根據不同的課程分組
select subjectName , avg(studentResult) as `AVG` , max(studentResult) , min(studentResult)
from `result` r
inner join `subject` sub
-- 當r 和 sub表中的 subjectNo相等時
on r.`subjectNo` = sub.`subjectNo`
-- 藉由 r的subjectNo進行分組
group by r.subjectNo 
-- 判斷平均分大於80
having AVG > 80;
```



#### 資料庫的MD5加密

- md5 : 增強算法複雜度和不可逆性
- md5不可逆 

```mysql
-- 查詢表格
select * from(`testmd5`);

-- md5加密 測試 --
create table `testmd5`(
	`id` int(4) not null,
      `name` varchar(20) not null,
      `pwd` varchar(50) not null,
      primary key(`id`)
)engine=innodb default charset=utf8;

-- 明文密碼
insert into `testmd5` values(1,'AAA','123456'),(2,'BBB','123456'),(3,'CCC','123456');

-- 加密
update testmd5 set pwd=md5(pwd) where id = 1;
update testmd5 set pwd=md5(pwd);

-- 插入資料時加密
insert into `testmd5` values(4,'DDD',md5('123456'));

-- 如何校驗 將用戶傳遞的密碼 進行md5加密 兩者比較加密後的值
select * from `testmd5` where `name` = 'AAA' and pwd = md5('123456');

```



## 事務

- 事務 : 都成功 or 都失敗
  - SQL 執行 A 轉帳給 B  如果一方成功 一方失敗 會產生問題
- 將一組SQL放在一個批次中執行

```
事務原則 : ACID原則 原子性 一致性 隔離性 持久性 
```



#### 原子性 Atomicity

- 表示兩個步驟一起成功 或是 一起失敗 不能只發生其中一個動作
  - 也就是轉帳的人所付出的錢 要是收到的人所收到的錢

#### 一致性 Conststency

- 事務前後的數據完整性要保持一致
- 無論進行了什麼步驟 最後兩者相加的結果會是一樣的
  - 轉帳的人及被轉帳的人 兩者相加起來的金額會是一樣的

#### 持久性 Durability

- 針對多個用戶間同時操作 主要是排除其他事務對此次事務的影響

#### 隔離性 Isolation

- 事務結束後的數據不會隨著外界原因導致數據丟失
- 如果事務沒有提交 恢復到原狀
- 如果事務已經提交 持久化到數據庫
- 事務一旦提交就不可逆



#### 隔離級別

##### 髒讀

- 指一個事務讀取了另外一個事務尚未提交的數據

##### 不可重複讀

- 在一個事務內讀取表的某一行數據 多次讀取結果不同 (不一定是錯誤 只是某些場合不對)
- t1讀取了一個數據後 t2更新了該數據並提交了 之後t1又讀取該數據 發現前後讀取的數據不一樣

##### 幻讀

- 指一個事務內讀取到了別的事務插入的數據 導致前後讀取不一致 
- 一般是行影響 多了一行



#### 執行事務

```mysql
-- mysql 預設開啟事務是自動提交的
set autocommit = 0; -- 關閉
set autocommit = 1; -- 開啟 (預設)
-- 手動處理事務
set autocommit = 0; -- 關閉自動提交

-- 事務開啟
start transaction; -- 標記一個事務的開始 從這個之後的sql都在同一個事務內
-- 提交 : 持久化(成功)
commit;
-- 回滾 : 回到原來的樣子 (失敗)
rollback;
-- 事務結束 
set autocommit = 1; -- 開啟自動提交

-- 了解
savepoint test; -- 保存點名  設置事務的保存點
rollback to savepoint; -- 回滾到保存點
release savepoint test; -- 刪除保存點
```



模擬

```mysql
-- 轉帳
create database shop character set utf8 collate utf8_general_ci;
use shop;
-- 查看表格
select * from `account`;
create table `account`(
	`id` int(3) not null auto_increment,
      `name` varchar(30) not null,
      `money` decimal(9,2) not null,
      primary key(`id`)
)engine=innodb default charset=utf8;

insert into account(`name`,`money`) values ('AA',2000.00),('BB',1000.00);

-- 模擬轉帳 事務
set autocommit = 0; -- 關閉自動提交
start transaction; -- 開啟一個事務
update account set money=money-500 where `id` = '1';
update account set money=money+500 where `id` = '2';
commit;-- 提交事務
rollback; -- 回滾
set autocommit = 1; -- 恢復預設值
```



## 索引



#### 索引的分類

- 主鍵索引 (PRIMARY KEY)
  - 唯一的標誌 主鍵不可以重複 只能有一個裂作用主鍵
- 唯一索引 (UNIQUE KEY)
  - 標誌的是列名唯一 不同的列名都可以加入標誌 避免同一列中的資料重複
  - 避免重複的列出現 唯一索引可以重複 多個列都可以標誌為唯一索引
- 常規索引 (KEY / INDEX)
  - 預設 index key關鍵字來設置
- 全文索引 (FullText)
  - 在特定的資料庫引擎下才有 MyISAM
  - 快速定位資料



#### 基礎語法

```mysql
-- 索引的使用
-- 創建表的時候給欄位增加索引
-- 創建完畢後 增加索引

-- 顯示所有的索引訊息
show index from grade;
-- 增加一個全文索引列名
alter table grade.student add fulltext index `studentName`(`studentName`);
-- explain 分析sql執行的狀況
explain select * from student; -- 非全文索引
explain select * from student Where match(studentName) against('A');
```



#### 索引原則

- 索引不是越多越好
- 不要對經常變動的數據加索引
- 小數據量的表不需要加索引
- 索引一般加在常用來查詢的欄位



```
索引的數據結構
```

Hash類型的索引

Btree : InnoDB的預設數據



## 權限管理與備份



#### MySQL備份

為什麼要備份 : 

- 保證資料不會丟失
- 資料轉移

MySQL資料庫備份的方式

- 直接複製物理文件
- 在可視化工具中手動導出
- 使用命令行導出 mysqldump 命令行使用

```
# mysqldump -hlocalhost -u用戶名 -p密碼 資料庫名 表格名 > 導出位置
mysqldump -hlocalhost -uroot -p123456 SQL_FIRST grade > C:\Users\Desktop
```



## 規範資料庫設計

當資料庫比較複雜的時候 需要設計

- 糟糕的資料庫設計 : 
  - 數據冗余 浪費空間
  - 數據庫插入和刪除麻煩 異常
  - 性能差
- 良好的資料庫設計 : 
  - 節省記憶體空間
  - 保證資料庫的完整性
  - 方便開發系統



#### 軟體開發中 關於資料庫的設計

- 分析需求 : 分析業務和需要處理的資料庫需求
- 概要設計 : 設計關係圖 E-R圖



#### 設計資料庫的步驟

- 蒐集資訊 分析需求
- 個人部落格
  - 用戶表 (用戶登入登出 用戶個人訊息 創建分類)
  - 分類表 (文章分類 創建人)
  - 文章表 (文章訊息)
  - 鏈結表
  - 自定義表 (系統訊息 關鍵字 主字段) key : value



#### 三大范式

數據規範化的理由

- 訊息重複
- 更新異常
- 插入異常
  - 無法正常顯示訊息
- 刪除異常
  - 丟失有效的訊息



```
三大范式
```

#### 第一范式 (1NF)

- 原子性 : 保證每一列不可再分
  - 無重複的列

#### 第二范式 (2NF)

- 滿足第一范式的前提
- 完全依賴 (非部分依賴)
- 屬性完全依賴於主鍵 (消除部分子函數依賴)
- 每張表只描述一件事情

#### 第三范式 (3NF)

- 滿足第二范式的前提
- 直接依賴 (非間接依賴)
- 屬性不依賴於其他非主屬性 (消除傳遞依賴)
  - 傳遞依賴 : a到b b到c 而a能到c 必須消除這種關係
- 假設建立一個訂單表 需要建立一個客戶編號作為外鍵與訂單表建立相應的關係
  - 不能直接在訂單表中添加客戶的其他訊息



#### 規範性 和 性能的問題

關聯查詢的表不能超過三張

- 考慮商業化的需求和目標 (成本 用戶體驗) 資料庫的性能更加重要
- 再規範性能的問題時 需要適當的考慮一下規範性
- 故意給某些表增加一些冗余的欄位 (從多表查詢變為單表查詢)
  - 訂單 + 商品id  -->  訂單 + 商品訊息  減少查詢id的時間
- 故意增加一些計算列 (從大數據量降低為小數據量的查詢 : 索引)



## JDBC

#### 資料庫驅動程式

- 程式會通過資料庫驅動程式與資料庫進行連接
  - 應用程式 --> MySQL驅動 -- > 資料庫

#### JDBC

- 為了簡化對資料庫統一的操作 提供了一個java操作資料庫的規範
  - 應用程式 -- > JDBC --> MySQL驅動 --> 資料庫



#### JDBC程式

```
創建測試資料庫
```

```mysql
-- JDBC --
create database jdbcstudy character set utf8 collate utf8_general_ci;

use jdbcstudy;
select * from `users`;

create table users(
	id int primary key,
      name varchar(40),
      password varchar(40),
      email varchar(60),
      birthday date
);
insert into users(id,name,password,email,birthday)
values(1,'AAA','123456','AAAA.com','2000-1-1'),
(2,'BBB','123456','BBBB.com','2000-1-2'),
(3,'CCC','123456','CCCC.com','2000-1-3');
```



#### 導入資料庫驅動

下載mysql-connector-java 導入裡面的jar包至lib中



#### 測試程式

```java
package com;

import java.sql.*;

public class JDBC01 {
    public static void main(String[] args) throws ClassNotFoundException, SQLException {
        
        // 1. 載入驅動
        // 拋出異常 ClassNotFoundException
        Class.forName("com.mysql.cj.jdbc.Driver"); // 固定寫法 載入驅動
        
        // 2. 用戶訊息和url
        // useUnicode=true 支持中文 & characterEncoding=utf8 設定字元為utf8 &
        // useSSL=true 使用安全連接  serverTimezone=UTC 時區 (8.0以後可能需要)
        String url = "jdbc:mysql://localhost:3306/jdbcstudy?serverTimezone=UTC&useUnicode=true&characterEncoding=utf8&useSSL=true";
        String username = "root";
        String password = "123456";
        
        // 3. 連接成功 返回資料庫對象
        // 拋出異常 SQLException
        // Connection 代表資料庫 不為空代表已經取得資料庫
        Connection connection = DriverManager.getConnection(url, username, password);

        // 4. 執行SQL的對象
        // Statement 執行SQL的對象
        Statement statement = connection.createStatement();
        
        // 5. 執行SQL的對象去執行SQL 可能存在結果 查看返回結果
        String sql = "select * from `users`";
        // Query查詢 update更新刪除插入
        // 返回的結果 結果集中封裝了我們全部查詢出來的結果
        ResultSet resultSet = statement.executeQuery(sql);
        while(resultSet.next()){
            System.out.println("id = " + resultSet.getObject("id"));
            System.out.println("name = " + resultSet.getObject("name"));
            System.out.println("password = " + resultSet.getObject("password"));
            System.out.println("email = " + resultSet.getObject("email"));
            System.out.println("birthday = " + resultSet.getObject("birthday"));
        }
        
        // 6. 釋放連接
        resultSet.close();
        statement.close();
        connection.close();
    }
}

```



#### 步驟總結

- 載入驅動
- 連接資料庫 DriverManager
- 獲取執行SQL的對象 Statement
- 獲得返回的結果集 
- 釋放連接



```
DriverManager
```

```java
// 1. 載入驅動
        // 拋出異常 ClassNotFoundException
        Class.forName("com.mysql.cj.jdbc.Driver"); // 固定寫法 載入驅動
        // 不建議使用此種載入方式 因為new物件的時候 類別裡會再進行一次載入 等於載入兩次
        DriverManager.registerDriver(new com.mysql.cj.jdbc.Driver());

// connection 代表資料庫
// 資料庫設置自動提交
// 事務提交
// 事務回滾
connection.rollback();
connection.commit();
connection.setAutoCommit();
```



```
URL
```

```java
String url = "jdbc:mysql://localhost:3306/jdbcstudy?serverTimezone=UTC&useUnicode=true&characterEncoding=utf8&useSSL=true";
// mysql -- 3306        
// 協議 ://主機地址:連接埠/資料庫名?參數1&參數2&參數3

// oralce -- 1521
// jdbc:oracle:think@localhost:1521:sid
```



```
Statement 執行SQL的對象  PrepareStatement執行SQL的對象
```

```java
String sql = "select * from `users`"; // 編寫SQL

statement.executeQuery(); // 查詢操作返回 ResultSet
statement.execute(); // 執行任何SQL
statement.executeUpdate(); // 更新 插入 刪除 都是用這個語句 返回一個受影響的行數
```



```
ResultSet 查詢的結果集 : 封裝了所有的查詢結果
```

獲取指定的資料類型

```java
// 不知道列類型的情況下使用
resultSet.getObject(); 
// 知道列的指定類型使用
resultSet.getString();
resultSet.getInt();
resultSet.getFloat();
resultSet.getDate();
```



```
遍歷 
```

```java
resultSet.beforeFirst(); // 移動到最前面
resultSet.afterLast(); // 移動到最後面
resultSet.next(); // 移動到下一個數據
resultSet.previous(); // 移動到前一行
resultSet.absolute(); // 移動到指定行
```



```
釋放資源 耗資源 用完關閉
```

```
// 6. 釋放連接
resultSet.close();
statement.close();
connection.close();
```



#### Statement對象

- JDBC中的statement對象用於向資料庫發送SQL語句 想完成對資料庫的增刪改查 只需要通過這個對象向資料庫發送增刪改查語句即可
- executeUpdate方法 用於向資料庫發送增,刪,改的SQL語句
- executeUpdate執行完後 將會返回一個整數 (即增刪改查語句導致了資料庫幾行數據發生了變化)
- statement.executeQuery方法用於向資料庫發送查詢語句 executeQuery方法返回代表查詢結果的ResultSet對象



```
CRUD操作 - create
```

使用executeUpdate(String sql)方法完成資料添加操作

```java
Statement st = conn.createStatement();
String sq1 = "insert into user(...)values(...)";
int num = st.executeUpdate(sq1);
if(num>0){
	System.out.println("插入成功!");
}
```



```
CRUD操作 - delete
```

```java
Statement st = conn.createStatement();
String sq1 = "delete from user where id=1";
int num = st.executeUpdate(sq1);
if(num>0){
	System.out.println("刪除成功!");
}
```



```
CRUD操作 - update
```

```java
Statement st = conn.createStatement();
String sq1 = "update user set name ='' where name=''";
int num = st.executeUpdate(sq1);
if(num>0){
	System.out.println("修改成功!");
}
```



```
CRUD操作 - read
```

```java
Statement st = conn.createStatement();
String sq1 = "select * from user where id=1";
ResultSet rs = st.executeQuery(sql);
while(rs.next()){
    // 根據獲取列的數據類型 分別調用rs的相應方法映射到java對象中
}
```



```
程式實現
```



定義用戶訊息及URL

db.properties

```java
driver=com.mysql.cj.jdbc.Driver
url=jdbc:mysql://localhost:3306/jdbcstudy?useUnicode=true&characterEncoding=utf8&useSSL=true
username=root
password=123456
```



提取工具類

```java
package com;

import java.io.IOException;
import java.io.InputStream;
import java.sql.*;
import java.util.Properties;

public class JDBC02 {
    private static String driver = null;
    private static String url = null;
    private static String username = null;
    private static String password = null;
    static {
        try{
            InputStream in = JDBC02.class.getClassLoader().getResourceAsStream("db.properties");
            Properties properties = new Properties();
            properties.load(in);
            // 固定寫法 獲取某一個資源
            driver = properties.getProperty("driver");
            url = properties.getProperty("url");
            username = properties.getProperty("username");
            password = properties.getProperty("password");

            // 驅動只要載入一次
            Class.forName(driver);

        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
        // 獲取連接
        public static Connection getConnection() throws SQLException {
                return DriverManager.getConnection(url, username, password);
        }
        // 釋放連接資源
        public static void release(Connection con, Statement st, ResultSet rs){
                if(rs != null){
                try {
                    rs.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }

                if(st != null){
                    try {
                        st.close();
                    } catch (SQLException e) {
                        e.printStackTrace();
                    }
                }
                if(con != null){
                    try {
                        con.close();
                    } catch (SQLException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
}
```



編寫增刪改 executeUpdate 套用之前的方法化 簡化做法

##### insert

```java
package com;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

public class TestInsert {
    public static void main(String[] args) {
        Connection conn = null;
        Statement st = null;
        ResultSet rs = null;

        try {
            // 簡化 直接使用getConnection 固定用法
            conn = JDBC02.getConnection(); // 獲取資料庫連接
            st = conn.createStatement(); // 獲得SQL的執行對象
            // SQL語句
            String sql = "insert into users(id,name,password,email,birthday)" +
                    "values(4,'DDD','123456','DDDD.com','2000-1-4');";
            // 更新 更新完回傳結果
            int i = st.executeUpdate(sql);
            if(i > 0){
                System.out.println("更新成功!");
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            // 釋放資源
            JDBC02.release(conn,st,rs);
        }
    }
}
```

##### Delete

```
package com;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

public class TestDelete {
    public static void main(String[] args) {
        Connection conn = null;
        Statement st = null;
        ResultSet rs = null;

        try {
            // 簡化 直接使用getConnection 固定用法
            conn = JDBC02.getConnection(); // 獲取資料庫連接
            st = conn.createStatement(); // 獲得SQL的執行對象
            // SQL語句
            String sql = "delete from users where id = 4;";
            // 更新 更新完回傳結果
            int i = st.executeUpdate(sql);
            if(i > 0){
                System.out.println("刪除成功!");
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            // 釋放資源
            JDBC02.release(conn,st,rs);
        }
    }
}
```

##### Update

```java
package com;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

public class TestUpdate {
    public static void main(String[] args) {
        Connection conn = null;
        Statement st = null;
        ResultSet rs = null;

        try {
            // 簡化 直接使用getConnection 固定用法
            conn = JDBC02.getConnection(); // 獲取資料庫連接
            st = conn.createStatement(); // 獲得SQL的執行對象
            // SQL語句
            String sql = "update users set `name` = 'ABC' ,`email` = 'ABC.com'where id = 1";
            // 更新 更新完回傳結果
            int i = st.executeUpdate(sql);
            if(i > 0){
                System.out.println("更新成功!");
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            // 釋放資源
            JDBC02.release(conn,st,rs);
        }
    }
}
```



##### select

```java
package com;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

public class TestSelect {
    public static void main(String[] args) {
        Connection conn = null;
        Statement st = null;
        ResultSet rs = null;
        try {
            conn = JDBC02.getConnection();

            st = conn.createStatement();
            // SQL
            String sql = "select * from users where id = 1";
            rs = st.executeQuery(sql); // 查詢完畢返回一個結果集
            while(rs.next()){
                System.out.println(rs.getString("name"));
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            JDBC02.release(conn,st,rs);
        }
    }
}
```



#### SQL注入問題

sql存在漏洞 會被攻擊導致資料洩漏 ==SQL會被拼接 or == 



正常情況 正確輸入時返回username password

```java
package com;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

public class SQLinjection {
    public static void main(String[] args) {
        login("ABC","123456");
    }
    //登入
    public static void login(String username,String password){
        Connection conn = null;
        Statement st = null;
        ResultSet rs = null;
        try {
            conn = JDBC02.getConnection();

            st = conn.createStatement();
            // select * from users where `name` = 'ABC' and `password` = '123456';
            String sql = "select * from users where `name` ='" + username + "' AND `password` ='" + password + "'";
            rs = st.executeQuery(sql); // 查詢完畢返回一個結果集
            while(rs.next()){
                System.out.println(rs.getString("name"));
                System.out.println(rs.getString("password"));
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            JDBC02.release(conn,st,rs);
        }
    }
}
```



從登入的輸入條件進行攻擊

```java
login(" 'or' 1=1 ","123456");
login(" 'or' 1=1 "," 'or' 1=1 ");
從
String sql = "select * from users where `name` ='" + username + "' AND `password` ='" + password + "'";
變成了
String sql = "select * from users ";
```



#### PreparedStatement對象

防止SQL注入問題 效率更好



##### 新增

```java
package com.PreparedStatement;
import java.sql.*;
import  java.util.Date;

public class TestInsert {
    public static void main(String[] args) {
        Connection conn = null;
        PreparedStatement pst = null;
        try {
            conn = JdbcUtils.getConnection();
            // 區別
            // 使用 ? 代替參數
            String sql = "insert into users(id,name,password,email,birthday) values(?,?,?,?,?)";
            pst = conn.prepareStatement(sql); // 需要先寫入SQL參數 先不執行

            // 手動給參數賦值 1 ~ 5 代表剛定義的第n個參數
            pst.setInt(1,4); // id
            pst.setString(2,"'DDD'"); // name
            pst.setString(3,"123456"); // password
            pst.setString(4,"DDDD.com"); // email
            // sql.Date   資料庫  java.sql.Date()
            // Util.Date  java   new Date().getTime() 獲得時間戳
            pst.setDate(5,new java.sql.Date(new Date().getTime())); // birthday

            // 執行
            int i = pst.executeUpdate();
            if(i > 0){
                System.out.println("插入成功");
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
```



##### 刪除

```java
package com.PreparedStatement;
import java.sql.*;

public class TestDelete {
    public static void main(String[] args) {
        Connection conn = null;
        PreparedStatement pst = null;

        try {
            conn = JdbcUtils.getConnection();
            // 區別
            // 使用 ? 代替參數
            String sql = "delete from users where id = ?";
            pst = conn.prepareStatement(sql); // 需要先寫入SQL參數 先不執行
            // 手動給參數賦值
            pst.setInt(1,4); // id = 4
            // 執行
            int i = pst.executeUpdate();
            if(i > 0){
                System.out.println("刪除成功");
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
```



##### 更新

```java
package com.PreparedStatement;

import java.sql.*;

public class TestUpdate {
    public static void main(String[] args) {
        Connection conn = null;
        PreparedStatement pst = null;

        try {
            conn = JdbcUtils.getConnection();
            // 區別
            // 使用 ? 代替參數
            String sql = "Update users set `name` = ? where id = ?";
            pst = conn.prepareStatement(sql); // 需要先寫入SQL參數 先不執行

            // 手動給參數賦值
            pst.setString(1,"AAA"); // name 更改為
            pst.setInt(2,1); // id = 1

            // 執行
            int i = pst.executeUpdate();
            if(i > 0){
                System.out.println("更新成功");
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
```



##### 查詢

與增刪改稍有不同

```java
package com.PreparedStatement;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class TestSelect {
    public static void main(String[] args) {
        Connection conn = null;
        PreparedStatement pst = null;
        ResultSet rs = null;
        // 獲取連接
        try {
            conn = JdbcUtils.getConnection();
            String sql = "select * from users where id = ?";
            conn.prepareStatement(sql);

            pst.setInt(1,1); // 第一個參數id 設置為1
            // 執行
            rs = pst.executeQuery();
            while(rs.next()){
                System.out.println(rs.getString("name"));
            }

        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            JdbcUtils.release(conn,pst,rs);
        }

    }
}
```



##### 防止SQL注入

使用PreparedStatement對象防止

```java
package com.PreparedStatement;

import java.sql.*;
import com.PreparedStatement.JdbcUtils;

public class SQLinjection {
    public static void main(String[] args) {
        login("AAA","123456");
        //login(" 'or' 1=1 ","123456");
    }
    //登入
    public static void login(String username,String password){
        Connection conn = null;
        PreparedStatement pst = null;
        ResultSet rs = null;
        try {
            conn = JdbcUtils.getConnection();
            // PreparedStatement 防止SQL注入的本質 把傳遞進來的參數當作字元
            // 假設其中存在轉譯字元 直接忽略  ex  ' 直接轉譯
            String sql = "select * from users where `name` = ? and `password` = ?"; // mybatis
            pst = conn.prepareStatement(sql);
            pst.setString(1,username);
            pst.setString(2,password);
            // 查詢完畢返回一個結果集
            rs = pst.executeQuery();

            while(rs.next()){
                System.out.println(rs.getString("name"));
                System.out.println(rs.getString("password"));
                System.out.println("--------------");
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            JdbcUtils.release(conn,pst,rs);
        }
    }
}
```



#### IDEA連接資料庫

- 開啟IEAD右邊欄位Database

- IDEA測試連接

DBMS: MySQL (ver. 8.0.27)
Case sensitivity: plain=lower, delimited=lower
Driver: MySQL Connector/J (ver. mysql-connector-java-8.0.25 (Revision: 08be9e9b4cba6aa115f9b27b215887af40b159e0), JDBC4.2)
Ping: 44 ms
SSL: yes

- 連接成功後 選擇資料庫 --> jdbcstudy

![擷取_2021_12_16_21_13_12_845](https://i.imgur.com/F25nPdH.png)



#### 事務

都成功或是都失敗

```
ACID原則
```

原子性 : 全都完成或是全都失敗

一致性 : 總數不變

**隔離性 : 多個進程互不干擾**

持久性 : 一旦提交不可逆 持久化到資料庫



隔離性問題 : 

髒讀 :  一個事務讀取了另一個沒有提交的事物

不可重複讀 : 在同一個事務內 重複讀取表中的數據 表中的數據發生了變化

虛讀(幻讀) : 在一個事務內 讀取到了別人插入的數據 導致前後讀出的結果不一致 



```
程式實現
```

1. 開啟事務 **conn.setAutoCommit(false);**
2. 一組業務執行完畢 提交事務 **pst.executeUpdate();**
3. 可以在catch語句中 顯示定義的rollback語句 執行失敗時則回復

```java
package transaction;

import com.PreparedStatement.JdbcUtils;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class Testtransaction01 {
    public static void main(String[] args) {
        Connection conn = null;
        PreparedStatement pst = null;
        ResultSet rs = null;

        try {
            conn = JdbcUtils.getConnection();
            // 關閉資料庫的自動提交 自動開啟事務
            conn.setAutoCommit(false); // 開啟事務
            // sql語句
            String sql1 = "update account set money = money - 100 where name = 'A'";
            pst = conn.prepareStatement(sql1);
            pst.executeUpdate();
            String sql2 = "update account set money = money + 100 where name = 'B'";
            pst = conn.prepareStatement(sql2);
            pst.executeUpdate();
            // 業務完畢 提交事務
            conn.commit();
            System.out.println("成功");
        } catch (SQLException e) {
            try {
                conn.rollback(); // 失敗的話回滾回執行前的狀態
            } catch (SQLException ex) {
                ex.printStackTrace();
            }
            e.printStackTrace();
        }finally {
            JdbcUtils.release(conn,pst,rs);
        }
    }
}
```



#### 資料庫連接池

資料庫連接 -- 執行完畢  -- 釋放   

連接 -- 釋放 十分浪費系統資源

- 池化技術 : 準備一些預先的資源 過來就連接預先準備好的資源
  - 最小連接數 10
  - 最大連接數 15 業務最大乘載上限
  - 等待超時 : 100ms

編寫連接池 --> 實作一個介面 DataSource



```
DBCP
```

導入

commons-pool2-2.11.1.jar

commons-dbcp2-2.9.0.jar

出現 Could not initialize class 錯誤

須多導入一個 commons-logging-1.2.jar



DBCP 配置文件格式

```
#  連接設置  裡面的名字是DBCP數據源定義完成的
driverClassName=com.mysql.cj.jdbc.Driver
url=jdbc:mysql://localhost:3306/jdbcstudy?userUnicode=true&characterEncoding=utf8&uesSSL=true
username=root
password=123456

#<!-- 初始化連接 -->
initialSize=10

#最大連接數量
maxActive=50

#<!-- 最大空閒連接 -->
maxIdle=20

#<!-- 最小空閒連接 -->
minIdle=5

#<!-- 超時等待時間以毫秒為單位 6000毫秒/1000等於60秒 -->
maxWait=60000#JDBC驅動建立連接時附帶的連接屬性 屬性的格式必須為這樣 :【屬姓名=property;】 
#注意："user" 與 "password" 兩個屬性會被明確地傳遞，因此這裡不需要包含他們
connectionProperties=useUnicode=true;characterEncoding=utf8

#指定由連接池所創建的連接的自動提交（auto-commit）狀態
defaultAutoCommit=true

#driver default 指定由連接池所創建的連接的唯獨（read-only）狀態。
#如果沒有設置該值 則“setReadOnly”方法將不被調用 （某些驅動並不支持唯獨模式，如：Informix）
defaultReadOnly=

#driver default 指定由連接池所創建的連接的事務級別(TransactionIsolation）。
#可用值為下列之一：（可見javadoc。）NONE,READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ, SERIALIZABLE
defaultTransactionIsolation=READ_COMMITTED
```



DBCP 啟動及關閉文件

```java
package DBCP;

import org.apache.commons.dbcp2.BasicDataSourceFactory;

import javax.sql.DataSource;
import java.io.InputStream;
import java.sql.*;
import java.util.Properties;

public class JdbcUtils_DBCP {
    private static DataSource dataSource = null;

    static {
        try{
            // 載入文件
            InputStream in = JdbcUtils_DBCP.class.getClassLoader().getResourceAsStream("dbcpconfig.properties");
            Properties properties = new Properties();
            // 將文件載入流
            properties.load(in);
            // 創建數據源 工廠模式 --> 創建對象
            dataSource = BasicDataSourceFactory.createDataSource(properties);

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    // 獲取連接
    public static Connection getConnection() throws SQLException {
        return dataSource.getConnection(); // 從數據源中獲取連接
    }
    // 釋放連接資源
    public static void release(Connection con, Statement st, ResultSet rs){
        if(rs != null){
            try {
                rs.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }

            if(st != null){
                try {
                    st.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
            if(con != null){
                try {
                    con.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```



DBCP 測試程式

```java
package DBCP;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.Date;
public class TestDBCP {
    public static void main(String[] args) {
        Connection conn = null;
        PreparedStatement pst = null;
        try {
            conn = JdbcUtils_DBCP.getConnection();
            // 區別
            // 使用 ? 代替參數
            String sql = "insert into users(id,name,password,email,birthday) values(?,?,?,?,?)";
            pst = conn.prepareStatement(sql); // 需要先寫入SQL參數 先不執行
            // 手動給參數賦值 1 ~ 5 代表剛定義的第n個參數
            pst.setInt(1,4); // id
            pst.setString(2,"DDD"); // name
            pst.setString(3,"123456"); // password
            pst.setString(4,"DDDD.com"); // email
            // sql.Date   資料庫  java.sql.Date()
            // Util.Date  java   new Date().getTime() 獲得時間戳
            pst.setDate(5,new java.sql.Date(new Date().getTime())); // birthday
            // 執行
            int i = pst.executeUpdate();
            if(i > 0){
                System.out.println("插入成功");
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            JdbcUtils_DBCP.release(conn,pst,null);
        }
    }
}
```



```
C3P0
```

導入

mchange-commons-java-0.2.20.jar

c3p0-0.9.5.5.jar







C3P0 配置文件格式

```xml
<?xml version="1.0" encoding="UTF-8"?>
<c3p0-config>
    <!--
c3p0的預設配置
如果在程式中"ComboPooledDataSource ds=new ComboPooledDataSource();"表示使用C3P0的預設數據-->
    <default-config>
        <property name="driverClass">com.mysql.cj.jdbc.Driver</property>
        <property name="jdbcUrl">jdbc:mysql://localhost:3306/jdbcstudy?userUnicode=true＆characterEncoding=utf8＆uesSSL=true＆serverTimezone=UTC</property>
        <property name="user">root</property>
        <property name="password">123456</property>

        <property name="acquireIncrement">5</property>
        <property name="initialPoolSize">10</property>
        <property name="minPoolSize">5</property>
        <property name="maxPoolSize">20</property>
    </default-config>
<!--  C3P0的命名配置  ComboPooledDateSource ds = new ComboPooledDataSource("MySQL"); 寫入MySQL表示使用MySQL數據 為空則使用預設 -->
    <named-config name="MySQL">
        <property name="driverClass">com.mysql.cj.jdbc.Driver</property>
        <property name="jdbcUrl">jdbc:mysql://localhost:3306/jdbcstudy?userUnicode=true＆characterEncoding=utf8＆uesSSL=true＆serverTimezone=UTC</property>
        <property name="user">root</property>
        <property name="password">123456</property>

        <property name="acquireIncrement">5</property>
        <property name="initialPoolSize">10</property>
        <property name="minPoolSize">5</property>
        <property name="maxPoolSize">20</property>
    </named-config>
</c3p0-config>
```



C3P0 啟動及關閉文件

```java
package C3P0;

import com.mchange.v2.c3p0.ComboPooledDataSource;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

public class JdbcUtils_C3P0 {
    private static ComboPooledDataSource dataSource = null;

    static {
        try{
            // xml只要放在source文件的src下就會自動導入 不需額外導入

            // 程式配置
//            dataSource = new ComboPooledDataSource();
//            dataSource.setDriverClass();
//            dataSource.setUser();
//            dataSource.setPassword();
//            dataSource.setJdbcUrl();
//
//            dataSource.setMaxPoolSize();
//            dataSource.setMinPoolSize();

            // 創建數據源 配置文件寫法
            dataSource = new ComboPooledDataSource("MySQL");


        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    // 獲取連接
    public static Connection getConnection() throws SQLException {
        return dataSource.getConnection(); // 從數據源中獲取連接
    }
    // 釋放連接資源
    public static void release(Connection con, Statement st, ResultSet rs){
        if(rs != null){
            try {
                rs.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }

            if(st != null){
                try {
                    st.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
            if(con != null){
                try {
                    con.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```



C3P0 測試程式

```java
package C3P0;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.Date;

public class TestC3P0 {
    public static void main(String[] args) {
        Connection conn = null;
        PreparedStatement pst = null;

        try {
            conn = JdbcUtils_C3P0.getConnection(); // 原來是自己實現的 現在用別人實現的
            // 區別
            // 使用 ? 代替參數
            String sql = "insert into users(id,name,password,email,birthday) values(?,?,?,?,?)";
            pst = conn.prepareStatement(sql); // 需要先寫入SQL參數 先不執行

            // 手動給參數賦值 1 ~ 5 代表剛定義的第n個參數
            pst.setInt(1,5); // id
            pst.setString(2,"DDD"); // name
            pst.setString(3,"123456"); // password
            pst.setString(4,"DDDD.com"); // email
            // sql.Date   資料庫  java.sql.Date()
            // Util.Date  java   new Date().getTime() 獲得時間戳
            pst.setDate(5,new java.sql.Date(new Date().getTime())); // birthday

            // 執行
            int i = pst.executeUpdate();
            if(i > 0){
                System.out.println("插入成功");
            }


        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            JdbcUtils_C3P0.release(conn,pst,null);
        }
    }
}
```



```
結論
```

無論使用什麼數據源 本質還是一樣 DataSource介面不變 方法就不會變



## MySQL workbench

- 字串集合 : utf8mb4
- 排序規則 : utf8mb4_bin
- PRIMARY KEY : 主要key
  - 資料庫表格中唯一且用來抓取資料的屬性 不會其他資料的key相同

```mysql
-- 建立資料庫
create database `SQL_FIRST`;
-- 顯示所有資料庫
SHOW DATABASES;	
-- 指定指令使用的資料庫
USE `SQL_FIRST`; 
-- 建立表格
CREATE TABLE `student`(         
	`student_id` INT PRIMARY KEY,  -- 直接指定主要屬性
    `name` VARCHAR(10),
    `major` VARCHAR(20),
    -- 指定主要元素
--  primary key(`student_id`);  
);
 -- 檢查表格
 DESCRIBE `student`; 
 -- 刪除表格
 DROP TABLE `student`; 
 -- 新增表格屬性
 ALTER TABLE `student` ADD `gpa` DECIMAL(3,2);
 -- 刪除表格屬性
 ALTER TABLE `student` DROP column gpa; 
 

 
 -- 列出表格的所有資料
 select * from `student`;
```



#### 插入表格

```mysql
 -- 插入 student 表格  依照參數的順序依序填入  PRIMARY KEY 為唯一的
 insert into `student` values(1,"ABC","english") ;
 insert into `student` values(2,"DFE","math") ;
 insert into `student` values(3,"GHI",NULL) ;
 
 -- 插入 student 表格 改變參數順序
 insert into `student`(`name`,`major`,`student_id`)  values("JKL","Math",4);
```



#### 限制 約束

```mysql
caeate table `student`(
	`student_id` int auto_increment,
	`name` varchar(20) not null default `未命名`,
	`major` varchar(20) unique,
	primary key(`student_id`)
);
-- not null 此項元素不可為null
-- unique 此項元素不可重複 每一個都是獨特的
-- default 當增加資料時不選擇此元素 則預設為命名的數值
-- auto_increment 每次添加資料後自動增加1
```



#### 修改 刪除資料

```mysql
update `student`
set `major` = 'english' 
where `major` = '英語';
```





#### 資料類型

```mysql
 INT 				-- 整數
 DECIMAL(m,n) 		-- 有小數點的數  (3,2) 有三個數字 小數點佔了兩位2.33
 VARCHAR(n) 		-- 字串 (10) 長度為10
 BLOB 				-- (Binary Large Object) 圖片 影片 檔案
 DATA 				-- 'YYYY-MM-DD' 日期
 TIMESTAMP 			-- 'YYYY-MM-DD HH:MM:SS' 記錄時間
```

