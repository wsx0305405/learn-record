# java



# 陣列



陣列的概述

- 陣列的理解 : 陣列 (Array) 是多個相同類型數據按一定順序排列的集合 並使用一個名字命名 並通過編號的方式對這些數據進行統一管理

陣列相關的概念

- 陣列名
- 元素
- 索引 (index)
- 陣列的長度 : 元素的個數

陣列的特點

- 陣列是有序排列的
- 陣列屬於引用數據類型的變數  陣列的元素 既可以是基本數據類型 也可以是引用數據類型
- 創建陣列對象會在記憶體中開闢一整塊連續的空間
- 陣列的長度一旦確定 就不能修改

陣列的分類

- 按照維度分成 : 一 二維陣列
- 按照陣列元素的類型 : 基本數據類型元素的陣列  引用數據類型元素的陣列

一維陣列的使用

- 一維陣列的聲明和初始化

``````java
int[] id; // 聲明
// 靜態初始化 : 陣列的初始化和陣列元素的賦值操作同時進行
ids = new int[]{100,101,102};
// 動態初始化 : 陣列的初始化和陣列元素的賦值操作分開進行
String[] names = new String[5];

/* 錯誤的寫法
	int[] arr1 = new int[];
	int[5] arr2 = new int[5];
	int[] arr3 = new int[3]{1,2,3};
*/

// 總結 : 一旦初始化完成 其長度就確定了
``````

- 如何調用陣列的指定位置的元素

``````java
// 通過角標的方式   陣列的角標(索引) 從0開始 ~ 陣列的長度-1
names[0] = "AAA";
names[1] = "BBB";
``````

- 如果獲取陣列的長度

``````java
// 屬性:length
System.out.println(names.length);
``````

- 如何遍歷陣列

``````java
for(int i = 0;i < names.length;i++){
	System.out.println(names[i]);
}

for(int a : names){
    System.out.println(a);
}

``````

- 陣列元素的預設初始化值
  - 整數 : 0
  - 浮點數 : 0.0
  - char : 0 或 '\u0000'
  - boolean : false
  - 引用數據類型 : null



#### 多維陣列



二維陣列的聲明和初始化

``````java
// 靜態初始化
int[][] arr1 = new int[][]{{1,2,3},{4,5},{6,7,8}};

// 動態初始化1
String[][] arr2 = new String[3][2];

// 動態初始化2
String[][] arr3 = new String[3][];

// 類型推斷
int[] arr4 = {1,2,3,4,5};
``````



如何調用陣列的指定位置的元素

``````java
int[][] arr = new int[][]{{1,2,3},{4,5,6},{7,8,9}};
System.out.println(arr[0]);
System.out.println(arr[0][1]);
System.out.println(arr[2][0]);
System.out.println(arr[3][1]);
``````



如何獲取陣列的長度

``````java
int[][] arr = new int[4][3];
System.out.println(arr.length); // 4
System.out.println(arr[0].length); // 3

int[][] arr = new int[3][];
arr[0] = new int[3];
arr[1] = new int[4];
arr[2] = new int[5];
System.out.println(arr[0].length); // 3
System.out.println(arr[1].length); // 4
System.out.println(arr[2].length); // 5
``````



如何遍歷陣列

```java
for (int i = 0; i < arr.length; i++) {
    for (int j = 0; j < arr[i].length; j++) {
        System.out.print(arr[i][j] + " ");
    }
    System.out.println();
}
```



二維陣列的預設初始化值

- 外層 : null  or  地址值
- 內層 : 與一維陣列初始情況相同 , 0 or null ..... 

``````java
int[][] arr = new int[4][3];
// 外層元素的初始化值為 : 地址值
// 內層元素的初始化值為 : 與一維陣列初始化情況相同
System.out.println(arr); // [[I@地址值
System.out.println(arr[0]); // [I@地址值
System.out.println(arr[0][0]); // 0

double[][] arr = new double[4][];
// 外層元素的初始化值為 : null
// 內層元素的初始化值為 : 不能調用 否則會出錯
System.out.println(arr[1]); // null
``````



#### 陣列的複製

``````java
int[] array1,array2;
array1 = new int[]{2,3,5,7,11,13,17,19};

array2 = new int[array1.length];
// 陣列的複製
for(int i = 0;i < array2.length;i++){
	array2[i] == array1[i];
}
``````



#### 陣列的反轉

``````java
String[] arr = new String[]{"AA","BB","CC","DD","EE","FF","GG"};

// 陣列的反轉  
// 方法一
for(int i = 0; i < arr.length / 2;i++){
	String temp = arr[i];
	arr[i] = arr[arr.length - i - 1];
	arr[arr.length - i - 1] = temp;
}

// 方法二
for(int i = 0,j = arr.length-1 ; i < j ; i++ , j--){
    String temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
``````



#### 陣列的搜尋

``````java
String[] arr = new String[]{"AA","BB","CC","DD","EE","FF","GG"};
// 線性搜尋
String dest = "BB";
for(int i = 0;i < arr.length;i++){
	if(dest.equals(arr[i])){
        System.out.println("找到了 位置為 " + i);
        break;
    }
}
``````



##### 二元搜尋

- 搜尋的陣列必須是有序的

``````java
int[] arr2 = new int[]{-12,-2,0,4,32,46,78,83,90};
int dest1 = 32;
int head = 0; // 初始的首索引
int end = arr2.length - 1; // 初始的末索引
while(head <= end){
	int middle = (head + end)/2;
	if(dest1 = arr2[middle]){
		System.out.println("找到了指定的元素 位置為 : " + middle);
		break;
	}else if(arr2[middle] > dest1){
		end = middle - 1;
	}else{	// arr2[middle] < dest1
		head = middle + 1;
	}
}
``````



#### 陣列的排序



##### 冒泡排序

``````java
int[] arr = new int[]{49,38,65,97,76,13,27,49};
for(int i = 0;i < arr.length - 1;i++){
    for(int j = 0;j < arr.length - 1 - i;j++){
        if(arr[j] > arr[j + 1]){
            int temp = arr[j];
            arr[j] = arr[j+1];
            arr[j + 1] = temp;
        }
    }
}
``````



#### Arrays工具類

``````
boolean equals(int[] a,int[] b) 	// 判斷兩個陣列是否相等
String toString(int[] a)			// 輸出陣列訊息
void fill(int[] a,int val)			// 將指定值填充到陣列之中
void sort(int[] a)					// 對陣列進行排序
int binarySearch(int[] a,int key)	// 對排序後的陣列進行二分法搜尋指定的值
``````



``````java
int[] arr1 = new int[]{1,2,3,4};
int[] arr2 = new int[]{1,3,2,4};
boolean isEquals = Arrays.equals(arr1,arr2);
System.out.println(isEquals); // false

System.out.println(Arrays.toString(arr1)); // 1 2 3 4

Arrays.fill(arr1,10);
System.out.println(Arrays.toString(arr1)); // 10 10 10 10

Arrays.sort(arr2);
System.out.println(Arrays.toString(arr2); // 1 2 3 4

int[] arr3 = new int[]{-10,2,11,45,78,96};
int index = Arrays.binarySearch(arr3,211); // 返回負數 表示
System.out.println(index);
``````







# 面向對象-物件導向



#### 特性 - 封裝 繼承 多態



- java類及類的成員
  - 屬性 方法 構造器 程式區塊 內部類
- 面向對象的三大特徵
  - 封裝性 繼承性 多態性 (抽象性)
- 其他關鍵字
  - this  super static final abstract interface package import



## 面向過程與面向對象

- 兩者都是一種思想 面向對象是相對於面相過程而言的

面向過程

- 強調的是功能行為 以函數為最小單位 考慮怎麼做

面向對象

- 將功能封裝進對象 強調具備了功能的對象 以類/對象為最小單位 考慮誰來做

面向對象更加強調運用人類在日常的思維邏輯中採用的思想方法與原則 如抽象 分類 繼承 聚合 多態



面向對象三大特徵

- 封裝 (Encapsulation)
- 繼承 (Inheritance)
- 多態 (Polymorphism)



#### 面向對象的思想概述

- 我們由面向過程的執行者轉化成面向對象的指揮者
- 面向對象分析方法分析問題的思路和步驟
  - 根據問題需要 選擇問題所針對的現實世界中的實體
  - 從實體中尋找解決問題相關的屬性和功能 這些屬性和功能就形成了概念世界中的類
  - 把抽象的實體用計算機語言進行描述 形成計算機世界中類的定義 即借助某種程式語言 把類購造成機算機語言能夠識別的處理和數據結構
  - 將類實例化成計算機世界中的對象 對象是計算機世界中解決問題的最終工具



## 類和對象

- 類(class) 和 對象(Object) 是面向對象的核心概念
  - 類是對一類事務的描述 是抽象的 概念上的定義
  - 對象是實際存在的該類事務的每個個體 因此也稱為實例 (instance)
- 面向對象程式設計的重點是類的設計
- 設計類 就是設計類的成員
- 萬物皆對象



#### java類及類的成員

- 屬性 : 對應類中的成員變數
- 行為 : 對應類中的成員方法



## 對象的創建和使用

- 類和對象的使用
  - 創建類 設計類的成員
  - 創建類的對象
  - 通過 對象.屬性 或 對象.方法 調用對象的結構
- 創建了一個類的多個對象 則每個對象都獨立的擁有一套類的屬性 (非static)
  - 意味著 如果我們修改了一個對象的屬性a 則不影響另外一個對象屬性的a值

```java
創建Person類的對象
	Person p1 = new Person();

調用對象的結構 : 屬性 方法
調用屬性 : 對象.屬性
	p1.name = "AAA";
	p1.isMale = true;

調用方法 : 對象.方法
	p1.eat();
	p1.sleep();
	p1.talk("english");

將p1變數保存的對象地址賦予給p3 , 導致p1和p3指向了同樣的heap空間中的對象實體
  	Person p3 = p1;
則修改p3 也等於修改了 p1
```





## 類的成員 : 屬性

```java
類中屬性的使用

屬性(成員變數) VS 局部變數
相同點:
	定義變數的格式 : 數據類型 變數名 = 變數值
	先聲明 後使用
	變數都有其對應的作用域

不同點:
	在類中聲明的位置不同
        屬性 : 直接定義在類的一對{}內
        局部變數 : 聲明在方法內 方法形參 程式區塊內 構造器形參 構造器內部的變數

	關於權限修飾符的不同
        屬性 : 可以在聲明屬性時 指名其權限 使用權限修飾符
        	常用的權限修飾符 : private public 不宣告 protected

        局部變數 : 不可使用權限修飾符
	
	預設初始化值的情況
        屬性 : 類的屬性 根據其類型 都有預設初始化值
            整型 (byte short int long) : 0
            浮點型 (float double) : 0.0
            字元型 (char) : 0 (或 '\u0000')
            布林型 (boolean) : false

            引用數據類型 (類 陣列 接口) null

        局部變數 : 沒有預設初始化值
            表示我們在定義局部變數值時 一定要賦予值
    	
    記憶體中載入的位置	
    	屬性 : 載入到heap空間 (非static)
    	局部變數 : 載入到stack空間
```



## 類的成員 : 方法

```
類中方法的聲明和使用

方法 : 描述類應該具有的功能
例如 Math類 sqrt() random() 
	Scanner類 nextXXX()
	
方法的聲明 : 權限修飾符 返回值類型 方法名(形參列表){
		方法體
}
	static final abstract 

權限修飾符
	private proteted 不宣告 public
	
返回值類型 : 有返回值 vs 沒有返回值
	如果方法有返回值 則必須在方法聲明時 指定返回值的類型 
		同時 方法中需要使用 return 返回指定類型的變數或常數
	如果方法沒有返回值 則方法聲明時 使用void表示
		通常 沒有返回值的方法中 不需要使用return
		要使用的話只能使用 "return" 表示結束此方法執行

定義方法該不該有返回值 
	根據題目要求

方法名 : 屬於標示符 遵循標示符的規則和規範

形參列表 : 方法可以聲明0 1 多個形參

方法體 : 方法功能的體現

return的使用
	使用範圍 : 使用在方法體中
	作用 : 結束方法
		  針對於有返回值類型的方法 使用 "return 數據" 方法返回所要的數據
		  return關鍵字後面不可以聲明執行語句
		  
方法的使用中 可以調用當前類的屬性或方法
		   方法A中又調用了方法A : 遞迴
	
方法中不能定義方法
```



#### 練習操作

生成隨機數

``````
Math.random() 返回值 : double
``````

四捨五入取整數

``````
Math.round(double d) 返回值 : long
``````



```java
public class StudentTest {
    public static void main(String[] args) {
        // 聲明Student類型的陣列
        Student[] students = new Student[20];
        // 賦值操作
        Student.init(students);

        System.out.println("int = " + (int)99.112 ); // 99
        System.out.println("int = " + (int)100.112 ); // 100
        // 遍歷
        Student.print(students);

        System.out.println("三年級的學生");
        // 印出三年級的學生訊息
        Student.printState(students,3);

        System.out.println("依照成績排序");
        Student.sort(students);

        // 遍歷
        Student.print(students);
    }
}

class Student{
    public int number;
    public int state;
    public int score;
    @Override
    public String toString() {
        return "Student{" +
                "number=" + number +
                ", state=" + state +
                ", score=" + score +
                '}';
    }
    // 賦予多個對象初始值
    public static void init(Student[] students){
        for (int i = 0; i < students.length; i++) {
            // 陣列元素賦值
            students[i] = new Student();
            // Student對象的屬性賦值
            students[i].number = (i + 1);
            // 年級 [1,6]  (b - a + 1)
            // 當取值範圍為 [a,b] --> b-a+1得出的是從a ~ b元素的個數
            // Math.random隨機生成 [0.0,1.0)中的一個double型數(左閉右開)
            // 乘以 6 - 1 + 1 得到 [0.0,6.0)
            students[i].state = (int) (Math.random() * (6 - 1 + 1)) + 1;
            // 成績 [0,100] = [0,101)      (100 - 0 + 1) * 0.99 = 98.01
            students[i].score = (int) (Math.random() * (101 - 0 + 1)) + 1;

        }
    }
    // 遍歷方法
    public static void print(Student[] str){
        for (Student student : str) {
            System.out.println(student);
        }
    }
    // 印出對應年級
    public static void printState(Student[] stu,int st){
        for (Student student : stu) {
            if(student.state == 3){
                System.out.println(student);
            }
        }
    }
    // 依照屬性排序
    public static void sort(Student[] students){
        // 冒泡排序按學生成績排序 並遍歷所有學生訊息
        for (int i = 0; i < students.length - 1; i++) {
            for (int j = 0; j < students.length - 1 - i; j++) {
                if(students[j].score > students[j + 1].score ){
                    // 排序 交換的是陣列的元素 Student對象
                    Student temp = students[j];
                    students[j] = students[j+1];
                    students[j+1] = temp;
                }
            }
        }
    }
}
```



#### 面向對象-問題

面向對象思想編程內容的三條主線分別是什麼

- 類及類的成員 : 屬性 方法 構造器 程式區塊 內部類

- 面向對象的三大特徵
  - 封裝 繼承 多態
- 其他關鍵字 : this super abstract interface static final package import

面向對象的編程思想

- 類 對象 面向對象的三大特徵

面向對象中類和對象的理解 兩者的關係

- 類 : 抽象的 概念上的內容
- 對象 : 實際存在的一個個體

類和對象的創建和執行操作有哪三步

- 創建類
- 創建類的對象 (類的實例化)
- 調用對象的結構 : 對象.屬性   對象.方法



#### 面向對象-複習

面向對象學習的三條主線

- java類及類的成員 : 屬性 方法 構造器 程式區塊 內部類
- 面向對象的三大特徵
  - 封裝性 繼承性 多態性
- 其他關鍵字 : this super static final abstract interface package import

面向對象與面向過程

- 面向過程 : 強調怎麼做
- 面向對象 : 考慮誰來做 誰可以執行什麼動作

面向對象中兩個重要的概念

- 類 : 對一個類事物的描述是抽象的 概念上的定義
- 對象 : 是實際存在的該類事物的每個個體 因此也稱為實例(instance)
  - 面向對象程式設計的重點是類的設計
  - 設計類 就是設計類的成員
- 兩者的關係 : 對象是由類 new 出來的

面向對象思想實現的規則

- 創建類 設計類的成員
- 創建類的對象
- 通過 對象.屬性   對象.方法調用對象的結構

萬物皆對象

- 在Java語言中 我們都將功能 結構等封裝到類中 通過類的實例化 調用具體的功能結構
  - Scanner String
  - 文件 File
  - 網路資源 URL
- 涉及到java語言與前端Html 後端的資料庫交互時 前後端的結構在Java層面交互時 都體現為類 對象

匿名對象

- 我們創建的對象 沒有顯式的賦給一個變量名 即為匿名對象
- 匿名對象只能調用一次



#### 對象陣列的記憶體

- 引用類型的變數 只可能儲存兩類值 null 或 地址值 (含變數的類型)



## 再談方法

#### 方法的重載(overload)

- 同一個類中 允許存在一個以上的同名方法 只要他們的參數個數或者參數類型不同即可
- 特點
  - 與返回類型無關 只看參數列表
  - 且參數列表必須不同 (參數個數或參數類型)
  - 調用時 根據方法參數列表的不同來區分



#### 可變形參的方法

- 允許直接定義能和多個實參相匹配的形參 也就是可以使用更簡單的方式來傳遞數的可變的實參
- 具體使用
  - 可變個數型參的格式 : 數據類型 ... 變量名
  - 當調用可變個數形參的方法時 傳入的參數個數可以是 0 1 2 個 ....
  - 可變個數形參的方法與苯類中方法名相同 形參不同的方法之間構成重載
  - 可變個數形參的方法與本類中方法名相同 形參類型也相同的陣列之間不構成重載
    - 也就是 兩者不能共存  String[] str  , String ... str

  - 可變個數形參在方法的形參中 必須聲明在末尾 
  - 可變個數形參在方法的形參中 最多只能聲明一個可變形參



#### 值傳遞機制

形參 : 方法定義時 聲明的 () 內的參數

實參 : 方法調用時 實際傳遞給形參的數據

- 如果參數是基本數據類型 此時實參賦給形參的是實參真實儲存的數據值
- 如果參數是引用數據類型 此時實參賦給形參的是實參儲存數據的地址值



#### 問題

``````java
public static void main(String[] args){
	int[] arr = new int[]{1,2,3};
	System.out.println(arr); // 地址值
	
	char[] arr1 = new char[]{'a','b','c'};
	System.out.println(arr1); // abc
}
``````





#### 遞迴方法 recursion

- 一個方法調用自己
- 方法遞迴包含了一種隱式的循環 他會重複執行某段程式 這種重複執行無須循環控制
- 遞迴一定要向已知方向遞迴 否則這種遞迴就會變成無窮遞迴



## OOP特徵 : 封裝與隱藏

封裝的作用和含意

- 使用時  不需要理解裡面內部的結構  

程式設計追求 高內聚 低耦合

- 高內聚 : 類的內部數據操作細節自己完成 不允許外部干涉
- 低耦合 : 僅對外暴露少量的方法用於使用

隱藏對象內部的複雜性 只對外公開簡單的接口 便於外界使用 從而提高系統的可擴展性 可維護性

也就是把該隱藏的隱藏起來 該暴露的暴露出來 就是封裝性的思想



封裝的體現

- 將類的屬性私有化(private) 同時提供公共的(public)方法來獲取(get)和設置(set)
- 不對外暴露的私有方法
- 單例模式 (將建構器私有化)
- 如果不希望類在包外被調用 可以不設置類的權限



#### 權限修飾符

- Java規定的四種權限 : private , 不宣告 , protected , public
- 四種權限都可以用來修飾類及類的內部結構 : 屬性 方法 構造器 內部類
- 具體的四種權限都可以用來修飾類的內部結構 : 屬性 方法 構造器 內部類
  - 修飾符只能使用  不宣告 , public

| 修飾符    | 類內部 | 同一個包 | 不同包的子類 | 同一個工程 |
| --------- | ------ | -------- | ------------ | ---------- |
| private   | yes    |          |              |            |
| 預設      | yes    | yes      |              |            |
| protected | yes    | yes      | yes          |            |
| public    | yes    | yes      | yes          | yes        |



#### 類的成員 : 建構器

建構器特徵

- 具有與類相同的名稱
- 不聲明返回值類形 (與聲明為void不同)
- 不能被 static final synchronized abstract native修飾  不能有return語句返回值

建構器作用

- 創建對象 為對象進行初始化
- 類別名 name = new 建構器

建構器特性

- 如果沒有自定義的建構器 則系統預設會生成一個無參數的建構器
- 定義建構器的格式 權限修飾符 類名(形參列表){}
- 一個類中定義的多個建構器 彼此構成重載
- 一旦我們定義了類的建構器後 系統就不再提供預設的無參數的建構器
- 一個類中 至少會有一個建構器



#### 屬性賦值小結

- 屬性賦值的先後順序
  - 預設初始化 int a; 
  - 顯式初始化 int a = 1;
  - 建構器賦值
  - 通過 對象.方法 或 對象.屬性 賦值
- 順序為 : 預設初始化  -->  顯式初始化  -->  建構器賦值  -->  對象.方法 對象.賦值



#### JavaBean

一種java語言寫成的可重用的組件

- 類是公共的
- 有一個無參的公共的構造器
- 有屬性 且有對應的get set方法



#### UML圖

![擷取_2022_02_22_11_27_04_77](A:\video\擷取_2022_02_22_11_27_04_77.png)



#### 關鍵字 : this

this可以理解為 當前對象 或 當前正在創建的對象

- this可以用來修飾 : 屬性 方法 建構器
- this修飾屬性和方法
  - 在類的方法中 我們可以使用this.屬性 或 this.方法的方式 調用當前對象屬性或方法
  - 特殊情況下 如果方法的參數和類的屬性同名時 我們必須顯式的使用 this.變數的方式 表明此變數是屬性 而非參數



this調用建構器

- 我們在類的建構器中 可以顯式的使用 this(參數列表) 的方式 調用本類中指定的其他建構器
- 建構器中不能通過 this(參數列表) 的方式調用自己
- 如果一個類中有n個建構器 則最多會有 n-1 個建構器使用了 this(參數列表)
- 規定 : this(參數列表) 必須聲明在當前建構器的第一行
- 建構器內部 最多只能聲明一個this(參數列表) 用來調用其他建構器



#### 關鍵字 : package import

package

- 為了更好的實現項目中類的管理 提供包的概念
- 使用package聲明類或接口所屬的包 聲明在源文件的首行
- 包 屬於標示符 遵循標示符的命名規則 規範(xxxyyyzzz) 
- 每 . 一次 就代表一層文件目錄
- 同一個包下 不能命名同名的接口 類
- 不同的包下 可以命名同名的接口 類



#### 關鍵字 :  import

- 在源文件中顯式的使用import結構導入指定包下的類 接口
- 聲明在包的聲明和類的聲明之間
- 如果需要導入多個結構 則並列寫出即可
- 可以使用 "xxx.*"的方式 表示可以導入xxx包下的所有結構
- 如果使用的類或接口是java.lang包下定義的 則可以省略import結構
- 如果使用的類或接口是本包下定義的 則可以省略import結構
- 如果在源文件中使用了不同包下的同名的類 則必須至少有一個類需要以全類名的方式顯示
  - com.java.package1.類名
- 使用"xxx.*"方式表示可以調用xxx包下的所有結構
  - 但是如果使用xxx子包下的結構 則仍需要顯式導入
- import static : 導入指定類或接口中的靜態結構 : 屬性或方法



#### MVC設計模式

- 將整個程式分成三個層次 : 視圖模型層 控制器層 數據模型層
- 將程式輸入輸出 數據處理 數據的展示分離開來的設計模式 使程式結構的靈活更加清晰
  - 同時也描述了程式各個對象間的通訊方式  降低了程式的耦合性



# 面向對象 - 2



#### OOP特徵 : 繼承性

繼承性的優點

- 減少了程式碼的冗於 提高了程式碼的複用性
- 便於功能的擴展
- 為了多態性的使用 提供了前提



繼承的格式 : class A extends B{}

- A : 子類 派生類 subclass
- B : 父類 超類 基類 superclass
- 一旦子類A繼承父類B後 子類A中就獲取了父類B中聲明的所有的屬性和方法
  - 父類中聲明為private的屬性或方法 子類繼承父類之後 仍然認為獲取了父類中私有的結構
  - 因為封裝性的影響 使得子類不能直接調用父類的結構
- 子類繼承父類後 還可以聲明自己特有的屬性和方法



Java中繼承性的規定

- 一個類可以被多個子類繼承
- Java中類的單繼承性 : 一個類只能有一個父類
- 子父類是相對的概念
- 子類直接繼承的父類 稱為直接父類  間接繼承的父類 稱為間接父類
- 子類繼承父類之後 就獲取了直接父類以及所有間接父類中聲明的屬性和方法



Object

- 如果沒有聲明繼承的父類的話  所有的類都繼承於java.lang.Object類
- 表示所有的java類具有java.lang.Object類聲明的功能



####  方法的重寫 override

- 子類繼承父類之後 可以對父類中同名同參數的方法 進行覆蓋操作
- 應用 : 重寫後 當創建子類對象以後 通過子類對象調用子父類中的同名同參數的方法時 實際執行的是子類重寫父類的方法
- 重寫的規定
  - 方法的聲明 : 權限修飾符 返回值類型 方法名(參數列表) throws 異常的類型 { 方法體 }
  - 子類重寫的方法的方法名和參數列表與父類被重寫的方法的方法名的參數列表相同
  - 子類重寫的方法的權限修飾符不小於父類被重寫的方法的權限修飾符
    - 特殊情況 : 子類不能重寫父類中聲明為private權限的方法
  - 返回值類型
    - 父類被重寫的方法的返回值類型是void 則子類重寫的方法的返回值類型只能是void
    - 父類被重寫的方法的返回值類型是A類型 則子類重寫的方法的返回值類型可以是A類或A類的子類
    - 父類被重寫的方法的返回值類型是基本數據類型 (double) 則子類重寫的方法的返回值類型必須是相同的基本數據類型 (也必須是double)
  - 子類重寫的方法拋出的異常類型不大於父類被重寫的方法拋出的異常類型
  - 子類和父類中的同名同參數的方法要的話都不聲明為static (可以重寫) 
    - 或是 都聲明為static (不能重寫)



#### 關鍵字 super

- super理解為 : 父類的
- super可以用來調用 : 屬性 方法 建構器
- super的使用
  - 我們可以在子類的方法或建構器中 通過super.屬性 super.方法 的方式顯式的調用父類中聲明的屬性或方法 但是通常情況下 我們習慣省略super.
  - 特殊情況 : 當子類和父類定義了同名的屬性時 我們要在子類中調用父類中聲明的屬性 則必須使用 super.屬性 的方式 表明調用的是父類中聲明的屬性
  - 特殊情況 : 當子類和父類定義了同名的方法時 我們要在子類中調用父類中聲明的方法時 則必須顯式的使用 super.方法 的方式 表明調用的是父類中被重寫的方法
- super調用建構器
  - 我們可以在子類的建構器中顯式的使用 super(參數列表) 的方式 調用父類中聲明的指定的建構器
  - super(參數列表) 的使用 必須聲明在子類建構器的首行
  - 我們在類的建構器中 針對於 this(參數列表) 或 super(參數列表) 只能選擇使用一個 不能同時出現
  - 在建構器的首行 沒有顯示的聲明 this(參數列表) 或 super(參數列表) 則預設調用的是父類中空參數的建構器
  - 在類的多個建構器中 至少有一個類的建構器中使用了 super(參數列表) 調用父類的建構器



#### 子類對象實例化過程

- 從結果上來看 (繼承性)
  - 子類繼承父類之後 就獲取了父類中聲明的屬性和方法
  - 創建子類的對象 在Heap空間中 就會載入所有父類中聲明的屬性
- 從過程上來看
  - 當我們通過子類的建構器創建子類對象時 我們一定會直接或間接的調用其父類的建構器 進而調用父類的父類的建構器
  - 直到調用了java.lang.Object類中空參數的建構器為止
  - 因為載入過所有的父類的結構 所以才能夠在記憶體中看到父類中的結構 子類對象才可以考慮進行調用
- 雖然創建子類對象時 調用了父類的建構器 但是從頭到尾就創建過一個對象 即為new的子類對象



#### OOP特徵 : 多態性

- 理解多態性 : 可以理解為一個事物的多種形態
- 何為多態性
  - 對象的多態性 : 父類的引用指向子類的對象
    - 或是子類的對象賦給父類的引用
- 例子

``````
Person p = new Man();
Object obj = new Date();
``````

- 多態的使用 : 虛擬方法調用
  - 有了對象的多態性以後 我們在編譯期 只能調用父類中聲明的方法 
  - 但在運行期 我們實際執行的是子類重寫父類的方法
  - 總結 
    - 編譯 看左邊  (屬性)
    - 運行 看右邊
- 多態性的使用前提 
  - 類的繼承關係
  - 方法的重寫
- 對象的多態性 只適用於方法 不適用於屬性



多態性是編譯時行為還是運行時行為

- 運行時行為   運行時才能判斷執行的是哪一個方法



#### 多態性-屬性 方法

- 若子類重寫了父類方法 意味著子類裡定義的方法徹底覆蓋了父類裡的同名方法 系統將不可能把父類裡的方法轉移到子類中 : 編譯看左邊 運行看右邊
- 對於實例變數則不存在這樣的現象 即使子類裡定義了與父類完全相同的實例變數 這個實例變數依然不可能覆蓋父類中定義的實例變數 : 編譯運行都看左邊



#### 方法的重載 重寫

從編譯和運行的角度

- 重載
  - 是指允許存在多個同名方法 
  - 這些方法的參數不同 編譯器根據方法不同的參數表 對同名方法的名稱做修飾 
  - 對於編譯器而言 這些同名方法就成了不同的方法 
  - 他們的調用地址在編譯期就綁定了
  - Java的重載可以包括父類漢子類 即子類可以重載父類的同名不同參數的方法
- 多態
  - 只有等到方法調用的那一刻 解釋運行器才會確定所要調用的具體方法
  - 稱為 晚綁定 或 動態綁定

結論 : 如果他不是晚綁定 他就不是多態



#### instanceof關鍵字

(對象 變數) instanceof 類別

- 多態
  - 多態的使用 : 當調用子父類同名同參數的方法時 實際執行的是子類重寫父類的方法--虛擬方法調用
  - 父類的引用 不能動用子類所持有的方法 屬性 
    - 因為編譯時期 引用的對象是父類
  - 有了對象的多態性後 記憶體中實際上是載入了子類特有的屬性和方法的
  - 但是由於變數聲明為父類類型 導致編譯時 只能調用父類中聲明的屬性和方法 子類特有的屬性和方法不能調用
- 如何才能調用子類特有的屬性和方法
  - 向下轉型 --> 使用強制類型轉換 

``````
Person p1 = new Man();
Man m1 = (Man) p1; // 轉成子類的型態
``````



instanceof

- 為了保證向下轉型時不出現ClassCastException異常  我們在轉型之前先進行instanceof判斷
- 一旦返回true 就進行向下轉型 否則不進行轉型

``````
a instanceof A : 判斷對象a是否是類A的實例  如果是 返回true  否則返回 false

如果 a instanceof A 返回true ,  a instanceof B 也返回true
則類A和類B有繼承關係
``````



#### 向下轉型問題

``````java
// 編譯時通過 運行時不通過
Person p1 = new Woman();
Man m1 = (Man)p1;

Person p2 = new Person();
Man m2 = (Man)p2;

// 編譯通過 運行時也通過
Object obj = new Woman();
Person p = (Person)obj;

// 編譯不通過
Man m3 = new Woman();

String str = new Date();
``````



#### Object類

- 是所有Java類的父類
- 如果在類的聲明中未使用extends關鍵字指名其父類 則預設父類為java.lang.Object類
- Object類中的功能(屬性 方法)具通用性
- finalize方法 : 對象回收之前會調用對象的此方法  一般不主動使用此方法  由GC回收調用

主要結構

``````
public boolean equals()
public Object()						建構	建構器
public boolean equals(Object obj)	普通	對象比較
public int hashCode()				普通	取得Hash碼
public String toString()			普通	對象印出時調用
``````



equals()方法

- Object類定義
  - 定義的equals()和 == 的作用是相同的  比較兩個對象的地址值是否相同 即兩個引用是否指向同一個對象實體

``````
public boolean equals(Object obj){
	return (this == obj);
}
``````

- 如何重寫equals()

``````java
class User{
	String name;
	int age;
	
	public boolean equals(Object obj){
		if(obj == this){
			return true;
		}
		if(obj instanceof User){
			User u = (User) obj;
			return this.age == u.age && this.name.equals(v.name);
		}
		return false;
	}
}
``````

- 開發中如何實現 : 自動生成



- toString

``````
String s = "abc";
s = null;
System.out.println(s); // null
System.out.println(s.toString); // NullPointerException
``````

- 如何重寫toString

``````
自動生成
public String toString(){
	return "Customer [name=" + name + ", age=" + age + "]";
}
``````



#### ==的使用

- 是一個運算符號
- 可以使用在基本數據類型變數和引用數據類型變數中
- 如果比較的是基本數據類型變數 : 比較兩個變數保存的數據是否相等 (不一定類型要相同)
- 如果比較的是引用數據類型變數 : 比較兩個對象的地址值是否相同
  - 即兩個引用是否指向同一個對象實體
- ==符號使用時 必須保證符號左右兩邊的變數類型一致

``````java
基本數據類型
int i = 10;
int j = 10;
double d = 10.0;
System.out.println(i == j); // true
System.out.println(i == d); // true  會進行提升至兩個值為double類型

boolean b = true;
// System.out.println(i == b); 無法比較

char c = 10;
System.out.println( i == c); // true

char c1 = 'A';
char c2 = 65;
System.out.println(c1 == c2); // true 會找取對應的數字對應字元

=======================================================================
引用類型
    
Customer cust1 = new Customer("AAA",20);
Customer cust2 = new Customer("AAA",20);
System.out.println(cust1 == cust2); // 引用類型比較地址  false
    
String str1 = new String("AAA");
String str2 = new String("AAA");
System.out.println(str1 == str2); // 引用類型比較地址  false
``````



#### equals()的使用

- 是一個方法

- 只能適用於引用數據類型

- Object類中equals()的定義

  ``````java
  public boolean equals(Object obj){
  	return (this == obj);
  }
  ``````

  - Object類中定義的equals()和 == 的作用是相同的 比較兩個對象的地址值是否相同

- 像String Date File 包裝類等都重寫了Object類中的equals()方法 重寫以後 比較的不是兩個引用的地址是否相同 而是比較兩個對象的"實體內容"是否相同

```java
System.out.println(cust1.equals(cust2)); // true  比較內容
System.out.println(str1.equals(str2)); // false 比較地址值

Date date1 = new Date(12345678L);
Date date2 = new Date(12345678L);
System.out.println(date1.equals(date2)); // true 比較內容
```



#### 重寫equals()的原則

- 對稱性 : 如果x.equals(y)返回true  那麼y.equals(x)也應該返回true
- 自反性 : x.equals(x)必須返回true
- 傳遞性 : 如果x.equals(y)返回true  而且 y.equals(z)返回true  那麼z.equals(x)也應該返回true
- 一致性 : 如果x.equals(y)返回true 只要x和y內容一直不變  不管重複x.equals(y)多少次 都是返回true
- 任何情況下 x.equals(null) 永遠返回false 
  - null.equals(x) 則一定會發生空指針異常
  - x.equals(和x不同類型的對象)永遠返回false



``````java
@Override
public boolean equals(Object obj){
	if(this == obj){  // 判斷地址是否相同
		return true;
	}
	
	if(obj instanceof MyDate){  // 判斷是否是繼承關係
		MyDate myDate = (MyDate) obj;   // 繼承關係才可以向下轉型
        // 接著比較類中的每一個屬性 基本數據使用 ==    引用類型使用 equals
		return this.day == myDate.day && this.month == myDate.month && 	
		this.year == myDate.year;
	}
	return false;
	
}
``````





#### == 和 equals的區別

- ==既可以比較基本類型也可以比較引用類型 
  - 對於基本類型就是比較值 對於引用類型就是比較記憶體地址
- equals是屬於java.lang.Object類裡面的方法 如果該方法沒有被重寫過預設也是==
  - 我們可以看到String等類的equals方法是被重寫過的 
  - 由於String類在日常開發中用的比較多 會被誤認為equals是比較值的錯誤觀點
- 具體要看自定義類裡有沒有重寫Object的equals方法來判斷
- 一般情況 重寫equals方法 會比較類中的相應屬性是否都相等



#### toString()的使用

- 當我們輸出一個對象的引用時 實際上就是調用當前對象的toString()
- Object類中toString()的定義

``````
public String toString(){
	return getClass().getName() + "@" + Integer.toHexString(hashCode());
}
``````

- 像String Date File 包裝類等都重寫了Object類中的toString()方法
  - 使得在調用對象的toString()時 返回 實體內容 訊息
- 自定義類也可以重寫toString()方法 當掉用此方法時 返回對象的實體內容



#### 單元測試

- 創建Java類 進行單元測試
  - 此時Java類的要求是 
    - 此類是public的
    - 此類提供公共的無參數的建構器
- 此類中聲明單元測試方法
  - 此時的單元測試方法 方法的權限是public 沒有返回值 沒有參數傳入
- 此單元測試方法上需要聲明註解 @Test



#### 包裝類 (封裝類)

- 希望Java的基本數據類型也有面向對象類的功能  所以為每個類型生成包裝類

| 基本數據類型 | 包裝類    |
| ------------ | --------- |
| byte         | Byte      |
| short        | Short     |
| int          | Integer   |
| long         | Long      |
| float        | Float     |
| double       | Double    |
| boolean      | Boolean   |
| char         | Character |



- 基本數據類型 - 包裝類轉換

```java
public class UserTest {
    public static void main(String[] args) {
        int i = 10;
//        Integer in1 = new Integer(i); // 已廢棄
        Integer integer = Integer.valueOf(i);
        System.out.println(integer);


//        Float f1 = new Float(123.2); // 已廢棄
        Float f2 = Float.valueOf("123.4");
        Float f3 = Float.valueOf(123.45f);
        System.out.println(f2);
        System.out.println(f3);

//        Boolean b1 = new Boolean(true);  // 已廢棄
        Boolean b2 = Boolean.valueOf(true);
        Boolean b3 = Boolean.valueOf("true123"); // 只要!=null 且等於 true 返回true

        System.out.println(b2);
        System.out.println(b3); // false

        Order order = new Order();
        System.out.println(order.isMale); // false  基本數據類型
        System.out.println(order.isFemale); // null  包裝類

    }
}

class Order{
    boolean isMale;
    Boolean isFemale;
}
```



- 包裝類-基本數據類型轉換

``````java
// 包裝類 ---> 基本數據類型
        Integer integer1 = Integer.valueOf(12);
        int i1 = integer1.intValue();
        System.out.println(i1);

        Float aFloat = Float.valueOf(12.3f);
        float v = aFloat.floatValue();
        System.out.println(v);
``````



#### 自動裝箱 自動拆箱 

```java
// 自動裝箱  基本數據類型 --> 包裝類的對象
int num2 = 10;
Integer in1 = num2; // 自動裝箱

boolean b1 = true;
Boolean b2 = b1; // 自動裝箱
System.out.println(b2);

// 自動拆箱  包裝類的對象 --> 基本數據類型
System.out.println(in1.toString());
int num3 = in1;  // 自動拆箱
System.out.println(num3);
```



- 基本數據類型包裝類與String相互轉換

基本數據 --> String

- String : valueOf(Xxx xxx)

```java
基本數據類型 包裝類 --> String類型    調用String重載的valueOf(Xxx xxx)

int num1 = 10;
// 方式一 連接運算
String str1 = num1 + "";
// 方式二 調用String的valueOf方法
float f1 = 12.3f
String str2 = String.valueOf(f1); // "12.3"

Double d1 = new Double(12.4);
String str3 = String.valueOf(d1); // "12.4"
```



String --> 基本數據

- parseXxx()

```java
String --> 基本數據類型 包裝類  調用包裝類的parseXxx()

// 字串中不全為數字 轉換時會有 NumberFormatException
String str1 = "123";
// 錯誤的情況
	// int num1 = (int) str1;
	// Integer in1 = (Integer) str1;
int num2 = Integer.parseInt(str1);

String str2 = "true";
String str3 = "true1";
boolean b1 = Boolean.parseBoolean(str2); // true
boolean b1 = Boolean.parseBoolean(str3); // false 只要不是true 都為false
```



#### 包裝類(Wrapper)題目

```java
// 涉及到後方的Double類型 作用域提升 1 -> 1.0
// 編譯時會要求類型都統一成同一個類型
Object o1 = true ? new Integer(1) : new Double(2.0);
System.out.println(o1);  //  1.0

// 這裡沒有要求一定要同一個類型
Object o2;
if(true)
	o2 = new Integer(1);
else
	o2 = new Double(2.0);
System.out.println(o2); // 1 
```



```java
Integer i = new Integer(1);
Integer j = new Integer(1);
System.out.println(i == j);  // false  比較地址  兩個new出來的空間地址不同

Integer m = 1;
Integer n = 1;
System.out.println(m == n);  // true  自動裝箱  不使用new的方式

// Integer內部定義了IntegerCache結構  IntegerCache中定義了Integer[]
// 保存了 -128 ~ 127 範圍的整數 如果我們使用自動裝箱的方式 給Integer賦值的範圍在
// -128 ~ 127 的範圍內時  可以直接使用陣列中的元素 不用再去new  目的 : 提高效率
Integer x = 128;  // 相當於new了一個Integer對象
Integer y = 128;  // 相當於new了一個Integer對象
System.out.println(x == y); // false
```



#### 面試題



多態性

- 多態性的使用
  - 對象的多態性 只適用於方法 不適用於屬性
- 關於向上轉型與向下轉型
  - 向上轉型 : 多態
- 為什麼要使用向下轉型
  - 有了對象的多態性以後 記憶體實際上是加載了子類特有的屬性和方法的 
  - 但是由於變數聲明為父類類型 導致編譯時我們只能調用父類中聲明的屬性和方法
  - 子類特有的屬性和方法不能調用
  - 為了調用子類特有的屬性和方法 必須使用向下轉型
- 如何實現向下轉型
  - 使用強制類型轉換符 ()
- 使用時的注意點
  - 使用強制轉型時 可能會出現ClassCastException的異常
  - 為了避免異常  需要先進行instanceof的判斷  返回true則進行轉換
    - 比較時要求要有繼承關係 否則會判斷失敗



對多態性的理解

- 實現程式碼的通用性



# 面向對象 - 3



#### 關鍵字 static

static關鍵字的使用

- static : 靜態的
- static可以用來修飾 : 屬性 方法 程式區塊 內部類
- 使用static修飾屬性 靜態變數
  - 是否使用了static修飾 又分為 : 靜態屬性 和 非靜態屬性 (實例變數)
  - 實例變數 : 我們創建了類的多個對象 每個對象都獨立的擁有一套類中的非靜態屬性 當修改其中一個對象中的非靜態屬性時 不會導致其他對象中同樣的屬性值的修改
  - 靜態變數 : 我們創建了類的多個對象 多個對象共享同一個靜態變數 當通過某一個對象修改靜態變數時 會導致其他對象調用此靜態變數時 是修改過了的
  - static修飾屬性的其他說明
    - 靜態變數隨著類的載入而載入 可以通過 類.靜態變數 的方式進行調用
    - 靜態變數的載入要早於對象的創建
    - 由於類只會載入一次 所以靜態變數在記憶體中只會存在一個 存在於方法區的靜態域中
- 使用static修飾方法
  - 隨著類的載入而載入 可以通過 類.靜態方法 的方式進行調用
  - 靜態方法中 只能調用靜態的方法和屬性
  - 非靜態方法中 既可以調用非靜態的方法和屬性 也可以調用靜態的方法和屬性

- static注意點
  - 在靜態的方法內 不能使用this關鍵字 super關鍵字

- 如何確定一個屬性是否要聲明為static
  - 屬性是可以被多個對象所共享 不會隨著對象不同而不同的

- 如何確定一個方法是否要聲明為Static
  - 操作靜態屬性的方法 通常設置為static的
  - 工具類中的方法 習慣上聲明為static   例如 : Math , Arrays , Collections




#### 單例模式 Singleton

- 類的單例設計模式 是要採取一定的方法保證在整個系統中 對某個類只能存在一個對象實例
  - 並且該類只能提供一個取得其對象實例的方法
  - 如果我們要讓類在一個虛擬機中只能產生一個對象 首先必須將類的建構器的訪問權限設置為private  這樣就不能使用new操作  讓類在的外部產生類的對象了
  - 但在類內部仍然可以產生該類的對象 因為在類的外部開始還無法得到類的對象 只能調用該類的某個靜態方法以返回類內部創建的對象
  - 靜態方法只能訪問類中的靜態成員變數 所以 指向類內部產生的該類對象的變數也必須定義成靜態的



單例模式優點

- 由於單例模式只生成一個實例 減少了系統性能的消耗
- 當一個對象需要比較多的資源時 例如 : 讀取配置 產生其他依賴對象 則可以通過在應用啟動時直接產生一個單例對象 然後永久保留在記憶體中的方式解決



單例模式應用場景

- 網站的計數器
- 應用程式的日誌應用
- 資料庫連接池
- 讀取配置文件的類
- Application



單例設計模式

- 如何實現
  - 餓漢式 , 懶漢式
- 區分餓漢式和懶漢式
  - 餓漢式
    - 優點
      - 執行緒安全
    - 缺點
      - 對象載入時間過長
  - 懶漢式
    - 優點
      - 延遲對象的創建
    - 缺點
      - 執行緒不安全



實現-餓漢式

- 初始化時就創建對象

```java
public class Singleton {
    public static void main(String[] args) {
        // 無法直接創建對象
//    Bank b1 = new Bank();

        Bank bank1 = Bank.getInstance();
        Bank bank2 = Bank.getInstance();
        System.out.println(bank1 == bank2); // true
    }
}
// 餓漢式
class Bank{
    // 1.私有化類的建構器
    private Bank(){

    }
    // 2.內部創建類的對象
    // 4.要求此對象也必須聲明為靜態的
    private static Bank instance = new Bank();

    // 3.提供公共的靜態方法 返回類的對象
    public static Bank getInstance(){
        return instance;
    }
}
```



```java
public class SingletonTest{
	public static void main(String[] args){
		Bank bank1 = Bank.instance;
		Bank bank2 = Bank.instance;
		// 因為加上了final 無法修改  否則可以進行破壞
		// Bank.instance = null;  
		System.out.println(bank1 == bank2);
	}
}
class Bank{
	private Bank(){
	
	}
	public static final Bank instance = new Bank();
}
```



實現-懶漢式

- 用的時候才創建對象
- 此為尚未處理執行緒安全的

```java
public class SingletonTest2 {
    public static void main(String[] args) {
        Order order1 = Order.getInstance();
        Order order2 = Order.getInstance();
        System.out.println(order1 == order2);
    }
}
// 懶漢式
class Order{
    // 1.私有化類的建構器
    private Order(){

    }
    // 2. 聲明當前類對象 沒有初始化
    // 4. 此對象也必須聲明為static
    private static Order instance = null;

    // 3.聲明public static的返回當前類對象的方法
    public static Order getInstance(){
        if (instance == null){  // 判斷只創建一個
            instance = new Order(); // 執行方法時才創建對象
        }
        return instance;
    }
}
```



#### main方法的語法

- main()方法作為程式的入口
- main()方法也是一個普通的靜態方法
- main()方法可以做為我們與控制台交互的方式 



如何將控制台獲取的數據傳給參數 : String[] args

- 運行時 : java 類名 "AAA" "BBB" "123" "true"



#### 程式區塊

- 程式區塊的作用 : 用來初始化類 對象
- 程式區塊如果有修飾的話 只能使用static
- 分類 : 靜態程式區塊 非靜態程式區塊
  - 靜態程式區塊
    - 內部可以有輸出語句
    - 隨著類的載入而執行 而且只執行一次
    - 作用 : 初始化類的訊息
    - 如果一個類中定義了多個靜態程式區塊 按照聲明的先後順序執行
    - 靜態程式區塊的執行要優先於非靜態程式區塊的執行
    - 靜態程式區塊內只能調用靜態的屬性 方法 不能調用非靜態的結構
  - 非靜態程式區塊
    - 內部可以有輸出語句
    - 隨著對象的創建而執行
    - 每創建一個對象 就執行一次
    - 作用 : 可以在創建對象時 對對象的屬性等進行初始化
    - 如果一個類中定義了多個非靜態程式區塊 按照聲明的先後順序執行
    - 非靜態程式區塊可以調用靜態的屬性 方法 和非靜態的屬性 方法



#### 屬性賦值先後順序

對屬性可以賦值的位置

- 預設初始化
- 顯式初始化
- 建構器初始化
- 有了對象後 通過 對象.屬性 對象.方法 進行賦值
- 在程式區塊中進行賦值

屬性賦值的順序

- 預設初始化
- 顯式初始化  /  在程式區塊中進行賦值
- 建構器初始化
- 有了對象後 通過 對象.屬性 對象.方法 進行賦值



#### 關鍵字 final

final : 最終的

- final可以用來修飾的結構 : 類 方法 變數

- final 用來修飾一個類 : 此類不能被其他類所繼承

  - 例如 String類 System類 StringBuffer類

- final 用來修飾方法 表明此方法也不能被重寫

  - 例如 Object類中的getClass()

- final 修飾變數 : 此時的 變數 就稱為一個常數

  - final修飾屬性 : 可以考慮賦值的位置有 : 顯式初始化  程式區塊初始化 建構器初始化
    - 也就是對象創建後Heap空間中就會給予空間  此時就要明確的賦予值

  ``````java
  // 建構器
  public void show(){
  	NUM = 10;
  }
  // 傳入一個final值
  public void show(final int num){
  	// num = 20 錯誤
  	return num;  // 傳入的值不能被修改
  }
  ``````

  

  - final修飾局部變數
    - 使用final修飾參數時 表明此參數是一個常數 當我們調用此方法時 給常數參數賦予一個實際參數 一旦賦予後 就只能在方法體內使用此參數 但不能重新賦值

- static final 用來修飾屬性 全域常數



#### 面向對象-問題

static修飾的屬性 相較於實例變數 有哪些特別之處

- 隨著類的載入而載入 早於對象的創見
- 只要權限允許 可以通過 對象.static屬性 的方式進行調用
- 存在於方法區的靜態域

類的屬性賦值的位置有哪些  先後順序為何

- 預設初始化
- 顯式初始化  程式區塊初始化
- 建構器初始化
- 通過 對象.屬性  對象.方法賦值



#### 抽象abstract

abstract關鍵字使用

- abstract : 抽象的
- abstract可以用來修飾的結構 : 類 方法
- abstract修飾類 : 抽象類
  - 此類不能實例化
  - 抽象類中一定有建構器 便於子類實例化時調用 (涉及 : 子類對象實例化的全過程)
  - 開發中 都會提供抽象類的子類 讓子類對象實例化 完成相關的操作
- abstract修飾方法 : 抽象方法
  - 抽象方法只有方法的聲明 沒有方法體
  - 包含抽象方法的類 一定是一個抽象類 反之 抽象類中可以沒有抽象方法
  - 若子類重寫了父類中的所有抽象方法  則此子類可實例化
  - 若子類沒有重寫父類中的所有的抽象方法 則此子類也是一個抽象類 需要使用abstract修飾



abstract使用的注意點

- abstract不能用來修飾 屬性 建構器等結構
- abstract不能用來修飾私有方法 靜態方法 final的方法 final的類



思考

- 為什麼抽象類不能使用final關鍵字聲明
  - 抽象類的要求是子類的繼承重寫  宣告成final將無法進行重寫 修改
- 抽象類中可以定義建構器嗎
  - 可以 因為子類創建對象時會調用父類的建構器 載入屬性 方法
- 是否可以理解成 : 抽象類就是比普通類多定義了抽象方法  除了不能直接進行類的實例化操作外 並沒有任何的不同
  - 不能 
  - 抽象類不一定會宣告抽象方法   但是抽象方法所屬的類一定是抽象類



抽象類基本操作

- 創建抽象類
  - 聲明一個抽象方法

```java
public abstract class Employee {
    private String name;
    private int id;
    private double salary;
    public Employee(){
        super();
    }

    public Employee(String name, int id, double salary) {
        this.name = name;
        this.id = id;
        this.salary = salary;
    }
    public abstract void work();
}
```



- 繼承抽象類 
  - 重寫方法

```java
public class Manager extends Employee{

    private double bonus;

    public Manager(double bonus){
        super();
        this.bonus = bonus;
    }

    public Manager(String name, int id, double salary, double bonus) {
        super(name, id, salary);
        this.bonus = bonus;
    }

    @Override
    public void work() {
        System.out.println("Manager管理員工");
    }
}
```



- 執行方法
  - 使用多態性

```java
public class EmployeeTest {
    public static void main(String[] args) {
        Manager manager = new Manager("AAA",001,2000,500);

        manager.work();
    }
}
```



抽象類的匿名子類

``````java
public class PersonTest{
	public static void main(String[] args){
		method(new Student()); // 匿名對象
		
		Worker worker = new Worker();
		method1(worker); // 非匿名的類 非匿名的對象
		
		method1(new Worker()); // 非匿名的類Worker 匿名對象(沒有給予對象名字)
        
        // 抽象類Person 無法直接new
        // 創建了一個匿名類的對象 : p 
        Person p = new Person(){  // 為Person的子類
            @Override			  // 子類重寫方法
            public void eat(){
                
            }
            
            @Override
            public void breath(){
                
            }
        };
        
	}
	
	public static void method1(Person p){
		p.eat();
		p.walk();
	}
    public static void method(Person p){

	}
}
``````



模板方法的設計模式

```java
public class TemplateTest{
    public static void main(String[] args) {
        Template t = new SubTemplate();
        t.spendTime();
    }
}

abstract class Template {
    // 計算某段程式碼執行花費的時間
    public void spendTime(){
        long start = System.currentTimeMillis();

        this.code(); // 不確定的部分

        long end = System.currentTimeMillis();

        System.out.println("花費的時間為 : " + (end - start));
    }

    public abstract void code();
}

class SubTemplate extends Template{
    @Override
    public void code() {
        for (int i = 2;i <= 1000;i++){
            boolean isFlag = true;
            for (int j = 2; j < Math.sqrt(i); j++) {
                if (i%j == 0){
                    isFlag = false;
                    break;
                }
            }
            if (isFlag){
                System.out.println(i);
            }
        }
    }
}
```



#### interface

- 使用interface來定義
- Java中 interface和類是並列的兩個結構
- 如何定義interface : 定義interface中的成員
  - JDK7以前 : 只能定義全域常數和抽象方法
    - 全域常數 : public static final的 但是書寫時可省略不寫
    - 抽象方法 :public abstract
  - JDK8
    - 除了定義全域常數和抽象方法之外 還可以定義靜態方法 預設方法
- interface中不能定義建構器 : 表示著interface不可實例化
- Java開發中 interface通過讓類去實現(implement)的方式來使用
  - 如果實現類覆蓋了interface中所有的抽象方法 則此實現類就可以實例化
  - 如果實現類沒有覆蓋interface中所有的抽象方法 則此實現類仍為一個抽象類
- Java類可以實現多個interface --> 彌補了Java單繼承性的侷限性
  - 格式 : Class AA entends BB implements CC,DD,EE
- interface之間可以繼承  而且可以多繼承
  - interface AA extends BB,CC
- interface的具體使用 : 體現多態性
- interface 實際上可以看做是一種規範



抽象類和interface有哪些異同



```java
public class InterfaceTest {
    public static void main(String[] args) {
        System.out.println();
        System.out.println();
    }
}

interface Flyable{
    // 全域常數
    public static final int MAX_SPEED = 7900;
    int MIN_SPEED = 1; // 省略了public static final

    // 抽象方法
    public abstract void fly();
    // 省略了 public abstract
    void stop();
    // Interfaces cannot have constructors
//    public Flyable(){ }
}

class Plane implements Flyable{
    @Override
    public void fly() {

    }

    @Override
    public void stop() {

    }
}
```



匿名實現類和對象

```java
public class USBTest {
    public static void main(String[] args) {
        Computer computer = new Computer();

        // 1.創建interface的 非匿名類 非匿名對象
        Flash flash = new Flash();
        computer.transferData(flash);

        // 2.創建interface的 非匿名類 匿名對象
        computer.transferData(new Printer());

        // 3.創建interface的 匿名實現類 非匿名對象(phone)
        // USB為interface 直接定義方法
        USB phone = new USB() { // 匿名實現類 : 不創建實作的類  直接創建interface
            @Override
            public void start() {
                System.out.println("匿名對象 - phone開始工作");
            }

            @Override
            public void stop() {
                System.out.println("匿名對象 - phone結束工作");
            }
        };
        computer.transferData(phone);

        // 4.創建interface的 匿名實現類 匿名對象
        computer.transferData(new USB() {
            @Override
            public void start() {
                System.out.println("mp3 開始工作");
            }

            @Override
            public void stop() {
                System.out.println("mp3 結束工作");
            }
        });

    }
}

class Computer{
    public void transferData(USB usb){
        usb.start();

        System.out.println("具體數據的處理細節");

        usb.stop();
    }
}

interface USB{
    void start();

    void stop();
}

class Flash implements USB{
    @Override
    public void start() {
        System.out.println("Flash 開始工作");
    }

    @Override
    public void stop() {
        System.out.println("Flash 結束工作");
    }
}

class Printer implements USB{
    @Override
    public void start() {
        System.out.println("Printer 開始工作");
    }

    @Override
    public void stop() {
        System.out.println("Printer 結束工作");
    }
}
```



#### JDK8新特性

- interface中定義的靜態方法 只能通過interface來調用
- 通過實現類的對象 可以調用interface中的預設(default)方法
  - 如果實現類重寫了interface中的預設方法 調用時 仍然調用的是重寫以後的方法
- 如果子類(或實現類)繼承的父類和實現的interface中聲明了同名同參數的預設方法
  - 那麼子類在沒有重寫此方法的情況下 預設調用的是父類中的同名同參數的方法 --> 類優先原則
- 如果實現類實現了多個interface 而這多個interface中定義了同名同參數的預設方法
  - 那麼在實現類沒有重寫此方法的情況下 報錯 --> interface衝突
  - 那麼就需要我們在實現類中重寫此方法





#### 代理模式(Proxy)

靜態代理 : 專門為某一個interface提供的代理

```java
public class NetWorkTest {
    public static void main(String[] args) {
        Server server = new Server();
        ProxyServer proxyServer = new ProxyServer(server);
        proxyServer.browse();
    }
}

interface NetWork{
    public void browse();
}

// 被代理類
class Server implements NetWork{
    @Override
    public void browse() {
        System.out.println("真實的伺服器訪問網路");
    }
}

// 代理類
class ProxyServer implements NetWork{
    private NetWork work;
    // 屬性初始化
    public ProxyServer(NetWork work){
        this.work = work;
    }

    // 代理類增強的方法
    public void check(){
        System.out.println("連接網路前的檢查工作");
    }
    @Override
    public void browse() {
        check();
        work.browse();
    }
}
```



#### 面試題

``````java
interface A {
	int x = 0;
}
class B{
	int x = 1;
}
class C extends B implements A{
	public void pX(){
		// System.out.println(x); 錯誤 向上同時繼承了兩個同級的x
		System.out.println(super.x); // x = 1
		System.out.println(A.x);  //  x = 0
	}
	public static void main(String[] args){
		new C().pX();
	}
}
``````



#### 類的成員 : 內部類

- Java中允許將一個類A聲明在另一個類B中 , 則類A就是內部類  類B稱為外部類

- 內部類的分類 

  - 成員內部類 (靜態 , 非靜態)   
  - 局部內部類 (方法內 , 程式區塊內 , 建構器內)

- 成員內部類

  - 一方面作為外部類的成員
    - 調用外部類的結構
    - 可以被static修飾
    - 可以被4種不同的權限修飾
  - 另一方面作為一個類
    - 類內可以定義屬性 方法 建構器等
    - 可以被final修飾 表示此類不能被繼承
      - 或不使用final 則可以被繼承
    - 可以是abstract修飾

- 如下問題

  - 如何實例化成員內部類的對象
  - 如何在成員內部類中區分調用外部類的結構

  ```java
  public class InnerClassTest {
      public static void main(String[] args) {
          // 創建Dog實例 (靜態的成員內部類)
          Person.Dog dog = new Person.Dog();
          dog.show();
  
          // 創建Bird實例 (非靜態的成員內部類)
          Person p = new Person();  // 創建對象 創建Bird
          Person.Bird bird = p.new Bird();
          bird.sing();
  
          System.out.println("---------------------");
          bird.display("new bird-name");
  
      }
  
  }
  
  
  class Person{
      String name = "person-name";
      int age;
  
      public void eat(){
          System.out.println("person to eat");
      }
  
      // 靜態成員內部類
      static class Dog{
          String name;
          int age;
          public void show(){
              System.out.println("a dog");
  //            eat();  無法調用外部類的非靜態屬性
          }
      }
  
      // 非靜態成員內部類
      class Bird{
          String name = "brid-name";
  
          public void sing(){
              System.out.println("bird singing");
              Person.this.eat(); // 調用外部類的非靜態屬性
              System.out.println(age);
          }
          public void display(String name){
              System.out.println(name); // 方法的參數
              System.out.println(this.name); // 內部類的屬性
              System.out.println(Person.this.name); // 外部類的屬性
          }
      }
  
  
      public void method(){
          // 局部內部類
          class AA{
  
          }
      }
  
      {
          // 局部內部類
          class BB{
  
          }
      }
  
      public Person(){
          // 局部內部類
          class CC{
  
          }
      }
  }
  ```

  - 開發中局部內部類的使用

  ```java
  public class InnerClassTest2 {
  
      // 少見
      public void method(){
  
          // 局部內部類
          class AA{
  
          }
      }
  
      // 方式一  非匿名類   匿名對象
      // 返回了一個實現了Comparable接口的類的對象  較常用
      public Comparable getComparable(){
  //        // 創建一個實現了Comparable接口的類
  //        class MyComparable implements Comparable{
  //            @Override
  //            public int compareTo(Object o) {
  //                return 0;
  //            }
  //        }
  //        return new MyComparable();
  
          // 方式二  匿名實現類 匿名對象
          return new Comparable() {
              @Override
              public int compareTo(Object o) {
                  return 0;
              }
          };
      }
  }
  ```





#### 抽象-問題

- abstract能修飾那些結構  修飾後有哪些特點
  - 類 方法
  - 類不能實例化 提供子類
    - 抽象方法只定義了一種功能的標準 具體的執行 需要子類去實現
- 接口是否能繼承接口  抽象類是否能實現接口   抽象類是否能繼承非抽象的類
  - 可以
  - 可以
  - 可以 , 沒有特別指明都繼承自Object
- 聲明抽象類 並包含抽象方法 測試類中創建一個繼承抽象類的匿名子類的對象

``````java
abstract AA{
	public abstract void m();
}
main(){
	AA a = new AA(){
		public void m(){
		
		}
	};
	a.m();
}

普通類一樣的創建
class Person{
    String name;
    public void eat();
}
main(){
    Person p = new Person(){
        public void eat(){}
    };
    p.eat();
}
``````



- 抽象類和接口有哪些共同點
  - 相同點
    - 不能實例化  都可以被繼承
  - 不同點
    - 抽象類有建構器   接口沒有建構器
    - 抽象類只能單繼承  接口可以有多繼承
- 如何創建靜態成員內部類和非靜態成員內部類的對象
  - 靜態直接創建
  - 非靜態成員內部類  需先聲明外部類

``````java
Person  static Dog  Bird
// 創建
Person.Dog dog = new.Person.Dog();

Person p = new Person();
Person.Bird bird = p.new Bird();
``````



# 異常



Error

``````java
public class ErrorTest{
	public static void main(String[] args){
		// stack溢出 java.lang.StackOverflowError
		// main(args);
		
		// Heap溢出 java.lang.OutOfMemoryError
		Integer[] arr = new Integer[1024*1024*1024];
	}
}
``````



#### 異常概述 異常體系結構

異常體系結構

- java.lang.throwable
  - java.lang.Error : 一般不編寫針對性的程式碼進行處理
  - java.lang.Exception : 可以進行異常的處理
    - 編譯時異常 (checked)
      - IOException
        - FileNotFoundException
      - ClassNotFoundException
    - 運行時異常 (unchecked , RuntimeException)
      - NullPointerException
      - ArrayIndexOutOfBoundException
      - ClassCastException
      - NumberFormatException
      - InputMismatchException
      - ArithmeticException



#### 常見異常

```java
public class ExceptionTest {
    public static void main(String[] args) throws IOException {

        // ****************編譯時異常******************
        // 需要拋出異常
        File file = new File("hello.txt");
        FileInputStream fis = new FileInputStream(file);

        int data = fis.read();
        while (data != -1){
            System.out.println(data);
            data = fis.read();
        }
        fis.close();

        // ****************運行時異常******************

        // ArithmeticException
        int a = 10;
        int b = 0;
        System.out.println(a/b); // 除以0 報錯


        // InputMismatchException
        Scanner scanner = new Scanner(System.in);
        int i = scanner.nextInt();  // 當輸入不為int類時 輸入不匹配
        System.out.println(i);

        // NumberFormatException
        String str = "123";
        str = "abc"; // 不是數字類型
        int i = Integer.parseInt(str);

        // ClassCastException
        Object obj = new Date();
        String str = (String) obj;

        // IndexOutOfBoundsException

            ArrayIndexOutOfBoundException
            int[] arr = new int[10];
            System.out.println(arr[10]);

        // NullPointerException

        int[] arr = null;
        System.out.println(arr[3]);

        String str = "abc";
        str = null;
        System.out.println(str.charAt(0));

    }
}
```



#### 異常處理機制-try-catch-finally



異常的處理 : 抓拋模型

- 拋 :  程式在正常執行的過程中 一旦出現異常 就會在異常程式處生成一個對應異常類的對象 並將此對象拋出
  - 關於異常的產生
    - 系統自動生成的異常對象
    - 手動的生成一個異常對象 並拋出 throw
- 抓 : 一旦拋出對象以後 其後的程式碼就不再執行  理解成異常的處理方式
  - try-catch-finally
  - throws



try-catch-finally的使用

``````java
try{
	// 可能出現異常的程式碼
}catch(異常類型1 變數名1){
	// 處理異常的方式1
}catch(異常類型2 變數名2){
	// 處理異常的方式2
}catch(異常類型3 變數名3){
	// 處理異常的方式3
}
....
finally{
	// 一定會執行的程式碼
}
``````



- finally是可選的
- 使用try將可能出現異常的程式碼區塊包裝起來 在執行過程中 一旦出現異常 就會生成一個對應異常類的對象 根據此對象的類型 去catch中進行匹配
- 一旦try中的異常對象匹配到某一個catch時 就會進入catch中進行異常的處理 一旦處理完成 就跳出當前的try-catch結構 (在沒有寫finally的情況)  繼續執行其後的程式碼
- catch中的異常類型如果沒有子父類關係 則聲明的順序可以自定義
- catch中的異常類型如果滿足子父類關係 則要求子類要聲明在父類的上面 否則會出錯
- 常用的異常對象處理的方式
  - String getMessage()
  - printStackTrace()
- 在try結構中聲明的變數 出了try結構後 就不能再被調用



使用try-catch-finally處理編譯時異常  使得程式在編譯時就不再報錯 但是運行時仍可能報錯

相當於我們使用try-catch-finally將一個編譯時可能出現的異常 延遲到運行時出現



開發中 由於運行時異常比較常見 所以我們通常不針對運行時異常編寫try-catch-finally 

但是針對於編譯時異常 我們一定要考慮異常的處理



```java
public class ExceptionTest1 {
    public static void main(String[] args) {
        String str = "123";
        str = "abc";
        try {
         int num = Integer.parseInt(str);
            System.out.println("hello ---- 1");
        }catch (NumberFormatException e){
            System.out.println("出現數值轉換異常");
            // String getMessage();
            System.out.println(e.getMessage()); // For input string: "abc"
            // PrintStackTrace();
            e.printStackTrace(); // 印出錯誤訊息
        }catch (NullPointerException e){
            System.out.println("出現空指針異常");
        }catch (Exception e){
            System.out.println("出現異常了");
        }

        System.out.println("hello ---- 2");
    }
}
```



finally的使用

- finally是可選的
- finally中聲明的是一定會被執行的程式碼 即使catch中又出現了異常 try中有return雨具 catch中有return語句等情況
- 像資料庫連接 輸入輸出流 網路編成Socket等資源 JVM是不能自動回收的 我們需要自己手動地進行資源釋放 此時的資源釋放 就需要聲明在finally中

```java
public class FinallyTest {
    public static void main(String[] args) {
        System.out.println(method());
    }
    public static int method(){
        try {
            int a = 10;
            int b = 0;
            System.out.println(a/b);
            return 1;
        }catch (ArithmeticException e){
            e.printStackTrace();
            return 2;  // 捕獲異常  執行返回
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            System.out.println("finally執行");
            // 只要finally最後有return  都會執行finally的return
            return 3;   // 不論捕獲了異常 還是try catch進行了return   在之前都會執行finally
        }
    }
}
```



#### 異常處理機制 throws

throws + 異常類型

- throws + 異常類型 寫在方法的聲明處 
  - 指名此方法執行時 可能會拋出的異常類型 一旦當方法執行時 出現異常 仍會在異常程式處生成一個異常類的對象 
  - 此對象滿足throws後異常類型時 就會被拋出 異常程式碼後續的程式 就不再執行
- try-catch-finally : 真正的將異常給處理掉了
  - throws的方式只是將異常拋給了方法的調用者 並沒有真正將異常處理掉
- 開發中如何選擇使用 try-catch-finally 還是使用 throws
  - 如果父類中被重寫的方法沒有throws方式處理異常 則子類重寫的方法也不能使用throws
    - 表示如果子類重寫的方法中有異常 必須使用try-catch-finally方式處理
  - 執行的方法a中 先後又調用了另外的幾個方法 這幾個方法是遞進關係執行的 建議這幾個方法使用throws的方式進行處理
    - 而執行的方法a可以考慮使用try-catch-finally的方式統一處理所有可能會有異常的方法

```java
public class ExceptionTest2 {
    public static void main(String[] args){
        try {
            method2();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static void method2() throws IOException {
        method1();
    }

    public static void method1() throws IOException {
        File file = new File("hello.txt");
        FileInputStream fis = new FileInputStream(file);

        int data = fis.read();
        while (data != -1){
            System.out.println(data);
            data = fis.read();
        }
        fis.close();
    }
}
```



#### 手動拋出異常 throw

- 手動生成一個異常對象 並拋出(throw)
  - throw new xxxxx 
  - 非運行時異常需拋出 throws

```java
public class StudentTest {
    public static void main(String[] args) {
        try {
            Student student = new Student();
            student.regist(-100);
            System.out.println(student);
        }catch (Exception e){
            System.out.println(e.getMessage());
        }
    }
}
class Student{
    private int id;
    public void regist(int id) throws Exception{
        if (id > 0){
            this.id = id;
        }else {
//            System.out.println("輸入的數據是非法的");
            // 手動拋出
//            throw new RuntimeException("輸入的數據是非法的");
            throw new Exception("輸入的數據是非法的");
        }
    }
}
```



#### 自定義異常類

- 繼承於現有的異常結構 : RuntimeException  Exception
- 提供全域變數 : serialVersionUID
- 提供重載的建構器

```java
public class MyException extends RuntimeException{

    static final long serialVersionUID = -7034897190745766939L;

    public MyException(){

    }

    public MyException(String msg){
        super(msg);
    }
}
```



#### 自定義異常-練習



自定義異常

```java
public class EcDef extends Exception{
    static final long serialVersionUID = -3387516993124229948L;

    public EcDef(){

    }

    public EcDef(String msg){
        super(msg);
    }
}
```

測試使用

```java
public class EcmDef {
    public static void main(String[] args) {
        try {
            int i = Integer.parseInt(args[0]); // 可能發生轉換異常 index溢出
            int j = Integer.parseInt(args[1]);

            int result = ecm(i, j);
            System.out.println(result);
        }catch (NumberFormatException e){
            System.out.println("數據類型不一致");
        }catch (ArrayIndexOutOfBoundsException e){
            System.out.println("缺少命令行參數");
        }catch (ArithmeticException e){
            System.out.println("算術異常 除以0");
        }catch (EcDef e){
            System.out.println(e.getMessage());
        }
    }

    public static int ecm(int i,int j) throws EcDef{
        if (i < 0 || j < 0){
            throw new EcDef("分子或分母為負數");
        }
        return i / j;
    }
}
```



#### 異常-總結

throw throws區別

- throws是異常處理的一種方式
  - 聲明方法可能要拋出的各種異常類
- throw為手動拋出異常對象  
  - 生成一個異常對象



程式執行過程 編譯時異常和運行時異常

- 編譯時異常
  - 執行javac.exe命名時 可能出現的異常
- 運行時異常
  - 執行java.exe命名時 可能出現的異常



如何看待編譯時異常和運行時異常

- 編譯時異常
  - 使用try-catch-finally處理編譯時異常 相當於將可能出現的異常延遲到運行時出現 
- 運行時異常
  - 由於運行時異常比較常見 我們通常不針對運行時異常編寫try-catch-finally
- 針對於編譯時異常 我們一定要考慮異常的處理



final finally finalize(方法名) 三者的區別

- final
  - 修飾 類 方法 變數
  - 修飾後 類不能被繼承  方法不能重寫  變數不能重新賦值
- finally
  - 用於try-catch中  最後一定會執行的程式區塊
- finalize
  - 當對象被回收前 會調用當前對象的finalize方法



# 多執行緒



#### 程式 進程 線程

程序(進程)、執行緒(線程)



- 程序 (program)
  - 是為完成特定任務 用某種語言編寫的一組指令的集合 即指**一段靜態的程式碼** 靜態對象
- 進程 (Process)
  - 是程式的一次執行過程 或是**正在運行的一個程式** 是一個動態的過程 
  - 有他自身的產生 存在 消亡的過程 --- 生命週期
    - 例如 : 運行中的應用程式
    - program是靜態的  process是動態的
    - **process作為資源分配的單位** 系統在運行時會為每個process分配不同的記憶體區域 
- 線程 (thread)
  - process可進一步細分為thread  是一個程式內部的一條執行路徑
    - 若一個process同一時間並行執行多個thread 則為支持多個thread的
    - **thread作為調度和執行的單位 每個thread擁有獨立的運行Stack和程式計數器(PC)**  thread切換的消耗小
    - 一個process的多個thread共享相同的記憶體單元 記憶體位址空間  --> 他們從同一個Heap中分配對象 可以訪問相同的變數和對象  使得thread間通訊更簡便 高效 
      - 同一個process中的所有thread共享 Method Area  和  Heap
    - 但多個thread操作共享的系統資源可能就會帶來**安全的隱憂**



#### 執行緒的創建和使用

方式一

- 創建一個繼承Thread類的子類
- 重寫Thread類的run()
- 創建Thread類的子類的對象
- 通過此對象調用start()
  - 啟動當前Thread
  - 調用當前Thread的run()

兩個問題

- 不能直接使用對象執行run()方法   因為無法進行執行緒的啟動操作
- 不能在已經執行start()方法的對象中再次執行start()

```java
/*
    創建繼承於Thread類的子類
    重寫run()
    創建Thread類的子類的對象
    通過對象調用start()
 */

public class ThreadTest {
    public static void main(String[] args) {

        // 創建對象
        MyThread myThread = new MyThread();

        // 調用方法start() : 啟動當前thread   調用當前thread的run()
        myThread.start();
        for (int i = 0; i < 100; i++) {
            System.out.println("hello----" + i + " thread name " + Thread.currentThread().getName());
        }

        // 問題一 我們不能通過直接調用run()的方式啟動thread  執行的會是當前執行緒而不是多執行緒
//        myThread.run();

        // 問題二 我們不能讓已經start()的thread去執行 會報 IllegalThreadStateException
        myThread.start();
    }
}

class MyThread extends Thread{
    // 2. 重寫run方法
    @Override
    public void run() {
        for (int i = 0 ; i < 100; i++){
            if (i % 2 == 0){
                System.out.println(i + " thread name " + Thread.currentThread().getName());
            }
        }
    }
}
```



#### Thread常用方法-優先級

```java
/*
    start() 啟動當前thread  調用當前thread的run()
    run() 通常需要重寫thread類中的此方法 將創建的thread要執行的操作聲明在此方法中
    currentThread() 靜態方法 返回執行當前程式碼的thread
    getName() 獲取當前thread的名字
    setName() 設置當前thread的名字
    yield() 釋放當前cpu的執行權
    join() 在threadA中調用執行緒threadB的join()  此時threadA就進入阻塞狀態
    stop() 已過時 當執行此方法時 強制結束當前執行緒
    sleep(long millitime) 讓當前的Thread睡眠指定的millitime毫秒 在指定的millitime
                          毫秒時間內 當前的thread是阻塞的
    isAlive() 判斷當前thread是否存活

    thread優先級
    MAX_PRIORITY : 10
    MIN_PRIORITY : 1
    NORM_PRIORITY : 5
    如何獲取和設置當前執行緒的優先級
    getPriority() : 獲取thread的優先級
    setPriority(int p) : 設置thread的優先級

    說明 : 高優先級的thread要搶占低優先級thread cpu的執行權
          只是從機率上來看 高優先級的thread高機率的情況下被執行
          並不代表一定會是高優先級的thread執行完後 才執行低優先級的thread


 */
public class ThreadMethodTest {
    public static void main(String[] args) {

        // 主要thread命名 設置優先級
        Thread.currentThread().setName("Main Thread");
        Thread.currentThread().setPriority(Thread.MIN_PRIORITY);

        HelloThread h1 = new HelloThread("thread-0001");

        // 設置thread的優先級
        h1.setPriority(Thread.MAX_PRIORITY);

//        h1.setName("thread-0001");
        h1.start();
        for (int i = 0; i < 100; i++) {
            if (i % 2 == 0){
                System.out.println(Thread.currentThread().getName() + ":" + i);
            }
        }

    }
}

class HelloThread extends Thread{
    public HelloThread() {
    }

    public HelloThread(String name) {
        super(name);
    }

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            if (i % 2 == 0){
//                try {
//                    sleep(1000);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
                System.out.println(Thread.currentThread().getName() + ":" + i);
            }
//            if (i % 60 == 0){
//                this.yield();
            }
        }
    }
```



#### 創建方式Runnabble

```java
/*
    創建一個實現了Runnable接口的類
    實現類中實現Runnable中的抽象方法 run()
    創建實現類的對象
    將此對象作為參數傳遞到Thread類的建構器中 創建Thread類的對象
    通過Thread類的對象調用start()
 */

public class ThreadTest1 {
    public static void main(String[] args) {
        // 創建實現類的對象
        MThread m1 = new MThread();
        // 將此對象作為參數傳遞到Thread類的建構器中 創建Thread類的對象
        Thread t1 = new Thread(m1);
        t1.setName("Thread-001");
        // 通過Thread類的對象調用start() : 啟動Thread
        // 調用當前Thread的run(0 --> 調用了Runnable類型的target的run()
        t1.start();

        //
        Thread t2 = new Thread(m1);
        t2.setName("Thread-002");
        t2.start();
    }
}

class MThread implements Runnable{
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            if (i % 2 == 0){
                System.out.println(i);
            }
        }
    }
}
```



#### 比較兩種創建方式

- 優先選擇 : 實現Runnable的方式
  - 實現的方式沒有類的單繼承性的侷限性
  - 實現的方式更適合來處理多個執行緒間有共享數據的情況
- 聯繫 : public class Thread implements Runnable
- 相同點
  - 兩種方式都需要重寫run()  將執行緒要執行的邏輯聲明在run()中



繼承Thread

```java
public class WindowTest{
    public static void main(String[] args) {
        // 創建了3個Window對象
        Window t1 = new Window();
        Window t2 = new Window();
        Window t3 = new Window();

        t1.setName("售票口1");
        t2.setName("售票口2");
        t3.setName("售票口3");

        t1.start();
        t2.start();
        t3.start();
    }
}

class Window extends Thread{
    // 需要宣告為static 保持只有一份數據
    private static int ticket = 10;

    @Override
    public void run() {
        while (true){
            if (ticket > 0){
                System.out.println(Thread.currentThread().getName() + ": 賣票 票號為: " + ticket);
                ticket--;
            }else {
                break;
            }
        }
    }
}
```



實現Runnable

```java
public class WindowTest1 {
    public static void main(String[] args) {
        // 只創建了一個Window1對象
        Window1 w1 = new Window1();
        // 後續放入Thread共用同一個Window1
        Thread t1 = new Thread(w1);
        Thread t2 = new Thread(w1);
        Thread t3 = new Thread(w1);

        t1.setName("售票口1");
        t2.setName("售票口2");
        t3.setName("售票口3");

        t1.start();
        t2.start();
        t3.start();


    }


}

class Window1 implements Runnable{
    private int ticket = 10;

    @Override
    public void run() {
        while (true){
            if (ticket > 0){
                System.out.println(Thread.currentThread().getName() + ": 賣票 票號為: " + ticket);
                ticket--;
            }else {
                break;
            }
        }
    }
}
```



#### 執行緒的生命週期

分成五種狀態

- 新建
  - 當一個Thread類或其子類的對象被聲明並創建時 新生的Thread對象處於新建狀態
- 就緒
  - 處於新建狀態的Thread被start()後 將進入Thread排列等待CPU 此時他已經具備運行的條件 只是還沒分配到CPU資源
- 運行
  - 當就緒的Thread被調度並獲得CPU資源時 便進入運行狀態  run()方法定義了Thread的操作和功能
- 阻塞
  - 在某種特殊狀況下 被人為掛起或執行輸入輸出操作時 讓出CPU並臨時中止自己的執行 進入阻塞狀態
- 死亡
  - Thread完成了他的全部工作或Thread被提前強制性的中止或出現異常導致結束



狀態交替

- 新建  -->  就緒
  - 調用start()
- 就緒  -->  運行
  - 獲取CPU執行權
- 運行  --> 就緒
  - 失去CPU執行權 或 yield()
- 運行  --> 阻塞
  - sleep(long time)
  - join()
  - 等待同步鎖
  - wait()
  - suspend()
- 阻塞  -->  就緒
  - sleep()時間到
  - join()結束
  - 獲取同步鎖
  - notify() / notifyAll()
  - resume()
- 運行  -->  死亡
  - 執行完run()
  - 調用Thread的stop()
  - 出現Error / Exception 且未處理



#### 執行緒的同步

售票問題

- 售票過程中 出現了重票 錯票 --> 執行緒上的安全問題
- 出現原因 : 當某個執行緒操作的過程中 尚未操作完成時 其他執行緒參與近來 也進行操作
- 如何解決 : 當一個執行緒a在操作時 其他執行緒不能參與近來 直到執行緒a操作完後 其他執行緒才可以開始操作  這種情況即使執行緒a出現了阻塞 也不能被改變
- 通過同步機制 來解決執行緒安全的問題



方式一 : 同步程式區塊

```
synchronized(同步監視器){
 // 需要被同步的程式碼

 }
```

-  說明 : 操作共享數據的程式碼 即為需要被同步的程式碼
   - 共享數據 : 多個執行緒共同操作的變數
     - 不能包含的程式碼多了 或是 少了
   - 同步監視器 : 鎖 任何一個類的對象 都可以擔任
   - 要求 : 多個執行緒必須共用同一把鎖

實現Runnalbe創建多執行緒的方式中 可以考慮使用this當作同步監視器

在繼承Thread創建多執行緒的方式中 慎用this當作同步監視器  可以考慮使用當前類 xxx.class

無論哪一種作法 要確保同步監視器是唯一的



方式二 : 同步方法

- 同步方法仍然涉及到同步監視器  只是不需要顯式的聲明
- 非靜態的同步方法  同步監視器是 : this
- 對於靜態的同步方法  同步監視器是 : 當前類本身

```java
// 實現Runnable  同步方法
public class Window2{
    public static void main(String[] args) {

        Window02 w = new Window02();

        Thread t1 = new Thread(w);
        Thread t2 = new Thread(w);
        Thread t3 = new Thread(w);


        t1.setName("售票口1");
        t2.setName("售票口2");
        t3.setName("售票口3");

        t1.start();
        t2.start();
        t3.start();
    }
}

class Window02 implements Runnable{
    // 需要宣告為static 保持只有一份數據
    private static int ticket = 100;

    @Override
    public void run() {
        while (true){
            if (ticket > 0){
                show();
            }else {
                break;
            }
        }
    }
    private synchronized void show(){ // 同步監視器 : this
        if (ticket > 0){
            System.out.println(Thread.currentThread().getName() + ": 賣票 票號為: " + ticket);
            ticket--;
        }
    }
}
```



```java
// 使用同步方法處理繼承Thread類的方式中的執行緒安全問題
public class WindowTest3{
    public static void main(String[] args) {
        // 創建了3個Window對象
        Window03 t1 = new Window03();
        Window03 t2 = new Window03();
        Window03 t3 = new Window03();

        t1.setName("售票口1");
        t2.setName("售票口2");
        t3.setName("售票口3");

        t1.start();
        t2.start();
        t3.start();
    }
}

class Window03 extends Thread{
    // 需要宣告為static 保持只有一份數據
    private static int ticket = 100;

//    static Object obj = new Object();

    @Override
    public void run() {
        while (true){
                show();
            }
    }
    private static synchronized void show(){ // 同步監視器 : Window03.class
//    private synchronized void show(){ // 同步監視器 t1 t2 t3 此種解決方式是錯誤的
        if (ticket > 0){
            System.out.println(Thread.currentThread().getName() + ": 賣票 票號為: " + ticket);
            ticket--;
        }
    }
}
```



- 同步的方法 解決了執行緒的安全問題
- 操作同步程式碼時 只能有一個執行緒參與 其他的執行緒等待 相當於一個單執行緒的過程 效率低



#### 執行緒安全-懶漢式單例

```java
class Bank{
    private Bank(){

    }

    private static Bank instance = null;

    public static Bank getInstance(){
//        // 方式一 : 效率較差
//        synchronized (Bank.class) {
//            if (instance == null){
//
//                instance = new Bank();
//            }
//            return instance;
//        }
        // 方式二 : 在進行排隊之前 先判斷是否有排隊的必要性
        if (instance == null){
            synchronized (Bank.class) {
                if (instance == null){

                    instance = new Bank();
                }
            }
        }
        return instance;
    }
}
```



#### 死鎖問題

- 不同的執行緒分別占用對方需要的同步資源不放棄  都在等待對方放棄自己需要的同步資源 形成了執行緒的死鎖
- 出現死鎖後 不會出現異常 提示 只是所有的執行緒都處於阻塞狀態



#### Lock鎖

- JDK5.0新增

synchronized 與 Lock 的異同

- 相同點
  - 兩者都可以解決執行緒安全問題
- 不同點
  - synchronized機制在執行完相應的同步程式後 自動的釋放同步監視器
  - Lock需要手動的啟動同步lock()   同時結束同步也需要手動的實現unlock()

優先使用順序

- Lock --> 同步程式區塊 (已經進入方法體 分配了相應資源) --> 同步方法 (在方法體之外)



#### 執行緒的通訊

涉及到的方法

- wait() 
  - 一旦執行此方法 當前執行緒都進入阻塞狀態 並釋放同步監視器
- notify() 
  - 一旦執行此方法 就會喚醒被wait的一個執行緒 如果有多個執行緒被wait 則喚醒優先級高的執行緒
- notifyAll()
  - 一旦執行此方法 就會喚醒所有被wait的執行緒
- wait() notify() notifyAll() 方法
  - 必須使用在同步程式區塊或同步方法中
  - 調用者必須是同步程式區塊或同步方法中的同步監視器
    - 否則會出現IllegalMonitorStateException異常
  - 定義在java.lang.Object類中
    - 為了要讓任何一個類的對象都可以擔任同步監視器



#### sleep() wait()

相同點

- 一旦執行方法 都可以使得當前的執行緒進入阻塞狀態

不同點

- 兩個方法聲明的位置不同
  - Thread類中聲明sleep()
  - Object類中聲明wait()
- 調用的要求不同
  - sleep() 可以在任何需要的地方調用
  - wait() 必須使用在同步程式區塊或同步方法中
- 關於是否釋放同步監視器
  - 如果兩個方法都使用在同步程式區塊或同步方法中
    - sleep()不會釋放鎖
    - wait()會釋放鎖



#### 生產者 消費者問題

```java
/*
    是否為多執行緒問題 ?  是 生產者執行緒  消費者執行緒
    是否有共享數據 ?  是 店員(或產品)
    如何解決執行緒安全的問題 ?  同步機制 有三種方法
    是否涉及到執行緒的通訊 ?  是

 */
public class ProductTest {
    public static void main(String[] args) {
        Clerk clerk = new Clerk();
        Producer p1 = new Producer(clerk);
        p1.setName("生產者1");

        Consumer c1 = new Consumer(clerk);
        c1.setName("消費者1");

        p1.start();
        c1.start();

    }
}

class Clerk{

    private int productCount = 0;

    // 生產產品
    public synchronized void produceProduct(){ // Clerk.class
        if ( productCount < 20){
            productCount++;
            System.out.println(Thread.currentThread().getName() + ": 開始生產第" + productCount + "個產品");
            // 生產完至少一個產品 就可以喚醒消費者
            notify();
        }else {
            System.out.println("生產者等待消費..........");
            // 等待
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

    }

    // 消費產品
    public synchronized void consumeProduct(){
        if (productCount > 0){
            System.out.println(Thread.currentThread().getName() + "開始消費第" + productCount + "個產品");
            productCount--;
            // 消費完至少一個產品 就可以喚醒生產者
            notify();
        }else {
            System.out.println("消費者等待生產..........");
            // 等待
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

// 生產者
class Producer extends Thread{

    private Clerk clerk;

    public Producer(Clerk clerk) {
        this.clerk = clerk;
    }

    @Override
    public void run() {
        System.out.println(getName() + " 開始生產商品... ");
        while (true){

            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            clerk.produceProduct();
        }
    }
}

// 消費者
class Consumer extends Thread{
    private Clerk clerk;

    public Consumer(Clerk clerk) {
        this.clerk = clerk;
    }

    @Override
    public void run() {
        System.out.println(getName() + " 開始消費商品... ");
        while (true){

            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            clerk.consumeProduct();
        }
    }
}
```



#### 實現Callable

- 相比run()方法 可以有返回值
- 方法可以拋出異常
- 支持泛型的返回值
- 需要藉助FutureTask類  例如獲取返回結果

```java
/*
    如何理解實現Callable接口的方式創建多執行緒比實現Runnable接口創建多執行緒方式強大
        1. call()可以有返回值
        2. call()可以拋出異常 被外面的操作捕獲 獲取異常的訊息
        3. Callable是支持泛型的
 */
public class ThreadNew {
    public static void main(String[] args){
        // 3. 創建Callable接口實現類的對象
        NumThread n1 = new NumThread();
        // 4. 將此Callable接口實現類的對象作為參數傳遞FutureTask建構器中 創建FutureTask的對象
        FutureTask<Integer> futureTask = new FutureTask<Integer>(n1); // FutureTask 實現了 Runnable
        // 5. 將FutureTask的對象作為參數傳遞到Thread類的建構器中 創建Thread對象 並調用start()
        new Thread(futureTask).start();

        try {
            // 6. 獲取Callable中call方法的返回值
            // get()返回值即為FutureTask建構器參數Callable實現類重寫的call()的返回值
            Integer sum = futureTask.get();
            System.out.println("總合為 : " + sum);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e){
            e.printStackTrace();
        }


    }
}

// 1. 創建一個實現Callable的實現類
class NumThread implements Callable<Integer> {
    // 2. 實現call方法 將此執行緒需要執行操作聲明在call()中
    @Override
    public Integer call() throws Exception {
        int sum = 0;
        for (int i = 0; i < 100; i++) {
            if (i%2 == 0){
                System.out.println(i);
                sum += i;
            }
        }
        return sum;
    }
}
```



#### 使用執行緒池

- 經常創建和銷毀 使用量特別大的資源
  - 例如並發情況下的執行緒 對性能影響較大
- 提前創建多個執行緒 放入執行緒池中 使用時值些獲取 使用完放回池中 可以避免頻繁的創建銷毀 實現重複利用 
- 優點
  - 提高響應速度 (減少了創建新執行緒的時間)
  - 降低資源消耗 (重複利用執行緒池中的執行緒 不需要每次創建)
  - 便於執行緒管理
    - corePoolSize : 核心池的大小
    - maximumPoolSize : 最大執行緒數
    - keepAliveTime : 執行緒沒有任務時最多保持多長時間終止

```java
/*
    corePoolSize : 核心池的大小
    maximumPoolSize : 最大執行緒數
    keepAliveTime : 執行緒沒有任務時最多保持多長時間後會終止

 */
public class ThreadPool{
    public static void main(String[] args) {
        // 1. 提供指定執行緒數量的執行緒池
        ExecutorService service = Executors.newFixedThreadPool(10);
        ThreadPoolExecutor service1 = (ThreadPoolExecutor) service;

        // 設置執行緒池的屬性
//        System.out.println(service.getClass());
        service1.setCorePoolSize(15);
//        service1.setKeepAliveTime();

        // 2. 執行指定的執行緒的操作 需要提供實現Runnable接口或Callable接口實現類的對象
        service.execute(new NumberThread()); // 適合Runnable
//        service.submit(); // 適合Callable

        service.execute(new NumberThread1());

        // 3. 關閉執行緒池
        service.shutdown();

    }
}

class NumberThread implements Runnable{

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            if ( i % 2 == 0){
                System.out.println(Thread.currentThread().getName() + ":" + i);
            }
        }
    }
}

class NumberThread1 implements Runnable{

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            if ( i % 2 != 0){
                System.out.println(Thread.currentThread().getName() + ":" + i);
            }
        }
    }
}
```



#### 多執行緒-問題

java如何解決執行緒安全問題 有幾種方式

- 同步程式區塊
- 同步方法
- Lock鎖



synchronized與Lock的異同

- 相同
  - 兩者都可以解決執行緒安全問題
- 不能
  - synchronized機制在執行完相應的同步程式碼後 自動的釋放同步監視器
  - Lock需要手動的啟動同步 lock()  同時結束同步也需要手動的實現 unlock()

執行緒通訊涉及的三個方法

- wait() 
  - 執行後 當前執行緒進入阻塞狀態 並釋放同步監視器
- notify() 
  - 執行後 就會喚醒被wait的一個執行緒 如果有多個執行緒被wait 則喚醒優先度最高的
- notifyAll() 
  - 執行後 就會喚醒所有被wait的執行緒

sleep()和wait()的異同

- 相同點
  - 一旦執行方法 就可以使當前的執行緒進入阻塞狀態
- 不同點
  - 兩個方法聲明的位置不同 
    - Thread類中聲明sleep() 
    - Object類中聲明wait()
  - 調用的要求不同
    - sleep()可以在任何需要的地方調用
    - wait()必須使用在同步程式區塊或同步方法中
  - 關於是否是放同步監視器 如果兩個方法都使用在同步程式區塊或同步方法中
    - sleep()不會釋放鎖
    - wait()會釋放鎖

不會釋放鎖的操作

- Thread.sleep() 暫停執行緒的執行
- Thread.yield() 暫停執行緒的執行
- suspend()將執行緒掛起 該執行緒不會釋放鎖(同步監視器)
  - 應盡量避免使用suspend() 和 resume()



# 常用類



#### String

- String類 : 表示字串
  - 所有字串字面值 如 "abc" 都作為此類的實例實現
- String是一個final類 代表不可變的字串序列
- 字串是常數 用" "表示 他們的值在創建之後不能更改
- String對象的字串內容是儲存在一個字串陣列value[]中的

```java
public class StringTest {
    /*
        String 字串 使用一對""引用起來
        1. String聲明為final的 不可被繼承
        2. String實現了Serializable接口 : 表示字串是支持序列化的
                 實現了Comparable接口 : 表示String可以比較大小
        3. String內部定義了final char[] value 用於儲存字串數據
        4. String代表不可變的字元序列 : 不可變性
            4.1 當對字串重新賦值時 需要重寫指定記憶體區域賦值 不能使用原有的value進行賦值
            4.2 當對現有的字串進行連接操作時 也需要重新指定記憶體區域賦值 不能使用原有的value進行賦值
            4.3 當調用String的replace()方法修改指定字元或字串時 也需要重新指定記憶體區域賦值
        5. 通過字面量(存在於方法區)的方式(區別於new) 給一個字串賦值
            此時的字串值聲明在字串常數池中
        6. 字串常數池中 不會儲存相同內容的字串
     */
    @Test
    public void test1(){
        String s1 = "abc";
        String s2 = "abc";
        s1 = "hello";

        System.out.println(s1 == s2); // 比較地址
        System.out.println(s1); // hello
        System.out.println(s2); // abc

        System.out.println("=======================");

        String s3 = "abc";
        s3 += "def";
        System.out.println(s3); // abcdef

        String s4 = "abc";
        String s5 = s4.replace('a','m');

        System.out.println(s4); // abc
        System.out.println(s5); // mbc
    }
}
```



#### String對象創建

- 實例化方式:
- 通過字面量定義的方式
- 通過 new + 建構器的方式

- String s = new String("abc") 方式創建對象 在記憶體中創建了幾個對象
  - 兩個 : 一個是Heap空間中new結構  一個是char[]對應的常數池中的數據 : "abc"

```java
@Test
public void test2(){
    // 通過字面量定義的方式 : 此時的s1和s2的數據javaEE聲明在方法區中的字串常數池中
    String s1 = "javaEE";
    String s2 = "javaEE";
    // 通過new + 建構器的方式 : 此時的s3和s4保存地址值 是數據在Heap空間中開闢空間以後對應的地址值
    String s3 = new String("javaEE");
    String s4 = new String("javaEE");

    System.out.println(s1 == s2); // true
    System.out.println(s1 == s3); // false
    System.out.println(s1 == s4); // false
    System.out.println(s3 == s4); // false

    System.out.println("==========================");
    Person p1 = new Person("Tom",12);
    Person p2 = new Person("Tom",12);

    System.out.println(p1.name.equals(p2.name)); // true
    System.out.println(p1.name == p2.name); // true

    p1.name = "Jerry";
    System.out.println(p2.name); // Tom
    System.out.println(p1.name == p2.name); // false
}
```



拼接

```java
/*
    常數與常數的拼接結果在常數池 且常數池中不會存在相同內容的常數
    只要其中一個是變數 結果就在Heap中
    拼接的結果調用intern()方法  返回值就在常數池中
 */
@Test
public void test3(){
    String s1 = "javaEE";
    String s2 = "hadoop";

    String s3 = "javaEEhadoop";
    String s4 = "javaEE" + "hadoop";
    String s5 = s1 + "hadoop"; // 有變數名參與時 此時都不是在常數池 相當於new
    String s6 = "javaEE" + s2;
    String s7 = s1 + s2;

    System.out.println(s3 == s4); // true
    System.out.println(s3 == s5); // false
    System.out.println(s3 == s6); // false
    System.out.println(s5 == s7); // false
    System.out.println(s5 == s6); // false
    System.out.println(s5 == s7); // false
    System.out.println(s6 == s7); // false

    String s8 = s6.intern(); // 返回得到的s8 使用的是常量池中已經存在的javaEEhadoop
    System.out.println(s8); // javaEEhadoop
    System.out.println(s3 == s8); // true

}
```



#### String常用方法

- int length()
- char charAt(int index)
- boolean isEmpty()
- String toLowerCase()
- String trim()

```java
@Test
public void test1(){
    String s1 = "HelloWorld";
    System.out.println(s1.length()); // 返回字串長度
    System.out.println(s1.charAt(0)); // 返回index的字元
    System.out.println(s1.charAt(9));

    System.out.println(s1.isEmpty()); // 判斷是否為空 返回true

    String s2 = s1.toLowerCase(); // 轉成小寫
    System.out.println(s1); // s1不可變 仍為原來的字串
    System.out.println(s2); // 改成小寫的字串

    String s3 = "  he  llo   world";
    String s4 = s3.trim();  // 去除首尾的空格
    System.out.println("-----" + s3 + "-----");
    System.out.println("-----" + s4 + "-----");

}
```



- boolean equalsIgnoreCase()
- String concat()
- int compareTo()
- String substring()

```java
@Test
public void test2(){
    String s1 = "HelloWorld";
    String s2 = "helloworld";
    System.out.println(s1.equals(s2)); // false
    System.out.println(s1.equalsIgnoreCase(s2)); // true 比較時忽略大小寫

    String s3 = "abc";
    String s4 = s3.concat("def");
    System.out.println(s4); // abcdef

    String s5 = "abc";
    String s6 = new String("abc");
    System.out.println(s5.compareTo(s6)); // 涉及到字串排序

    String s7 = "ABCDEFG";
    String s8 = s7.substring(3); // 返回新的字串 從beginIndex開始擷取到最後一個字元
    System.out.println(s7);
    System.out.println(s8); // DEFG

    // 返回新的字串 從beginIndex開始擷取到endIndex(不包含)的一個子字串
    String s9 = s7.substring(3,6);
    System.out.println(s9); // DEF
}
```



- endsWith(String suffix) : 測試此字串是否已指定的後綴結束
- startsWith(String prefix) : 測試此字串是否以指定的前綴開始
- startsWith(String prefix,int toffset) : 測試此字串從指定索引開始的子字串是否相等

- contains(CharSequence s) : 當此字串包含指定的char序列時 返回true



- indexOf(String str) : 返回指定子字串在此字串中第一次出現處的index
- indexOf(String str, int fromIndex) : 返回指定子字串在此字串第一次出現處的index
- lastIndexOf(String str) : 返回指定子字串在此字串中最右邊出現處的index
- lastIndexOf(String str, int fromIndex) : 返回指定子字串在此字串中最後一次出現處的index

上述中 indexOf 和 lastIndexOf 方法如果未找到都是返回-1



```java
@Test
public void test3(){
    String str1 = "helloworld";
    boolean b1 = str1.endsWith("rld");
    System.out.println(b1); // true

    boolean b2 = str1.startsWith("He");
    System.out.println(b2); // false

    boolean b3 = str1.startsWith("ll",2);
    System.out.println(b3); // true

    String str2 = "wor";
    System.out.println(str1.contains(str2)); // true  判斷是否包含str2

    System.out.println(str1.indexOf("lo")); // 3

    System.out.println(str1.indexOf("lol")); // -1

    // 從index = 5 開始找尋
    System.out.println(str1.indexOf("lo",5)); // -1

    String str3 = "helloworld";

    System.out.println(str3.lastIndexOf("or"));
    System.out.println(str3.lastIndexOf("or",2)); // 從開始的index向左找
}
```



- replace(char oldChar,char newChar)
  - 返回一個新的字串 他是通過用newChar替換此字串出現的所有oldChar得到的
- replace(CharSequence target,CharSequence replacement)
  - 使用指定的字面值 替換序列中此字串所有匹配字面值目標的子字串
- replaceAll(String regex, String replacement)
  - 使用給定的replacement替換此字串所有匹配給定的正則表達式的子字串
- replaceFirst(String regex,String replacement)
  - 使用給定的replacement替換此字串匹配給定的正則表達式的第一個子字串



- matches(String regex)
  - 告知此字串是否匹配給定的正則表達式
- String[] split(String regex)
  - 根據給定的正則表達式的匹配拆分此字串
- String[] split(String regex, int limit)
  - 根據匹配給定的正則表達式來拆分此字串 最多不超過limit個 如果超過了 剩下的全部放到最後一個元素中

```java
@Test
public void test4(){
    String str1 = "Hello world Hello world";
    String replace = str1.replace("Hello", "No");
    System.out.println(str1); // 不改變str1的值
    System.out.println(replace);

    String str2 = "12hello34world56java789mysql1234";
    // 將字串中的數字替換成 , 如果開頭跟結尾有 , 的話移除
    String newstr = str2.replaceAll("\\d+", ",").replaceAll("^,|,$","");
    System.out.println(newstr);

    String str3 = "12345";
    // 判斷字串中是否全部由數字組成
    boolean matches = str3.matches("\\d+");
    System.out.println(matches);

    String tel = "0987654321";
    // 判斷這是一個以 xx 開頭的電話
    boolean result = tel.matches("09\\d{7,8}");
    System.out.println(result);

}
```



#### String數據類型轉換

- Integer <----> String
  - Integer ----> String   : valueOf() 
  - String   ----> Integer : Integer.parseInt()

```java
@Test
    public void  test1(){
        String str1 = "123";
//        int num = (int)str1; // 錯誤
        int num = Integer.parseInt(str1);

        String str2 = String.valueOf(num); // "123"
        String str3 = num + "";

        System.out.println(str1 == str3); // false

    }
```

- String  <----> char[]
  - String --> char[] : 調用String的toCharArray()
  - char[] --> String : 調用String的建構器

```java
/*
    String --> char[] : 調用String的toCharArray()
    char[] --> String : 調用String的建構器
 */
@Test
public void test2(){
    String str1 = "abc123";

    char[] charArray = str1.toCharArray();
    for (int i = 0; i < charArray.length; i++) {
        System.out.println(charArray[i]);
    }

    char[] arr = new char[]{'h','e','l','l','o'};
    String str2 = new String(arr);
    System.out.println(str2);
}
```

- String  <----> byte[]
  - String ---> byte[] : 調用String的getBytes()
  - byte[] --> String : 調用String的建構器

```java
/*
    String 與 byte[]的轉換
    編碼 String --> byte[] : 調用String的getByte()
    解碼 byte[] --> String : 調用String的建構器
    
    解碼時要求使用的字元集要與編碼一樣
 */
@Test
public void test3() throws UnsupportedEncodingException {
    String str1 = "abc123";
    byte[] bytes = str1.getBytes();
    System.out.println(Arrays.toString(bytes)); // [97, 98, 99, 49, 50, 51]

    byte[] gbks = str1.getBytes("gbk");
    System.out.println(gbks);

    System.out.println("-----------------------");

    String str2 = new String(bytes); // 使用預設的字元集 進行解碼
    System.out.println(str2);

    String str3 = new String(gbks);
    System.out.println(str3);

    String str4 = new String(gbks,"gbk"); // 使用gbk解碼
    System.out.println(str4);
}
```



#### String StringBuffer StringBuilder

- 三者對比
  - String : 不可變的字元序列  底層使用char[]儲存
  - StringBuffer  : 可變的字元序列 執行緒安全  效率低 底層使用char[]儲存
  - StringBuilder : 可變的字元序列 執行緒不安全 效率高 底層使用char[]儲存

- 效率對比
  - StringBuilder > StringBuffer > String

```java
    String str = new String(); // char[] value = new char[0];
    String str1 = new String("abc"); // char[] value = new char[]{'a','b','c'};

    StringBuffer sb1 = new StringBuffer(); // char[] value = new char[16]; 底層創建長度為16的陣列

    StringBuffer sb2 = new StringBuffer("abc");

    問題1. System.out.prnitln(sb2.length()); // 3
    問題2. 擴容問題:如果要添加的數據底層陣列滿了 需要擴容底層的陣列
           預設情況下 擴容為原來容量的2倍+2 同時將原有陣列中的元素複製到新的陣列中

    開發中建議使用StringBuffer(int capacity) 或 StringBuilder(int capacity)
```



相互轉換

- String --> StringBuffer StringBuilder : 調用StringBuffer StringBuilder建構器
- StringBuffer StringBuilder --> String 
  - 調用String建構器 
  - StringBuffer  StringBuilder的toString()



#### StringBuffer常用方法

- StringBuffer append(xxx)
  - 用於進行字串拼接
- StringBuffer delete(int start,int end)
  - 刪除指定位置的內容
- StringBuffer replace(int start,int end,String str)
  - 把[start,end)位置替換成str 
- StringBuffer insert(int offset,xxx)
  - 在指定位置插入xxx
- StringBuffer reverse()
  - 將當前字串序列反轉



總結

- 增 : append(xxx)
- 刪 : delete(int start,int end)
- 改 : setCharAt(int n,char ch) / replace(int start, int end ,String str)
- 查 : charAt(int n)
- 插入 : insert(int offset,xxx)
- 長度 : length()
- 遍歷 : for + charAt()

```java
@Test
   public void test2(){
       StringBuffer str1 = new StringBuffer("abc");
       str1.append(1);
       str1.append('1');
       System.out.println(str1); // abc11
//       str1.delete(2,4);  // 刪除指定位置的內容
//       str1.replace(2,4,"hello"); // 位置替換為str
       str1.insert(2,false); // 在指定位置插入xxx
       System.out.println(str1);
       str1.reverse();  // 把當前字元序列反轉
       System.out.println(str1);
       str1.substring(2,4); // 返回從start開始到end位置的 左閉右開的子字串

   }
```



#### String練習



##### 字串反轉

```java
public class StringDemo {
    public static void main(String[] args) {
        String aaa = reverse("abcdefg", 2, 5);
        System.out.println(aaa);

        String bbb = reverse2("abcdefg", 2, 5);
        System.out.println(bbb);

        String ccc = reverse3("abcdefg", 2, 5);
        System.out.println(ccc);
    }
    /*
        將字串進行反轉 將字串中指定部分進行反轉 abcdefg --> abfedcg

        方式一 : 轉換為char[]

     */
    @Test
    public static String reverse(String str,int startIndex,int endIndex){

        if (str != null && str.length() != 0){
            char[] arr = str.toCharArray();
            for (int x = startIndex,y = endIndex; x < y; x++,y--) {
                char temp = arr[x];
                arr[x] = arr[y];
                arr[y] = temp;
            }
            return new String(arr);
        }
        return null;
    }

    // 方式二 使用String拼接  由於每次拼接String都會新建立String 效率較差
    @Test
    public static String reverse2(String str,int startIndex,int endIndex){
        if (str != null){
            // 第一部分
            String reverseStr = str.substring(0,startIndex); // [0,index)
            // 第二部分
            for (int i = endIndex;i >= startIndex ;i--){
                reverseStr += str.charAt(i);
            }
            // 第三部分
            reverseStr += str.substring(endIndex + 1);
            return reverseStr;
        }
        return null;
    }

    // 方式三 使用StringBuffer StringBuilder 替換 String
    public static String reverse3(String str,int startIndex,int endIndex){
        if (str != null){
            StringBuilder builder = new StringBuilder(str.length());
            // 第一部分
            builder.append(str.substring(0, startIndex));
            // 第二部分
            for (int i = endIndex; i >= startIndex ; i--) {
                builder.append(str.charAt(i));
            }
            // 第三部分
            builder.append(str.substring(endIndex + 1));

            return builder.toString();
        }
        return null;
    }
}
```



##### 字串出現次數

```java
/*
        獲取字串在另一個字串中出現的次數
            例如 獲取 ab 在 "abksdjkdskogablnasab" 中出現的次數
     */
    public int getCount(String main,String sub){
        int mainLength = main.length();
        int subLength = sub.length();
        int index = 0;
        int count = 0;
        if (mainLength >= subLength){
            while ( (index = main.indexOf(sub,index)) != -1) {
                ++count;
                index += subLength; // 更新index
            }
            return count;
        }else {
            return 0;
        }
    }
```



##### 最大相同子串

```java
/*
    獲取兩個字串中最大相同子串
    str1 = "abcwerthelloyuiodef str2 = "cvhellobnm"
    說明 : 將短的字串進行長度依次遞減 與較長的串比較
 */
// 兩個字串中 只有一個最大長度相同的子串
public String getMaxSameString(String str1,String str2){
    String maxStr = (str1.length() >= str2.length()) ? str1 : str2;
    String minStr = (str1.length() < str2.length()) ? str1 : str2;
    int length = minStr.length();
    for (int i = 0; i < minStr.length(); i++) { // 總共比較length()次 從length ~ length - (length - 1)的長度

        for (int x = 0,y = length - i; y < length;x++,y++ ){
            String subStr = minStr.substring(x,y);

            if (maxStr.contains(subStr)){
                return subStr;
            }
        }
    }
    return null;
}
```



尋找多個子串

```java
@Test
public String[] getMaxSameString2(String str1,String str2){
    if (str1 != null && str2 != null){
        StringBuffer sBuffer = new StringBuffer();
        String maxStr = (str1.length() >= str2.length()) ? str1 : str2;
        String minStr = (str1.length() < str2.length()) ? str1 : str2;

        int length = minStr.length();
        for (int i = 0; i < minStr.length(); i++) { // 總共比較length()次 從length ~ length - (length - 1)的長度
            for (int x = 0,y = length - i; y < length;x++,y++ ){
                String subStr = minStr.substring(x,y);

                if (maxStr.contains(subStr)){
                    sBuffer.append(subStr + ",");
                }
            }
            if (sBuffer.length() != 0){
                break;
            }
        }
        String[] split = sBuffer.toString().replaceAll(",$","").split("\\,");
        return split;
    }
    return null;
}
```



#### JDK8之前的日期時間API

- System類中currentTimeMillis()
- java.util.Date和子類java.sql.Date
- SimpleDateFormat
- Calendar



獲取系統當前時間 : System類的currentTimeMillis()

```java
@Test
public void test1(){
    long time = System.currentTimeMillis();
    System.out.println(time); // 1246184740385
}
```



java.util.Date類 和  java.sql.Date類

```java
/*
        java.util.Data類
            java.sql.Date類
        1. 兩個建構器的使用
        2. 兩個方法的使用
            toString() : 顯示當前年 月 日 時 分 秒
            getTime() : 獲取當前Date對象的毫秒數 (時間戳)
        3. java.sql.Date : 對應著資料庫中的日期類型的變數
            如何實例化
     */

    @Test
    public void test2(){
        // 建構器一 : Date() : 創建一個對應當前時間的Date對象
        Date date1 = new Date();
        System.out.println(date1);
        System.out.println(date1.toString()); // 當前時間
        System.out.println(date1.getTime()); // 時間戳

        // 建構器二 : 創建指定毫秒數的Date對象
        Date date2 = new Date(1346148807222L);
        System.out.println(date2.toString()); // 將時間戳轉為當前時間

        // 創建java.sql.Date對象
        java.sql.Date date3 = new java.sql.Date(1346148807222L);
        System.out.println(date3); // 2012-08-28

        // 如何將java.util.Date對象轉換為java.sql.Date對象
        // 情況一
//        Date date4 = new java.sql.Date(1346148807222L);
//        java.sql.Date date5 = (java.sql.Date) date4;
        // 情況二
        Date date6 = new Date();
        // 放入時間戳進行sql的日期轉換
        java.sql.Date date7 = new java.sql.Date(date6.getTime()); // 2012-08-28


    }
```



SimpleDateFormat

```java
/*
        SimpleDateFormat的使用 : SimpleDateFormat對日期Date類的格式化和解析
        1. 兩個操作
            1.1 格式化 : 日期 ---> 字串
            1.2 解析 : 格式化的逆過程  字串  ---> 日期
        2. SimpleDateFormat的實例化
     */
    @Test
    public void test3() throws ParseException {
        // 實例化SimpleDateFormat
        SimpleDateFormat sdf = new SimpleDateFormat();
        // 格式化 : 日期 ---> 字串
        Date date = new Date();
//        System.out.println(date); Wed Mar 02 09:59:37 CST 2022  日期
        String format = sdf.format(date);
        System.out.println(format); // 2022/3/2 上午10:00  字串

        // 解析 : 格式化的逆過程  字串 --> 日期
//        String str = "2000-01-01";
        String str = "2022/3/2 上午10:03";
        Date parse = sdf.parse(str);
        System.out.println(parse); // java.text.ParseException: Unparseable date: "2000-01-01"

//      *****************************************************

        // 指定格式化
        SimpleDateFormat sdf2 = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
        String format2 = sdf2.format(date); // date = Wed Mar 02 09:59:37 CST 2022  日期
        System.out.println(format2); // 2022-03-02 10:09:04

        // 解析 : 要求字串必須符合SimpleDateFormat識別的格式
        Date parse1 = sdf2.parse("2020-03-02 10:09:04");
        System.out.println(parse1); // Mon Mar 02 10:09:04 CST 2020

    }
```



字串 --> 日期    使用java.sql.Date

```java
/*
        SimpleDateFormat
        練習一 : 2020-02-03 轉換為 java.sql.Date  解析 : 字串 --> 日期
     */
    @Test
    public void test4() throws ParseException {
        String str = "2020-02-03";
        // 定義格式
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
        Date date = sdf.parse(str); // parse解析
//        System.out.println(date);  Mon Feb 03 00:00:00 CST 2020
        java.sql.Date birthDate = new java.sql.Date(date.getTime());
        System.out.println(date.getTime()); // 1580659200000 通過時間戳轉換
        System.out.println(birthDate); // 2020-02-03


    }
```



計算天數

```java
/*
    SimpleDateFormat
    練習二 : 三天捕魚兩天曬網  1990-01-01
        如果挑選某一天 判斷那時的情況
        總天數 % 5 == 1 2 3 : 捕魚
        總天數 % 5 == 4 0 : 曬網
    計算總天數
    方式一 : (data2.getTime() - data1.getTime()) / (1000 * 60 * 60 * 24) + 1
    方式二 : 1990-01-01 --> 2019-12-31 + 2020-01-01 --> 2020-09-08
 */
```



#### Calendar(日曆)類

```java
/*
        Calendar 日曆類 (抽象類) 使用
     */
    @Test
    public void test5(){
        // 1.實例化
        // 方式一 : 創建其子類 (GregorianCalendar)的對象
        // 方式二 : 調用其靜態方法 getInstance()
        Calendar calendar = Calendar.getInstance();
//        System.out.println(calendar.getClass());

        // 2.常用方法
        // get()
        int days = calendar.get(Calendar.DAY_OF_MONTH); // 獲取這個月的第幾天
        System.out.println(days);
        System.out.println(calendar.get(Calendar.DAY_OF_YEAR)); // 獲取這一年的第幾天

        // set()
        calendar.set(Calendar.DAY_OF_MONTH,4);
        days = calendar.get(Calendar.DAY_OF_MONTH);
        System.out.println(days); // 4

        // add()
        calendar.add(Calendar.DAY_OF_MONTH,3);
        days = calendar.get(Calendar.DAY_OF_MONTH);
        System.out.println(days); // 4 + 3 = 7

        // getTime() : 日曆類 --> Date
        Date date = calendar.getTime(); // 更改過後的時間 (4 + 3)
        System.out.println(date); // Mon Mar 07 11:25:44 CST 2022

        // setTime() : Date --> 日曆類
        Date date1 = new Date(); // 獲取當前時間
        calendar.setTime(date1); // 重新設置
        days = calendar.get(Calendar.DAY_OF_MONTH);
        System.out.println(days); // 2

    }
```



#### JDK8中新日期時間API

Calendar類和Date面臨的問題

- 可變性 : 日期和時間的類應該是不可變的
- 偏移性 : Date中的年份從1900開始 月份從0開始  也就是需要 -1900  +1 
- 格式化 : 格式化只對Date有用  Calendar則不行
- 他們都不是執行緒安全的 不能處理閏秒



新時間日期API

- java.time : 包含值對象的基礎包
- java.time.chrono : 提供對不同的日曆系統的訪問
- java.time.format : 格式化和解析時間和日期
- java.time.temporal : 包括底層框架和擴展特性
- java.time.zone : 包含時區支持的類



 LocalDate LocalTime LocalDateTime 的使用

```java
/*
    LocalDate LocalTime LocalDateTime 的使用
        1. LocalDateTime 相較於 LocalDate LocalTime 使用頻率較高
 */
@Test
public void test1(){
    // now() : 獲取當前的日期 時間  時間+日期
    LocalDate localDate = LocalDate.now();
    LocalTime localTime = LocalTime.now();
    LocalDateTime localDateTime = LocalDateTime.now();
    System.out.println(localDate); // 2022-03-02
    System.out.println(localTime); // 12:05:21.854144800
    System.out.println(localDateTime); // 2022-03-02T12:05:21.854144800

    // of() : 設置指定的 年 月 日 時 分 秒  沒有偏移量
    LocalDateTime localDateTime1 = LocalDateTime.of(2020, 2, 3,4,5,6);
    System.out.println(localDateTime1); // 2020-02-03T04:05:06

    //getXxx() : 獲取相關的屬性
    System.out.println(localDateTime); // 2022-03-02T12:10:31.956186500
    System.out.println(localDateTime.getDayOfMonth()); // 2
    System.out.println(localDateTime.getDayOfWeek()); // WEDNESDAY
    System.out.println(localDateTime.getMonth()); // MARCH
    System.out.println(localDateTime.getMonthValue()); // 3
    System.out.println(localDateTime.getMinute()); // 10

    // 體現不可變性  設置新的返回值 而不是修改傳入值
    // withXxx() : 設置相關的屬性
    LocalDate localDate1 = localDate.withDayOfMonth(22);
    System.out.println(localDate); // 2022-03-02
    System.out.println(localDate1); // 2022-03-22

    // 不可變性
    LocalDateTime localDateTime2 = localDateTime.plusMonths(3);
    System.out.println(localDateTime); // 2022-03-02T12:16:31.373354700
    System.out.println(localDateTime2); // 2022-06-02T12:16:31.373354700

    //
    LocalDateTime localDateTime3 = localDateTime.minusDays(6);
    System.out.println(localDateTime); // 2022-03-02T12:17:07.886517
    System.out.println(localDateTime3); // 2022-02-24T12:17:07.886517

}
```



Instant的使用

```java
/*
    Instant的使用
    類似於java.util.Date類
 */
@Test
public void test2(){
    // now() : 獲取本初子午線對應的標準時間
    Instant instant = Instant.now();
    System.out.println(instant); // 2022-03-02T04:32:28.189524800Z

    // 添加時間的偏移量
    OffsetDateTime offsetDateTime = instant.atOffset(ZoneOffset.ofHours(8));
    System.out.println(offsetDateTime); // 2022-03-02T12:32:28.189524800+08:00

    // 獲取自1970年 1月1日0分0秒 開始的毫秒數 --> Date類的getTime()
    long milli = instant.toEpochMilli();
    System.out.println(milli); // 1646195548189

    // ofEpochMilli() : 通過給予的毫秒數 獲取Instant實例 --> Date(long millis)
    Instant instant1 = Instant.ofEpochMilli(1646195548189L);
    System.out.println(instant1); // 2022-03-02T04:32:28.189Z

}
```



485



#### Java比較器

Comparable與Comparator比較

- Comparable的方式 一旦指定 保證Comparable實現類的對象在任何位置都可以比較大小
- Comparator屬於臨時性的比較



##### 自然排序Comparable

java.lang.Comparable

- Comparable接口強行對實現他的類的對象進行整體排序 這種排序為類的自然排序
- 實現Comparable的類必須實現compareTo(Object obj)方法 通過compareTo(Object obj)方法的返回值比較大小

```java
/*
    Comparable接口的使用舉例 : 自然排序
    1.String 包裝類等實現了Comparable接口 重寫了compareTo(obj)方法 給出了比較兩個對象的依據
    2.String 包裝類重寫了compareTo()方法後 進行了從小到大的排序
    3.重寫compareTo(obj)的規則
        如果當前對象this大於參數對象obj 返回正整數
        如果當前對象this小於參數對象obj 返回負整數
        如果當前對象this等於參數對象obj 返回0
    4.對於自定義類來說 如果需要排序 我們可以讓自定義類實現Comparable接口 重寫compareTo(obj)方法
      在compareTo(obj)方法中指名如何排序
 */
@Test
public void test1(){
    String[] arr = new String[]{"AA","CC","KK","MM","EE","II","ZZ"};

    Arrays.sort(arr);

    System.out.println(Arrays.toString(arr));
}
```



比較類中的屬性

- 實作Comparable 重寫compareTo

```java
// 指名商品比較大小的方式 : 價格從低到高排序 , 再依照產品名稱從低到高排序
    @Override
    public int compareTo(Object o) {
        if (o instanceof ABC){
            ABC abc = (ABC) o;
            // 方式一
            if (this.price > abc.price){
                return 1;
            }else if (this.price < abc.price){
                return -1;
            }else {
//                return 0;
                return this.name.compareTo(abc.name);
            }
            // 方式二
//            return Double.compare(this.price,abc.price);
        }
        throw new RuntimeException("傳入的數據類型不一致");
    }
```

- 進行比較

```java
@Test
public void test2(){
    ABC[] arr = new ABC[5];
    arr[0] = new ABC("CCC",60);
    arr[1] = new ABC("BBB",40);
    arr[2] = new ABC("HHH",90);
    arr[3] = new ABC("EEE",20);
    arr[4] = new ABC("ZZZ",40);

    Arrays.sort(arr);

    System.out.println(Arrays.toString(arr));

}
```





##### 定制排序Comparator

java.util.Comparator

- 當元素的類型沒有實現java.lang.Comparable接口而又不方便修改程式碼
  - 或是實現了java.lang.Comparable接口的排序規則不適合當前的操作 可以使用Comparator的對象來排序
- 重寫compare(Object o1,Object o2)方法 比較o1和o2的大小
  - 如果返回正整數 表示o1大於o2
  - 如果返回0 表示相等
  - 如果返回負整數 表示o1小於o2



```java
/*
    Comparator接口的使用 : 定制排序
 */
@Test
public void test3(){
    String[] arr = new String[]{"AA","CC","KK","MM","EE","II","ZZ"};
    Arrays.sort(arr, new Comparator<String>() {
        // 依照字串從大到小的排序
        @Override
        public int compare(String o1, String o2) {
            if (o1 instanceof String && o2 instanceof String){
                // 強制轉型
                String s1 = (String) o1;
                String s2 = (String) o2;
                return -s1.compareTo(s2);
            }
            throw new RuntimeException("輸入的數據類型不一致");
        }
    });
    System.out.println(Arrays.toString(arr));
}
```



```java
@Test
public void test4(){
    ABC[] arr = new ABC[6];
    arr[0] = new ABC("CCC",60);
    arr[1] = new ABC("BBB",40);
    arr[2] = new ABC("HHH",90);
    arr[3] = new ABC("EEE",20);
    arr[4] = new ABC("ZZZ",40);
    arr[5] = new ABC("HHH",40);

    Arrays.sort(arr, new Comparator<ABC>() {
        // 指名商品比較大小的方式 :產品名稱從低到高排序 , 再依照價格從高到低排序
        @Override
        public int compare(ABC o1, ABC o2) {
            // 判斷產品名是否相等
            if (o1.getName().equals(o2.getName())){
                // 相等 比較價格
                return -Double.compare(o1.getPrice(),o2.getPrice());
            }else {
                // 不相等 比較名稱
                return o1.getName().compareTo(o2.getName());
            }
        }
    });
    System.out.println(Arrays.toString(arr));
}
```



#### System類

- 建構器是private的  無法創建該類的對象
- 內部的成員變數和方法都是static 可以直接調用
- 成員變數包含
  - in :  標準輸入流 (鍵盤輸入)
  - out : 標準輸出流 (顯示器)
  - err : 標準錯誤輸出流 (顯示器)
- 成員方法
  - native long currentTimeMillis()
    - 返回當前電腦的時間  返回時間戳的毫秒數
  - void exit(int status)
    - 退出程式
    - status的值為0代表正常退出  非0代表異常退出
  - void gc()
    - 請求系統進行垃圾回收  至於系統是否立刻回收 取決於系統中垃圾回收算法的實現和系統執行時的情況
  - String getProperty(String key)
    - 獲得系統中屬性名為key的屬性對應的值 



#### Math類

``````java
abs 絕對值
acos,asin,atan,cos,sin,tan 三角函數
sqrt 平方根
pow(double a,double b) a的b次冪
log 自然對數
exp e為底的指數
max(double a,double b)
min(double a,double b)
random() 返回0.0~1.0的隨機數
long round(double a) double型數據a轉換為long型
toDegrees(double angrad) 弧度 --> 角度
toRadians(double angdeg) 角度 --> 弧度
``````



#### 常用類-問題

解釋編碼 解碼  日期時間的格式化 解析

- 編碼 : 字串 --> byte
- 解碼 : byte --> 字串
- 格式化 : 日期 --> 字串
- 解析 : 字串 --> 日期



JDK日期 時間相關的類

- java.util.Date 和 java.sql.Date --> Instant
- SimpleDateFormat --> DateTimeFormatter
- Calendar --> LocalDate  LocalTime  LocalDateTime





# 枚舉類



#### 枚舉類定義

- 當類中的對象是有限個 確定個數時 稱為枚舉類
  - 星期 : 星期一 ~ 星期天
  - 季節 : 春天 ~ 冬天
- 當需要定義一組常數時 建議使用枚舉類





#### 如何自定義枚舉類

```java
public class SeasonTest {
    public static void main(String[] args) {
        Season spring = Season.SPRING;
        System.out.println(spring);
    }
}
// 自定義枚舉類
class Season{
    // 聲明Season對象的屬性:private final修飾
    private final String seasonName;
    private final String seasonDesc;


    // 私有化類的建構器
    private Season(String seasonName,String seasonDesc){
        this.seasonName = seasonName;
        this.seasonDesc = seasonDesc;
    }

    // 提供當前枚舉類的多個對象 : public static final
    public static final Season SPRING = new Season("春天","spring");
    public static final Season SUMMER = new Season("夏天","summer");
    public static final Season AUTUMN = new Season("秋天","autumn");
    public static final Season WINTER = new Season("冬天","winter");

    // 其他 : 獲取枚舉類對象的屬性

    public String getSeasonName() {
        return seasonName;
    }

    public String getSeasonDesc() {
        return seasonDesc;
    }

    // 提供toString()

    @Override
    public String toString() {
        return "Season{" +
                "seasonName='" + seasonName + '\'' +
                ", seasonDesc='" + seasonDesc + '\'' +
                '}';
    }
}
```



#### 如何使用關鍵字enum定義枚舉類

- 定義的枚舉類預設繼承於class java.lang.Enum類
- 使用enum關鍵字  常數刪去重複的部分

```java
/*
     使用enum關鍵字定義枚舉類
     定義的枚舉類預設繼承於class java.lang.Enum類
 */
public class SeasonTest02 {
    public static void main(String[] args) {
        Season1 summer = Season1.SUMMER;
        System.out.println(summer);
        System.out.println(Season1.class.getSuperclass());
    }
}
// 使用enum關鍵字
enum Season1 {
    // 提供當前枚舉類的多個對象 : public static final --> 刪去重複的部分
    // 提供當前枚舉類的對象 多個對象間用 , 隔開 末尾對象使用 ; 結束
    SPRING("春天","spring"),
    SUMMER("夏天","summer"),
    AUTUMN("秋天","autumn"),
    WINTER("冬天","winter");


    // 聲明Season對象的屬性:private final修飾
    private final String seasonName;
    private final String seasonDesc;


    // 私有化類的建構器
    private Season1(String seasonName, String seasonDesc){
        this.seasonName = seasonName;
        this.seasonDesc = seasonDesc;
    }


    // 其他 : 獲取枚舉類對象的屬性

    public String getSeasonName() {
        return seasonName;
    }

    public String getSeasonDesc() {
        return seasonDesc;
    }
}
```



#### Enum類的主要方法

- values()方法
  - 返回枚舉類型的對象陣列 該方法可以很方便的遍歷所有的枚舉值
- valueOf(String str)
  - 可以把一個字串轉為對應的枚舉類對象 要求字串必須是枚舉類對象的名字 
  - 如果沒有找到str的枚舉類對象 則拋異常 : IllegalArgumentException
- toString()
  - 返回當前枚舉類常數的名稱

```java
public class SeasonTest02 {
    public static void main(String[] args) {
        Season1 summer = Season1.SUMMER;
        // toString()
        System.out.println(summer.toString());
        // values()
        Season1[] values = Season1.values();
        for (Season1 value : values) {
            System.out.println(value);
        }
        // valueOf(String objName) : 返回枚舉類中對象名是objName的對象
        // 如果沒有找到objName的枚舉類對象 則拋異常 : IllegalArgumentException
        Season1 winter = Season1.valueOf("WINTER");
        System.out.println(winter);
    }
}
```



#### 實現接口的枚舉類

```java
/*
    使用enum關鍵字定義的枚舉類實現接口的情況
        情況一 : 實現接口 在enum類中實現抽象方法
        情況二 : 讓枚舉類的對象分別實現接口中的抽象方法
 */
interface Info{
    void show();
}

// 使用enum關鍵字
enum Season1 implements Info{
    // 提供當前枚舉類的多個對象 : public static final --> 刪去重複的部分
    // 提供當前枚舉類的對象 多個對象間用 , 隔開 末尾對象使用 ; 結束
    SPRING("春天","spring"){
        @Override
        public void show() {
            System.out.println("春天重寫方法");
        }
    },
    SUMMER("夏天","summer"){
        @Override
        public void show() {
            System.out.println("夏天重寫方法");
        }
    },
    AUTUMN("秋天","autumn"){
        @Override
        public void show() {
            System.out.println("秋天重寫方法");
        }
    },
    WINTER("冬天","winter"){
        @Override
        public void show() {
            System.out.println("冬天重寫方法");
        }
    };
}
```



# 註解



#### 註解(Annotation)概述

- Annotation是程式碼裡的特殊標記 這些標記可以在編譯 類加載 運行時被讀取 並執行相應的處理
- 通過使用Annotation 可以再不改變原有邏輯的情況下 在源文件中嵌入一些補充訊息 程式分析工具 開發工作 部署工具等可以通過這些補充訊息進行驗證或進行部署
- Annotation可以像修飾符一樣被使用 可用於修飾包 類 建構器 方法 成員變數 參數 局部變數的聲明 這些訊息被保存在Annotation的"name=value"對中



#### 常見的Annotation



#### 自定義Annotation



#### JDK中的元註解



#### 利用反射獲取註解訊息



#### JDK8註解的新特性



# 集合



## 集合與陣列

#### 集合與陣列儲存數據概述

- 集合 陣列都是對多個數據進行儲存操作的結構 簡稱Java容器
- 此時的儲存 主要指的是記憶體層面的儲存 不涉及到持久化的儲存 (.txt .jpg .avi 資料庫中)



#### 陣列儲存的特點

- 一旦初始化以後 其長度就確定了
- 陣列一旦定義好 其元素的類型也就確定了 我們也就只能操作指定類型的數據



#### 陣列儲存的弊端

- 一旦初始化後 長度就不可修改
- 陣列中提供的方法非常有限 對於添加 刪除 插入數據等操作 非常不便 同時效率不高
- 獲取陣列中實際源入的個數的需求 陣列沒有現成的屬性或方法可用
- 陣列儲存數據的特點 序 可重複 對於無序 不可重複的需求不能滿足



#### 集合儲存的優點

- 解決陣列儲存數據方面的弊端



## Collection接口

#### 單列集合框架結構

``````
Collection接口 : 單列集合 用來儲存一個一個的對象
	List接口 : 儲存有序的 可重複的數據  --> 動態陣列
		ArrayList,LinkedList,Vector
	Set接口 : 儲存無序的 不可重複的數據  --> 集合
		HashSet,LinkedHashSet,TreeSet
``````



#### Collection接口常用方法

```java
boolean contains(Object obj) 判斷當前集合中是否包含obj
boolean containAll(Collection coll) : 判斷形參coll中的所有元素是否都存在於當前集合中
boolean remove(Object obj) : 從當前集合中移除obj元素
boolean removeAll(Collection coll) : 差集 從當前集合中移除coll中所有的元素
boolean retainAll(Collection coll) : 交集 獲取當前集合和coll集合的交集 並返回給當前集合
```



- Collection接口的實現類會重寫obj所在類的equals()方法 包含String 但不包含引入的class
- contain() : 判斷形參中的所有元素是否都存在於當前集合

```java
/*
    Collection接口中聲明的方法的測試
    向Collection接口的實現類的對象中添加數據obj時 要求obj所在類要重寫equals()
 */
public class CollectionTest {

    public static void main(String[] args) {
        Collection coll = new ArrayList();
        coll.add(123);
        coll.add(456);
        coll.add(false);
        coll.add(new String("ASDFG"));
        coll.add(2345);
        Person p = new Person("AAA",20);
        coll.add(p);
        // contains(Object obj) 判斷當前集合中是否包含obj
        // 在判斷時會調用obj對象所在類的equals()方法
        boolean contains = coll.contains(123);
        System.out.println(contains); // true
        System.out.println(coll.contains(new String("ASDFG"))); // true
        System.out.println(coll.contains(p)); // true
        System.out.println(coll.contains(new Person("AAA",20))); // false --> 重寫equals true

        // containAll(Collection coll) : 判斷形參coll1中的所有元素是否都存在於當前集合中
        Collection coll1 = Arrays.asList(123,456);
        System.out.println(coll.contains(coll1)); // true  123 456都在其中
    }

}
```

- 差集 removeAll  : 移除remove中的所有元素  可用來將兩個集合中相同的數據移除

```java
@Test
public void test2(){
    // remove(Object obj) : 從當前集合中移除obj元素
    Collection coll = new ArrayList();
    coll.add(123);
    coll.add(456);
    coll.add(false);
    coll.add(new String("ASDFG"));
    coll.add(new Person("AAA",20));

    // 利用equals比較 找尋移除的數值
    coll.remove(1234);
    System.out.println(coll);

    coll.remove(new Person("AAA",20));
    System.out.println(coll);

    // removeAll(Collection coll) : 差集 從當前集合中移除coll中所有的元素
    Collection coll1 = Arrays.asList(123,4567);
    coll.removeAll(coll1);
    System.out.println(coll);
}
```

- 交集  retainAll  : 獲取當前集合和目標集合的交集  並將結果返回給當前集合
- equals(Object obj) : 判斷相同 則返回true
  - 每一個數據的順序和元素都要相同  因為ArrayList是有序的

```java
@Test
public void test3(){
    Collection coll = new ArrayList();
    coll.add(123);
    coll.add(456);
    coll.add(false);
    coll.add(new String("ASDFG"));
    coll.add(new Person("AAA",20));
    Collection coll1 = Arrays.asList(123,456,789);
    // retainAll(Collection cloo1):交集 獲取當前集合和coll1集合的交集 並返回給當前集合
    coll.retainAll(coll1);
    System.out.println(coll);

    // equals(Object obj) 判斷相同返回true
    // 每一個元素都相同且順序相同 因為ArrayList為有序的
    Collection coll2 = Arrays.asList(123,456);
    System.out.println(coll.equals(coll2));

}
```



#### Colletction集合與陣列間的轉換

- hashCode() : 印出集合的hashCode
- toArray() : 集合 --> 陣列 
- Arrays.asList : 陣列 --> 集合
  - 使用 int 跟封裝類 Integer的區別   封裝類才能顯示正確的資料

```java
@Test
public void test4(){
    Collection coll = new ArrayList();
    coll.add(123);
    coll.add(456);
    coll.add(false);
    coll.add(new String("ASDFG"));
    coll.add(new Person("AAA",20));

    // hashCode():
    System.out.println(coll.hashCode());

    // 集合 --> 陣列 : toArray()
    Object[] objects = coll.toArray();
    for (Object object : objects) {
        System.out.println(object);
    }

    // 陣列 --> 集合
    List<String> strings = Arrays.asList(new String[]{"AA", "BB", "CC"});
    System.out.println("Arrays.asList: " + strings);
    System.out.println("Arrays.asList size: " + strings.size());

    List ints = Arrays.asList(new int[]{123, 456});
    System.out.println("Arrays.asList int: " + ints);
    System.out.println("Arrays.asList int.size: " + ints.size());

    // int 包裝類 integer 則可識別數量
    List Integer = Arrays.asList(new Integer[]{123, 456});
    System.out.println("Arrays.asList Integer: " + Integer);
    System.out.println("Arrays.asList Integer.size: " + Integer.size());

    List in = Arrays.asList(123, 456);
    System.out.println("Array.asList in: " + in);
    System.out.println("Array.asList in.size: " + in.size());

}

// iterator() : 返回Iterator接口的實例 用於遍歷集合元素
```



## Iterator接口



#### iterator概述

- Iterator對象稱為疊代器(設計模式的一種) , 主要用於遍歷Collection集合中的元素
- GOF為疊代器模式的定義為 : 提供一種方法訪問一個容器(container)對象中各個元素 而又不需暴露該對象的內部細節 疊代器模式 就是為容器而升
- Collection接口繼承了java.lang.Iterable接口  該接口有一個iterator()方法 那麼所有實現了Colleciton接口的集合類都有一個iterator()方法 用以返回一個實現了Iteractor接口的對象
- Iteractor僅用於遍歷集合 Iterator本身並不提供承裝對象的能力 如果需要創建Iteractor對象 則必須有一個疊代的集合
- 集合對象每次調用iteractor()方法都得到一個全新的疊代器對象 預設游標都在集合的第一個元素之前



#### Iterator接口遍歷集合

- 一般會將hasNext() 和 next() 兩個方法一起加入遍歷使用
- hasNext() 判斷是否還有下一個元素
- next() 將指針往下一個位置移動  同時返回集合位置上的元素

每次執行疊代器的方法都會指向第一個位置的前面coll.iterator() 不能將此方法直接丟入使用

```java
/*
       iterator() : 返回Iterator接口的實例 用於遍歷集合元素
       集合元素的遍歷操作 使用疊代器Iteractor接口
       內部的方法 : hasNext() 和 next()
 */

public class IteratorTest {

    @Test
    public void test1(){
        Collection coll = new ArrayList();
        coll.add(123);
        coll.add(456);
        coll.add(new Person("AAA",20));
        coll.add(new String("ABC"));
        coll.add(false);

        Iterator iterator = coll.iterator(); // 指向0位置

        // 方式一
//        System.out.println(iterator.next()); // 指向第一個位置 123
//        System.out.println(iterator.next()); // 指向第二個位置 456
//        System.out.println(iterator.next());
//        System.out.println(iterator.next());
//        System.out.println(iterator.next());
        // 異常  超出範圍
//        System.out.println(iterator.next());

        // 方式二 : 不建議使用
//        for (int i = 0; i < coll.size(); i++) {
//            System.out.println(iterator.next());
//        }

        // 方式三 : 推薦
        while (iterator.hasNext()){
            System.out.println(iterator.next());
        }
    }
}
```



#### iteractor接口方法

- remove()
  - iterator可以刪除集合的元素 但是是遍歷過程中通過疊代器對象的remove方法 不是集合中的remove方法
  - 如果還未調用next()或在上一次調用next方法之後已經調用了remove方法 再調用remove都會報illegalStateException
    - 也就是不能在一個位置連續remove()

```java
@Test
public void test2() {
    Collection coll = new ArrayList();
    coll.add(123);
    coll.add(456);
    coll.add(new Person("AAA", 20));
    coll.add(new String("ABC"));
    coll.add(false);

    // 刪除集合中的 ABC
    Iterator iterator = coll.iterator();
    while (iterator.hasNext()){
        Object next = iterator.next();
        // 判斷元素為 ABC 時 進行移除元素
        if("ABC".equals(next)){
            iterator.remove();
        }

    }
    // 重置位置
    iterator = coll.iterator();
    // 遍歷元素
    while (iterator.hasNext()){
        System.out.println(iterator.next());
    }

}
```



#### foreach遍歷

```java
@Test
public void test(){
    Collection coll = new ArrayList();
    coll.add(123);
    coll.add(456);
    coll.add(new Person("AAA", 20));
    coll.add(new String("ABC"));
    coll.add(false);

    // for (集合元素的類型 區域變數 : 集合對象)
    for (Object obj : coll) {
        System.out.println(obj);
    }
}
```



## Collection子接口 : List接口

```java
Collection接口 : 單列集合 用來儲存一個一個的對象
	  List接口 : 儲存有序的 可重複的數據  --> 動態陣列
		ArrayList,LinkedList,Vector
```



#### List接口概述

- 由於java中陣列用來儲存數據的侷限性 我們通常使用List替代陣列  又稱為 動態陣列
- List集合類中的元素有序 且可重複 集合中的每個元素都有其對應的順序索引
- List容器中的元素都對應一個整數型的序號記載其在容器中的位置 可以根據序號存取容器中的元素
- JDK API中List接口的實現類常用的有 : ArrayList LinkedList Vector



#### ArrayList LinkedList Vector比較

```java
Collection接口 : 單列集合 用來儲存一個一個的對象
 	  List接口 : 儲存有序的 可重複的數據  --> 動態陣列 替換原有的陣列
    	ArrayList : 作為List接口的主要實現類 : 執行緒不安全 效率高  底層使用							Object[] elementData儲存
   		LinkedList : 對於頻繁的插入 刪除操作 使用此類效率比ArrayList高 : 底層使用						 雙向鏈表儲存
   		Vector : 作為List接口的古老實現類 : 執行緒安全 效率低  底層使用Object[] 					 elementData儲存

ArrayList  LinkedList  Vector 三者的異同
相同點 : 三個類都實現了List接口 儲存數據的特點相同 : 有序的 可重複的數據
```



#### ArrayList

- ArrayList中維護了一個Object類型的陣列 elementData
- 當創建對象時 如果使用的是無參建構器 則初始elementData容量為0 (jdk7為10)
- 如果使用的是指定容量capacity的建構器 則初始elementData容量為capacity
- 當添加元素時 : 先判斷是否需要擴容 如果需要擴容 則調用grow方法  否則直接添加元素到合適位置
- 如果使用的是無參數建構器 且第一次添加 需要擴容的話  則擴容為10  如果需要再次擴容的話 則擴容elementData為1.5倍
- 如果使用的是指定容量capacity的建構器  如果需要擴容 則直接擴容elementData為1.5倍



源碼分析

```
jdk7的情況
	ArrayList list = new ArrayList()  底層創建了長度是10的Object[]陣列 elementData

	list.add(123) elementData[0] = new Integer(123);

	list.add(11)  如果此次的添加導致底層elementData陣列容量不夠 則擴充

預設情況下 擴充為原來容量的1.5倍 同時需要將原有陣列中的數據複製到新的陣列中

jdk8的情況
	ArrayList list = new ArrayList() 底層Object[] elementData初始化為{} 並沒有創建長度為10的陣列
	list.add(123)  第一次調用add()時 底層才創建了長度10的陣列 並將數據123添加到elementData[0]

後續的添加和擴充操作與jdk7相同
```



小結

- jdk7的ArrayList的創建類似於單例的餓漢式
- jdk7的ArrayList的創建類似於單例的懶漢式 延遲了陣列的創建 節省記憶體



#### LinkedList

LinkedList list = new LinkedList() 內部聲明了Node類型的first和last屬性 預設值為null

list.add(123)  將123封裝到Node中 創建Node對象

其中 Node定義為 體現了LinkedList的雙向鏈表

```java
private static class Node<E> {
        E item;
        Node<E> next;
        Node<E> prev;

        Node(Node<E> prev, E element, Node<E> next) {
            this.item = element;
            this.next = next;
            this.prev = prev;
        }
    }
```



#### Vector

```
jdk7和jdk8中通過Vector()構建器創建對象時 底層都創建了長度為10的陣列 
在擴充方面 預設擴充為原來的陣列長度的2倍
```



#### List接口常用方法

``````java
void add(int index,Object ele) 
	在index位置插入ele元素
boolean addAll(int index,Collection eles)
	從index位置開始將eles中的所有元素添加進來
Object get(int index)
	獲取指定index位置的元素
int indexOf(Object obj)
	返回obj在集合中首次出現的位置
int lastIndexOf(Object obj)
	返回obj在集合中末次出現的位置
Object remove(int index)
	移除指定index位置的元素 並返回此元素
Object set(int index,Object ele)
	設置指定index位置的元素為ele
List subList(int fromIndex,int toIndex)
	返回從fromIndex到toIndex位置的子元素
``````



```java
@Test
public void test1(){
    ArrayList list = new ArrayList();
    list.add(123);
    list.add(456);
    list.add("AA");
    list.add(new Person("ABC",10));
    list.add(789);
    System.out.println(list);

    // void add(int index,Object ele)
    // 在index位置插入ele元素
    list.add(1,"BCD");
    System.out.println(list);

    // boolean allAll(int index,Collection eles)
    // 從index位置開始將eles中的所有元素添加
    List list1 = Arrays.asList(1,2,3);
    list.addAll(list1);
    System.out.println(list.size()); // 6 + 3 = 9
    System.out.println(list);

    // Object get(int index)
    // 獲取指定index位置的元素
    System.out.println(list.get(0));
}
```



```java
@Test
public void test2(){
    ArrayList list = new ArrayList();
    list.add(123);
    list.add(456);
    list.add("AA");
    list.add(new Person("ABC",10));
    list.add(789);

    // int indexOf(Object obj)
    // 返回obj在集合中首次出現的位置
    // 如果不存在 返回-1
    int index = list.indexOf(456);
    System.out.println(index);

    // int lastIndexOf(Object obj)
    // 返回obj在當前集合中末次出現的位置
    System.out.println(list.lastIndexOf(7890));

    // Object remove(int index)
    // 移除指定index位置的元素 並返回此元素
    Object obj = list.remove(0);
    System.out.println(obj);
    System.out.println(list);

    // Object set(int index,Object ele)
    // 設置指定index位置的元素為ele
    list.set(1,"CC");
    System.out.println(list);

    // list subList(int fromIndex,int toIndex)
    // 返回從fromIndex到toIndex位置的左閉右開區間的子集合 --> index 2 3
    List list1 = list.subList(2, 4);
    System.out.println(list1);
    System.out.println(list);
}
```

- 遍歷

```java
@Test
public void test3(){
    ArrayList list = new ArrayList();
    list.add(123);
    list.add(456);
    list.add("AA");
    list.add(new Person("ABC",10));
    list.add(789);

    System.out.println("方式一");

    // Iterator疊代器方式
    Iterator iterator = list.iterator();
    while (iterator.hasNext()){
        System.out.print(iterator.next());
    }
    System.out.println();
    System.out.println("方式二");

    // 增強for循環
    for (Object o : list) {
        System.out.print(o);
    }
    System.out.println();
    System.out.println("方式三");

    // 普通for循環
    for (int i = 0; i < list.size(); i++) {
        System.out.print(list.get(i));
    }
}
```



總結 : 常用方法

- 增 : add(Object obj)
- 刪 : remove(int index)  / remove(Object obj)
- 改 : set(int index,Object ele)
- 查 : get(int index)
- 插入 : add(int index,Object ele)
- 長度 : size()
- 遍歷 
  - Iterator 疊代器方式
  - 增強for循環
  - 普通的循環



## Collection子接口 : Set接口

```
Collection接口 : 單列集合 用來儲存一個一個的對象
    Set接口 : 儲存無序的 不可重複的數據  --> 集合
        HashSet 作為set接口的主要實現類 執行緒不安全 可以儲存null值
        LinkedHashSet 作為HashSet的子類 加入Link 遍歷內部數據時 可以按照添加的順序遍歷
        			  對於頻繁的遍歷操作  LinkedHashSet效率高於HashSet
        TreeSet 可以按照添加對象的指定屬性 進行排序
        
1. Set接口中沒有額外定義新的方法 使用的都是Collection中聲明過的方法
2. 要求 : 向Set中添加的數據 其所在的類一定要重寫hashCode()和equals()
   要求 : 重寫的HashCode()和equals()盡可能保持一致性
         相等的對象必須具有相等的散列碼        
```



#### Set接口概述

- Set接口是Collection的子接口 set接口沒有提供額外的方法
- Set集合不允許包含相同的元素 如果把兩個相同的元素加入同一個Set集合中 添加操作會失敗
- Set判斷兩個對象是否相同不是使用 == 運算符 而是根據equals()方法



#### 儲存對象所在類的要求

```java
1. Set接口中沒有額外定義新的方法 使用的都是Collection中聲明過的方法
2. 要求 : 向Set中添加的數據 其所在的類一定要重寫hashCode()和equals()
   要求 : 重寫的HashCode()和equals()盡可能保持一致性
         相等的對象必須具有相等的散列碼    
```



#### 無序性 不可重複性

- 無序性
  - 不等於隨機性 每次印出數據時不會每次都隨機印出
  - 儲存的數據在底層陣列中並非按照陣列索引的順序添加 而是根據數據的hash值決定的
- 不可重複性
  - 保證添加的元素依照equals()判斷時 不能返回true 
  - 即相同的元素只能添加一個
  - 在class中沒有重寫hashCode()方法 表示兩個hashCode是不同的 所以會存在相同資料但hash值不同的數據

```java
Set : 儲存無序的 不可重複的數據
    1. 無序性 : 不等於隨機性 儲存的數據在底層陣列中並非按照陣列索引的順序添加
               而是根據數據的hash值決定的

    2. 不可重複性 : 保證添加的元素依照equals()判斷時 不能返回true
                  即相同的元素只能添加一個
```



#### HashSet

- HashSet是Set接口的典型實現 大多數時候使用Set集合時都使用這個實現類
- HashSet按Hash算法儲存集合中的元素 因此具有很好的存取 查找 刪除性能
- HashSet具有以下特點
  - 不能保證元素的排列順序
  - HashSet不是執行緒安全的
  - 集合元素可以是null
- HashSet集合判斷兩個元素相等的標準 (不可重複性)
  - 兩個對象通過HashCode()方法比較相等
  - 並且兩個對象的equals()方法返回值也相等
- 對於存放在Set容器中的對象 對應的類一定要重寫equals()和hashCode(Object obj)方法 以實現對象相等規則 
  - 即 : 相等的對象必須具有相等的散列碼



#### HashSet元素添加原理

```java
添加元素的過程 : HashSet為例
    向HashSet中添加元素 a , 首先調用元素a所在的類的hashCode()方法 計算元素a的hash值
    此hash值接著通過某種算法計算出在HashSet底層陣列中的存放位置 (即為 索引位置)
    判斷陣列此位置上是有已經有元素:
        如果此位置上沒有其他元素 則元素a添加成功  --> 情況1
        如果此位置尚有其他元素b(或以鏈表型是存在的多個元素) 則比較元素a與元素b的hash值
            如果hash值不相等 則元素a添加成功  --> 情況2
            如果hash值相等 進而需要調用元素a所在類的equals()方法
                equals()返回true , 元素a添加失敗
                equals()返回false , 元素a添加成功  --> 情況3

   對於添加成功的情況2和情況3而言 : 元素a與已經存在指定索引位置上的數據以鏈表的方式儲存
   jdk7 : 元素a放到陣列中 指向原來的元素   a-->b
   jdk8 : 原來的元素在陣列中 指向元素a     b-->a
       
   HashSet底層 : 陣列+鏈表的結構  (jdk7)
```



#### 重寫equals()方法的原則

- 在程式運行時 同一個對象多次調用hashCode()方法應該返回相同的值
- 當兩個對象的equals()方法比較返回true時 這兩個對象的hashCode()方法的返回值也應相同
- 對象中用作equals()方法比較的Field 都應該用來計算hashCode值



#### IDEA工具的hashCode()重寫

為什麼hashCode方法中會使用31這個數字

- 選擇係數時要選擇盡量大的係數 如果計算出來的hash地址越大 所謂的衝突就越少 查找起來效率也會提高 (減少衝突)
- 31只占用了5bits 相乘造成數據溢出的機率較小
- 31可以由 i * 31 == (i<<5)-1表示 現在很多的虛擬機裡面都有做相關的優化
- 31是一個質數 質數的作用是如果用一個數字來乘以這個數 最終出來的結果只能被質數本身或被乘數還有1整除 (減少衝突)



#### LinkedHashSet

- 每個數據還維護了兩個引用 記錄此數據前一個數據和後一個數據
- 優點 : 對於頻繁的遍歷操作  LinkedHashSet效率高於HashSet



#### TreeSet

- TreeSet和TreeMap採用紅黑樹的儲存結構
- 特點 : 有序 查詢速度比List快



- TreeSet : 自然排序

```java
/*
    向TreeSet中添加的數據 要求是相同類的對象
    兩種排序方式 : 自然排序(實現Comparable接口) 定制排序 (Comparator)

    自然排序中 比較兩個對象是否相同的標準是 : compareTo()返回0 不再是equals()
    定制排序中 比較兩個對象是否相同的標準是 : compare()返回0 不再是equals()
 */
    @Test
    public void test1(){

        TreeSet treeSet = new TreeSet();
        // 失敗 不同添加不同類的對象
//        treeSet.add(123);
//        treeSet.add(456);
//        treeSet.add("AA");
//        treeSet.add(new Person("ABC",10));

        // 例子一
//        treeSet.add(12);
//        treeSet.add(2);
//        treeSet.add(52);
//        treeSet.add(14);
//        treeSet.add(13);
//        Iterator iterator = treeSet.iterator();
//        // 遍歷整數時 由小到大排序
//        while (iterator.hasNext()){
//            System.out.println(iterator.next());
//        }

        // 例子二
        // 類別需要提供比較方式 實作類中的Co
        treeSet.add(new Person("AAA",10));
        treeSet.add(new Person("BBB",12));
        treeSet.add(new Person("CCC",14));
        treeSet.add(new Person("DDD",16));
        treeSet.add(new Person("EEE",18));
        treeSet.add(new Person("EEE",20));
        Iterator iterator1 = treeSet.iterator();
        while (iterator1.hasNext()){
            System.out.println(iterator1.next());
        }
}
```

- 實體類重寫方法
  - 實作Comparable

``````java
public class Person implements Comparable
    
    
    // 依照姓名從小到大排序
    // 由大到小  return -this.name.compareTo(person.name);
    @Override
    public int compareTo(Object o) {
        if (o instanceof Person){
            Person person = (Person)o;
//            return this.name.compareTo(person.name); // 單純比較name排序
            int compare = this.name.compareTo(person.name);
            // 比較是否有相同的name  有的話進行age的比較
            if(compare != 0){
                return compare;
            }else{
                return Integer.compare(this.age,person.age);
            }
        }else{
            throw new RuntimeException("輸入的類型不匹配");
        }
    }
``````



- 定制排序
  - new Comparator()

``````java
向TreeSet中添加的數據 要求是相同類的對象
    兩種排序方式 : 自然排序(實現Comparable接口) 定制排序 (Comparator)

    自然排序中 比較兩個對象是否相同的標準是 : compareTo()返回0 不再是equals()
    定制排序中 比較兩個對象是否相同的標準是 : compare()返回0 不再是equals()
    
// 定制排序 (Comparator)
    @Test
    public void test2(){
        Comparator com = new Comparator() {
            // 依照年齡從小到大排序
            @Override
            public int compare(Object o1, Object o2) {
                if(o1 instanceof Person && o2 instanceof Person){
                    Person u1 = (Person) o1;
                    Person u2 = (Person) o2;
                    return Integer.compare(u1.getAge(),u2.getAge());
                }else{
                    throw new RuntimeException("輸入的數據類型不匹配");
                }
            }
        };
        //
        TreeSet treeSet = new TreeSet(com);
        treeSet.add(new Person("AAA",10));
        treeSet.add(new Person("BBB",12));
        treeSet.add(new Person("CCC",14));
        treeSet.add(new Person("DDD",16));
        treeSet.add(new Person("EEE",18));
        treeSet.add(new Person("EEE",14));
        Iterator iterator1 = treeSet.iterator();
        while (iterator1.hasNext()){
            System.out.println(iterator1.next());
        }
    }   
``````



## 集合-問題

```
集合Collection中儲存的如果是自定義類的對象 需要自定義類重寫哪個方法 為什麼
```

- 重寫equals()方法  --> 執行contain()  remove() retainsAll() 操作時需要考慮equals()

List : equals()方法

Set  (HashSet LinkedHashSet為例)  : equals() , hashCode()

​		(TreeSet為例) : Comparable: compareTo(Object obj)

​								  Comparator: compare(Object o1,Object o2)

```
ArrayList LinkedList Vector  三者的相同點與不同點
```

- 相同點 : 實現List接口  有序 可重複
- 不同點
  - ArrayList
    - 執行緒不安全
    - 效率較Vector高
    - 擴充1.5倍
    - 只在尾部添加 經常查詢某個元素 效率較好 O(1)
    - 刪除 插入 效率較差 O(n)
  - LinkedList
    - 底層結構為Linked
    - 查詢某個元素 效率較差 O(n)
    - 刪除 插入 效率較好 O(1)
  - Vector
    - 執行緒安全
    - 效率較ArrayList低
    - 擴充2倍

```
List接口的常用方法 (增 刪 改 查 插 長度 遍歷)
```

- add(Object obj)
- remove(Object obj) / remove(int index)
- set(int index,Object obj)
- get(int index)
- add(int index, Object obj)
- size()
- 遍歷使用iterator foreach  普通的for

```
如何使用iterator遍歷 和 foreach 遍歷
```



```
Set儲存數據的特點是什麼  常見的實現類有什麼
```

- 無序性 不可重複性
- HashSet LinkedHashSet  TreeSet



## 集合-複習

```
Collection接口常見方法
```

- add(Object obj) , addAll(Collection coll) , size() , isEmpty() , clear();
- 需要重寫equals()的方法 都需要判斷裡面的元素是否存在
  - contains(Object obj) , containsAll(Collection coll) , remove(Object obj) , removeAll(Collection coll) 差集 , retainAll(Collection coll) 交集 , equals(Object obj);
- hashCode() , toArray() , iterator()

```
Colleciot集合與陣列間的轉換
```

```java
// 集合 --> 陣列 : toArray()
            Object[] objects = coll.toArray();
            for (Object object : objects) {
                System.out.println(object);
            }

            // 陣列 --> 集合
            List<String> strings = Arrays.asList(new String[]{"AA", "BB", "CC"});
            System.out.println("Arrays.asList: " + strings);
            System.out.println("Arrays.asList size: " + strings.size());

            List ints = Arrays.asList(new int[]{123, 456});
            System.out.println("Arrays.asList int: " + ints);
            System.out.println("Arrays.asList int.size: " + ints.size());
```



```
使用Collection集合儲存對象 要求對象所屬的類滿足
```

- 向Collection接口的實現類的對象中添加數據obj時 要求obj所在類要重寫equals()



```
要求
```

- 先理解選擇適合的集合類去實現數據的保存 調用其內部的相關方法
- 再理解不同的集合類底層的數據結構為何 如何實現數據的操作的 增刪改查等



``````
遍歷Collection的兩種方法
``````

- 使用疊代器iterator
- forEach
- 增強for



#### List接口-複習

```
儲存的數據特點
```

- 儲存有序的 可重複的數據

```
常用的方法
```

- 增 : add(Object obj)
- 刪 : remove(int index)  / remove(Object obj)
- 改 : set(int index,Object ele)
- 查 : get(int index)
- 插入 : add(int index,Object ele)
- 長度 : size()
- 遍歷 
  - Iterator 疊代器方式
  - 增強for循環
  - 普通的循環

```
常用實現類
```

```java
Collection接口 : 單列集合 用來儲存一個一個的對象
 	  List接口 : 儲存有序的 可重複的數據  --> 動態陣列 替換原有的陣列
    	ArrayList : 作為List接口的主要實現類 : 執行緒不安全 效率高  底層使用							Object[] elementData儲存
   		LinkedList : 對於頻繁的插入 刪除操作 使用此類效率比ArrayList高 : 底層使用						 雙向鏈表儲存
   		Vector : 作為List接口的古老實現類 : 執行緒安全 效率低  底層使用Object[] 					 elementData儲存
```



```
儲存的元素的要求
```

- 添加的對象 所在的類需要重寫equals()方法



#### Set接口-複習

```
儲存的數據特點
```

- 無序的  不可重複的
- 具體說明 以HashSet為例
  - 無序性 : 不等於隨機性 儲存的數據在底層陣列中並非按照陣列索引的順序添加
        而是根據數據的hash值決定的
  - 不可重複性 : 保證添加的元素依照equals()判斷時 不能返回true
    	即相同的元素只能添加一個

```
元素添加過程  以HashSet為例
```

```java
添加元素的過程 : HashSet為例
    向HashSet中添加元素 a , 首先調用元素a所在的類的hashCode()方法 計算元素a的hash值
    此hash值接著通過某種算法計算出在HashSet底層陣列中的存放位置 (即為 索引位置)
    判斷陣列此位置上是有已經有元素:
        如果此位置上沒有其他元素 則元素a添加成功  --> 情況1
        如果此位置尚有其他元素b(或以鏈表型是存在的多個元素) 則比較元素a與元素b的hash值
            如果hash值不相等 則元素a添加成功  --> 情況2
            如果hash值相等 進而需要調用元素a所在類的equals()方法
                equals()返回true , 元素a添加失敗
                equals()返回false , 元素a添加成功  --> 情況3

   對於添加成功的情況2和情況3而言 : 元素a與已經存在指定索引位置上的數據以鏈表的方式儲存
   jdk7 : 元素a放到陣列中 指向原來的元素   a-->b
   jdk8 : 原來的元素在陣列中 指向元素a     b-->a
       
   HashSet底層 : 陣列+鏈表的結構   (jdk7)
```



```
常用實現類
```

```
Collection接口 : 單列集合 用來儲存一個一個的對象
    Set接口 : 儲存無序的 不可重複的數據  --> 集合
        HashSet 作為set接口的主要實現類 執行緒不安全 可以儲存null值
        LinkedHashSet 作為HashSet的子類 加入Link 遍歷內部數據時 可以按照添加的順序遍歷
        			  對於頻繁的遍歷操作  LinkedHashSet效率高於HashSet
        TreeSet 可以按照添加對象的指定屬性 進行排序
```



```
儲存對象所在類的要求
```

``````java
HashSet / LinkedHashSet
1. Set(HashSet LinkedHashSet)接口中沒有額外定義新的方法 使用的都是Collection中聲明過的方法
2. 要求 : 向Set中添加的數據 其所在的類一定要重寫hashCode()和equals()
   要求 : 重寫的HashCode()和equals()盡可能保持一致性
         相等的對象必須具有相等的散列碼 
       
TreeSet
    自然排序中 比較兩個對象是否相同的標準是 : compareTo()返回0 不再是equals()
    定制排序中 比較兩個對象是否相同的標準是 : compare()返回0 不再是equals()       
``````



#### TreeSet的使用

```
向TreeSet中添加的數據 要求是相同類的對象
```



```
兩種排序方式 : 
自然排序 (實現Comparable接口)  

定制排序 (Comparator)
```



- 自然排序

  - 使Employee實現Comparable接口 並按name排序

  ```java
  public class Employee implements Comparable{
      private String name;
      private int age;
      private MyDate birthday;
  	// constructor  get set toString 
  
      @Override
      public int compareTo(Object o) {
          if(o instanceof Employee){ // 傳入的參數為Employee
              Employee e = (Employee) o;
              return this.name.compareTo(e.name);
          }
  //        return 0;
          throw new RuntimeException("傳入的數據類型不一致");
      }
  
  }
  ```

  - 為實體類定義比較的方式後 使用iterator遍歷

  ```java
  // 使用自然排序
      @Test
      public void test(){
          TreeSet treeSet = new TreeSet();
          Employee e1 = new Employee("AAA",20,new MyDate(2000,1,1));
          Employee e2 = new Employee("CCC",25,new MyDate(2002,3,10));
          Employee e3 = new Employee("DDD",30,new MyDate(2004,6,13));
          Employee e4 = new Employee("BBB",35,new MyDate(2006,9,16));
          Employee e5 = new Employee("EEE",40,new MyDate(2008,12,19));
  
          treeSet.add(e1);
          treeSet.add(e2);
          treeSet.add(e3);
          treeSet.add(e4);
          treeSet.add(e5);
  
          Iterator iterator = treeSet.iterator();
          while (iterator.hasNext()){
              System.out.println(iterator.next());
          }
      }
  ```

  

- 定制排序

  - 創建TreeSet時傳入Comparator對象 按生日日期的先後排序

  ```java
  // 按生日日期的先後排序
      @Test
      public void test2(){
          TreeSet treeSet = new TreeSet(new Comparator() {
              @Override
              public int compare(Object o1, Object o2) {
                  // 先判斷傳入類型
                  if(o1 instanceof Employee && o2 instanceof Employee){
                      Employee e1 = (Employee) o1;
                      Employee e2 = (Employee) o2;
                      MyDate b1 = e1.getBirthday();
                      MyDate b2 = e2.getBirthday();
  
                   方式一
                      // 比較年
                      int minusYear = b1.getYear() - b2.getYear();
                      if(minusYear != 0){
                          return minusYear;
                      }
                      // 比較月
                      int minusMonth = b1.getMonth() - b2.getMonth();
                      if(minusMonth != 0){
                          return minusMonth;
                      }
                      // 比較日
                      return b1.getDay() - b2.getDay();
  
                  // 方式二
  //                    return b1.compareTo(b2);
                  }
  //                throw new RuntimeException("傳入的數據類型不一致");
              }
          });
  
          Employee e1 = new Employee("AAA",20,new MyDate(2004,5,20));
          Employee e2 = new Employee("CCC",25,new MyDate(2004,3,10));
          Employee e3 = new Employee("DDD",30,new MyDate(2000,6,13));
          Employee e4 = new Employee("BBB",35,new MyDate(2003,9,16));
          Employee e5 = new Employee("EEE",40,new MyDate(2020,12,19));
  
          treeSet.add(e1);
          treeSet.add(e2);
          treeSet.add(e3);
          treeSet.add(e4);
          treeSet.add(e5);
  
          Iterator iterator = treeSet.iterator();
          while (iterator.hasNext()) {
              System.out.println(iterator.next());
          }
      }
  
  }
  ```

  - MyDate實作Comparable介面
    - 將比較方法封裝在compareTo

  ```java
  public class MyDate implements Comparable{
      private int year;
      private int month;
      private int day;
  // constructor get set toString
  
      @Override
      public int compareTo(Object o) {
          if(o instanceof MyDate){
              MyDate m = (MyDate) o;
  
              int minusYear = this.getYear() - m.getYear();
              if(minusYear != 0){
                  return minusYear;
              }
              int minusMonth = this.getMonth() - m.getMonth();
              if (minusMonth != 0){
                  return minusMonth;
              }
              return this.getDay() - m.getDay();
          }
          throw new RuntimeException("傳入類型不一致");
      }
  }
  ```

  - 將得到的兩個MyDate類直接使用compareTo方法

  ```java
      // 按生日日期的先後排序
      @Test
      public void test2(){
          TreeSet treeSet = new TreeSet(new Comparator() {
              @Override
              public int compare(Object o1, Object o2) {
                  // 先判斷傳入類型
                  if(o1 instanceof Employee && o2 instanceof Employee){
                      Employee e1 = (Employee) o1;
                      Employee e2 = (Employee) o2;
                      MyDate b1 = e1.getBirthday();
                      MyDate b2 = e2.getBirthday();
                  // 方式二
                      return b1.compareTo(b2);
                  }
                  throw new RuntimeException("傳入的數據類型不一致");
              }
          });
  // treeSet 數據
          Iterator iterator = treeSet.iterator();
          while (iterator.hasNext()) {
              System.out.println(iterator.next());
          }
      }
  }
  ```



#### 面試題

- 在List內去除重複數字值

```java
將已經放置完 ArrayList的資料加入HashSet中
加入的ArrayList中 因為使用了set.addAll(list) 所以需要重寫hashCode()方法

public static List duplicateList(List list){
	HashSet set = new HashSet();
	set.addAll(list);
	return new ArrayList(set);
}
public static void main(String[] args){
	List list = new ArrayList();
	list.add(..);
	
	List list2 = duplicateList(list);
}
```



- HashSet  有效 無效操作

```java
@Test
public void test(){
    HashSet set = new HashSet();
    Person p1 = new Person("AA",1001);
    Person p2 = new Person("BB",1002);

    set.add(p1);
    set.add(p2);
    System.out.println(set);

    // 更改了 AA 1001 中計算的hashcode中的數據
    p1.setName("CC");
    // 但是刪除的是原p1的hashcode  指向的是 AA 1001 無效操作
    set.remove(p1);
    System.out.println(set);
    // 增加了 CC 1001 的數據  計算的hashcode位置為 CC 1001 有效操作
    set.add(new Person("CC",1001));
    System.out.println(set);
    // 增加了 AA 1001 的數據  因為之前更改了 AA --> CC  所以沒有重複 有效操作
    set.add(new Person("AA",1001));
    System.out.println(set);
}
```





# Map



#### Map實現類

```
 Map:雙列數據 儲存key-value對的數據 類似於函數 y = f(x)
     HashMap: 作為Map的主要實現類 執行緒不安全 效率高 可以儲存null的key和value
         LinkedHashMap: 保證在遍歷map元素時 可以按照添加的順序實現遍歷
              原因 : 在原有的HashMap底層結構基礎上 添加了一對指針 指向前一個和後一個元素
              對於頻繁的遍歷操作 此類執行效率高於HashMap
     TreeMap:保證按照添加的key-value對進行排序實現排序遍歷 此時考慮key的自然排序或定制排序
             底層使用紅黑樹
     Hashtable: 作為古老的實現類 執行緒安全 效率低 不能儲存null的key和value
         Properties:常用來處理配置文件 key和value都是String類型

HashMap的底層 : 陣列 + 鏈表 (jdk7以前)
               陣列 + 鏈表 + 紅黑樹 (jdk8)
```



#### Map結構理解

```java
Map結構的理解
    Map中的key : 無序的 不可重複的 使用Set儲存所有的key --> key所在的類要重寫equals()和hashCode() (以HashMap為例)
    Map中的value : 無序的 可重複的 使用Collection儲存所有的value --> value所在的類要重寫equals()
    一個鍵值對 : key-value構成了一個Entry對象
    Map中的entry : 無序的 不可重複的 使用Set儲存所有的entry
```



#### HashMap底層實現原理

- jdk7

```java
jdk7 :
    HashMap map = new HashMap():
    在實例化後 底層創建了長度為16的一維陣列Entry[] table
    ..可能執行過多次put..
    map.put(key1,value1)
    首先 調用key1所在類的hashCode()計算key1的hash值
         此hash值經過某種算法計算後 得到在Entry陣列中的存放位置
    如果此位置上的數據為空 此時的key1-value1添加成功  ----情況1
    如果此位置上的數據不為空 表示此位置上存在一個或多個數據(以鏈表形式存在)
                         比較key1和已經存在的所有數據的hash值
       如果key1的hash值與已經存在的數據的hash值都不相同 此時key1-value1添加成功  ----情況2
       如果key1的hash值和已經存在的某個數據的hash值相同 繼續比較: 調用key1所在類的equals()方法比較
                如果equals()返回false : 此時key1-value1添加成功  ----情況3
                如果equals()返回true : 使用value1替換value2
情況2和情況3 : 此時key1-value1和原來的數據以鏈表的方式儲存
    
在不斷的添加過程中 會涉及到擴充問題 預設的擴充方式 : 擴充為原來容量的2倍 並將原有的數據複製過來

```

- jdk8

```
jdk8
    new HashMap(): 底層沒有創建一個長度為16的陣列
    jdk8底層的陣列是 Node[] 而非 Entry[]
    首次調用put()方法時 底層創建長度為16的陣列
    jdk7底層結構只有 陣列+鏈表 jdk8中底層結構為 : 陣列+鏈表+紅黑樹
        當陣列中的某一個索引位置上的元素以鏈表形式存在的數據個數 > 8 且當前陣列的長度 > 64時
        此時此索引位置上的所有數據改為紅黑樹儲存
```



#### HashMap源碼分析 552

```
DEFAULT_INITIAL_CAPACITY : HashMap的預設容量 16
DEFAULT_LOAD_FACTOR : HashMap的預設加載因子 0.75
threshold : 擴充的臨界值 = 容量 * 加載因子 = 16 * 0.75 = 12
TREEIFY_THRESHOLD : Bucket中鏈表長度大於該預設值 轉化為紅黑樹 8
MIN_TREEIFY_CAPACITY : 桶中的Node被樹化時最小的hash表容量 64
```

- jdk7
- jdk8



#### 負載因子LOAD FACTOR

- 負載因子的大小決定了HashMap的數據密度
- 負載因子越大密度越大 發生碰撞的機率越高 陣列中的鏈表也就越長 造成查詢或插入時的比較次數增多 性能會下降
- 負載因子越小 就越容器觸發擴充 數據密度也越小 表示發生碰撞的機率越小 陣列中的鏈表也就越短 查詢跟插入時比較的次數也越小 性能會更高 但是會浪費一定的內容空間 而且經常擴充也會影響性能 建議初始化預設大一點的空間
- 按照其他語言的參考及研究經驗 會考慮將負載因子設置成0.7~0.75  此時平均搜尋長度接近於常數



#### LinkedHashMap底層實現

底層基本上是HashMap 只是增加了前後的保存

- HashMap中的內部類 : Node

```java
static class Node<K,V> implements Map.Entry<K,V> {
    final int hash;
    final K key;
    V value;
    Node<K,V> next;
}
```

- LinkedHashMap中的內部類 : Entry
  - 由before after記錄添加的元素的先後順序

``````java
static class Entry<K,V> extends HashMap.Node<K,V> {
        Entry<K,V> before, after;
        Entry(int hash, K key, V value, Node<K,V> next) {
            super(hash, key, value, next);
        }
    }
``````



#### Map常用方法

```java
Map中定義的方法
    添加 刪除 修改操作
       Object put(Object key,Object value) : 將指定key-value添加到(或修改)當前map對象中
       void putAll(Map m) : 將m中的所有key-value對存放到當前map中
       Object remove(Object key) : 移除指定key的key-value對 並返回value
       void clear() : 清空當前map中的所有數據
    元素查詢操作
       Object get(Object key) : 獲取指定key對應的value
       boolean containKey(Object key) : 是否包含指定的key
       boolean containValue(Object value) : 是否包含指定的value
       int size() : 返回map中key-value對的個數
       boolean isEmpty() : 判斷當前map是否為空
       boolean equals(Object obj) : 判斷當前map和參數對象obj是否相等
   元視圖操作的方法
       Set keySet() : 返回所有key構成的Set集合
       Collection values() : 返回所有value構成的Collection集合
       Set entrySet() : 返回所有key-value對構成的Set集合
```

- 添加 刪除 修改操作

```java
添加 刪除 修改操作
       Object put(Object key,Object value) : 將指定key-value添加到(或修改)當前map對象中
       void putAll(Map m) : 將m中的所有key-value對存放到當前map中
       Object remove(Object key) : 移除指定key的key-value對 並返回value
       void clear() : 清空當前map中的所有數據
	@Test
    public void test3(){
        Map map = new HashMap();
        // 將指定key-value添加到(或修改)當前map對象中
        map.put("AA",123);
        map.put("CC",14);
        map.put("BB",234);
        map.put("DD",678);
        map.put("AA",458);
        System.out.println(map);

        Map map1 = new HashMap();
        map1.put("NN",789);
        map1.put("DD",456);
        // 將m中的所有key-value對存放到當前map中
        map.putAll(map1);
        System.out.println(map);

        // remove(Object key)
        Object value = map.remove("CC");
        System.out.println(value);
        System.out.println(map);

        // clear()
        map.clear(); // 與map = null操作不同
        System.out.println(map.size());
        System.out.println(map);

    }    
```

- 元素查詢操作

```java
元素查詢操作
   Object get(Object key) : 獲取指定key對應的value
   boolean containKey(Object key) : 是否包含指定的key
   boolean containValue(Object value) : 是否包含指定的value
   int size() : 返回map中key-value對的個數
   boolean isEmpty() : 判斷當前map是否為空
   boolean equals(Object obj) : 判斷當前map和參數對象obj是否相等
    
	@Test
    public void test4(){
        Map map = new HashMap();
        map.put("AA",123);
        map.put(456,123);
        map.put("BB",56);
        // Object get(Object key)
        System.out.println(map.get(45));

        // boolean containKey(Object key)
        boolean isExist = map.containsKey("BB");
        System.out.println(isExist);

        // boolean containValue(Object value)
        isExist = map.containsValue(123);
        System.out.println(isExist);

        // boolean isEmpty() 判斷size是否 == 0
        map.clear(); // 將陣列元素的引用捨棄 設置size = 0
        System.out.println(map);
        System.out.println(map.isEmpty());

//      boolean equals(Object obj)  兩個同型的map : HashMap  key.value相同
    }    
```

- 元視圖操作的方法

```java
@Test
public void test5(){
    Map map = new HashMap();
    map.put("AA",123);
    map.put(45,123);
    map.put("BB",56);

    // 遍歷所有的key類 : keySet()
    Set set = map.keySet();
    Iterator iterator = set.iterator();
    while (iterator.hasNext()){
        System.out.println(iterator.next());
    }

    // 遍歷所有的value集 : values()
    Collection values = map.values();
    for (Object obj : values) {
        System.out.println(obj);
    }

    // 遍歷所有的key-value
    // 方式一 entrySet()
    Set entrySet = map.entrySet();
    Iterator iterator1 = entrySet.iterator();
    while(iterator1.hasNext()){
        Object next = iterator1.next();
        // entrySet集合中的元素都是entry
        Map.Entry entry = (Map.Entry) next;
        System.out.println(entry.getKey() + "---->" + entry.getValue());
    }
    // 方式二
    Set keySet = map.keySet();
    Iterator iterator2 = set.iterator();
    while (iterator2.hasNext()){
        Object key = iterator2.next();
        Object value = map.get(key);
        System.out.println(key + "---->" + value);
    }
}
```

- 總結 : 常用方法
  - 添加 : put(Object key,Object value)
  - 刪除 : remove(Object key)
  - 修改 : put(Object key,Object value)
  - 查詢 : get(Object key)
  - 長度 : size()
  - 遍歷 : keySet() / values() / entrySet()



#### TreeMap

- 自然排序

```java
// 向TreeMap中添加key-value 要求key必須是由同一個類創建的對象
// 因為要按照key進行排序 自然排序 定制排序

// 自然排序
@Test
public void test1(){
    TreeMap map = new TreeMap();
    User u1 = new User("BBB",20);
    User u2 = new User("HHH",22);
    User u3 = new User("AAA",25);
    User u4 = new User("EEE",18);
    User u5 = new User("EEE",23);
    map.put(u1,98);
    map.put(u2,76);
    map.put(u3,80);
    map.put(u4,66);
    map.put(u5,66);

    Set entrySet = map.entrySet();
    Iterator iterator = entrySet.iterator();
    while (iterator.hasNext()){
        Object obj = iterator.next();
        Map.Entry entry = (Map.Entry) obj;
        System.out.println(entry.getKey() + "---->" + entry.getValue());
    }
}
```

- 定制排序

```java
// 定制排序
@Test
public void test2(){
    TreeMap map = new TreeMap(new Comparator() {
        @Override
        public int compare(Object o1, Object o2) {
            if( o1 instanceof User && o2 instanceof User){
                User u1 = (User) o1;
                User u2 = (User) o2;
                // 依照年齡排序
                return Integer.compare(u1.getAge(),u2.getAge());
            }
            throw new RuntimeException("輸入的類型不匹配");
        }
    });
    User u1 = new User("BBB",20);
    User u2 = new User("HHH",22);
    User u3 = new User("AAA",25);
    User u4 = new User("EEE",18);
    User u5 = new User("EEE",23);
    map.put(u1,98);
    map.put(u2,76);
    map.put(u3,80);
    map.put(u4,66);
    map.put(u5,66);

    Set entrySet = map.entrySet();
    Iterator iterator = entrySet.iterator();
    while (iterator.hasNext()){
        Object obj = iterator.next();
        Map.Entry entry = (Map.Entry) obj;
        System.out.println(entry.getKey() + "---->" + entry.getValue());
    }
}
```



#### Map實現類-Properties

```java
public class PropertiesTest {
    public static void main(String[] args){
        FileInputStream fileInputStream = null;
        try {
        // Properties : 常用來處理配置文件 key和value都是String類型
            Properties pros = new Properties();
            fileInputStream = new FileInputStream("jdbc.properties");
            pros.load(fileInputStream); // 載入流對應的文件
            String name = pros.getProperty("name");
            String password = pros.getProperty("password");

            System.out.println(name);
            System.out.println(password);
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            if(fileInputStream != null){
                try {
                    fileInputStream.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```



## Collections工具類

操作陣列的工具類

- Collections是一個操作Set List Map等集合的工具類
- Collections中提供了一系列靜態的方法對集合元素進行排序 查詢 修改等操作 還提供了對集合對象設置不可變 對集合對象實現同步控制等方法
- 排序操作 (均為static方法)

```java
reverse(List) : 反轉List元素的順序
Shuffle(List) : 對list集合元素進行隨機排序
sort(List) : 根據元素的自然順序對指定list集合元素按升序排序
sort(List, Comparator) : 根據指定的Comparator產生的順序對list集合元素進行排序
swap(List, int, int) : 將指定list集合中的i處元素和j處元素進行交換
```



#### Collections常用方法

```java
Object max(Collection) : 根據元素的自然排序 返回給定集合中的最大元素
Object max(Collection, Comparator) : 根據Comparator指定的順序 返回給定集合中的最大元素
Object min(Collection)
Object min(Collection, Comparator)
int frequency(Collection, Object) : 返回指定集合中指定元素的出現次數
void copy(List dest,List src) : 將src中的內容複製到dest中
boolean replaceAll(List list,Object oldval, Object newVal) : 使用新值替換List對向的所有舊值
```



- reverse
- shuffle
- sort
- swap

```java
public class CollectionsTest {

    @Test
    public void test1(){
        List list = new ArrayList();
        list.add(123);
        list.add(46);
        list.add(84);
        list.add(0);
        list.add(-45);

        System.out.println(list);
//        Collections.reverse(list); // 反轉
//        Collections.shuffle(list); // 隨機化
//        Collections.sort(list); // 排序
//        Collections.swap(list,2,4);
        int frequency = Collections.frequency(list, 46); // 尋找出現次數
        System.out.println(frequency);
        System.out.println(list);
    }
```

- copy
- synchronizedList

```java
@Test
    public void test2(){
        List list = new ArrayList();
        list.add(123);
        list.add(46);
        list.add(84);
        list.add(0);
        list.add(-45);

//        List dest = new ArrayList();
//        Collections.copy(dest,list); // srcSize > dest.size() 則拋出異常

        List dest = Arrays.asList(new Object[list.size()]);
        System.out.println(list.size()); // 5
        System.out.println(dest); // [null, null, null, null, null]
        Collections.copy(dest,list);
        System.out.println(dest);

        /*
            Collections 類中提供了多個 synchronizedXxx()方法
            該方法可使將指定集合包裝成執行緒同步的集合
            從而可以解決多執行緒並發訪問集合時的執行緒安全問題
         */
        // 返回的list1即為執行緒安全的List
        List list1 = Collections.synchronizedList(list);
    }
```



#### Map-複習

```
常用實現類結構
```

``````
 Map:雙列數據 儲存key-value對的數據 類似於函數 y = f(x)
     HashMap: 作為Map的主要實現類 執行緒不安全 效率高 可以儲存null的key和value
         LinkedHashMap: 保證在遍歷map元素時 可以按照添加的順序實現遍歷
              原因 : 在原有的HashMap底層結構基礎上 添加了一對指針 指向前一個和後一個元素
              對於頻繁的遍歷操作 此類執行效率高於HashMap
     TreeMap:保證按照添加的key-value對進行排序實現排序遍歷 此時考慮key的自然排序或定制排序
             底層使用紅黑樹
     Hashtable: 作為古老的實現類 執行緒安全 效率低 不能儲存null的key和value
         Properties:常用來處理配置文件 key和value都是String類型

HashMap的底層 : 陣列 + 鏈表 (jdk7以前)
               陣列 + 鏈表 + 紅黑樹 (jdk8)
``````



```
Map結構理解
```

```
Map中的key : 無序的 不可重複的 使用Set儲存所有的key --> key所在的類要重寫equals()和		hashCode() (以HashMap為例)
Map中的value : 無序的 可重複的 使用Collection儲存所有的value --> value所在的類要重寫	equals()
一個鍵值對 : key-value構成了一個Entry對象
Map中的entry : 無序的 不可重複的 使用Set儲存所有的entry
```



```
常用方法
```

```
- - 添加 : put(Object key,Object value)
  - 刪除 : remove(Object key)
  - 修改 : put(Object key,Object value)
  - 查詢 : get(Object key)
  - 長度 : size()
  - 遍歷 : keySet() / values() / entrySet()
```



```
HashMap底層典型屬性的說明
```

```
DEFAULT_INITIAL_CAPACITY : HashMap的預設容量 16
DEFAULT_LOAD_FACTOR : HashMap的預設加載因子 0.75
threshold : 擴充的臨界值 = 容量 * 加載因子 = 16 * 0.75 = 12
TREEIFY_THRESHOLD : Bucket中鏈表長度大於該預設值 轉化為紅黑樹 8
MIN_TREEIFY_CAPACITY : 桶中的Node被樹化時最小的hash表容量 64
```



```
TreeMap的使用
```

- 自然排序
- 定制排序





#### Collections工具類-複習

```
作用
```

- 操作Collection和Map的工具類

``````
常用方法
``````

```java
reverse(List) : 反轉List元素的順序
Shuffle(List) : 對list集合元素進行隨機排序
sort(List) : 根據元素的自然順序對指定list集合元素按升序排序
sort(List, Comparator) : 根據指定的Comparator產生的順序對list集合元素進行排序
swap(List, int, int) : 將指定list集合中的i處元素和j處元素進行交換

Object max(Collection) : 根據元素的自然排序 返回給定集合中的最大元素
Object max(Collection, Comparator) : 根據Comparator指定的順序 返回給定集合中的最大元素
Object min(Collection)
Object min(Collection, Comparator)
int frequency(Collection, Object) : 返回指定集合中指定元素的出現次數
void copy(List dest,List src) : 將src中的內容複製到dest中
boolean replaceAll(List list,Object oldval, Object newVal) : 使用新值替換List對向的所有舊值
```

- ArrayList和HashMap都是執行緒不安全的 如果程式要求執行緒安全 我們可以將ArrayList HashMap轉換為執行緒安全的
  - 使用 synchronizeList(List list) 和 synchronizedMap(Map map)



``````
面試題-Collection 和 Collections的區別
``````





# 泛型Generic



#### 為什麼要有泛型

- 作為標籤
- 設計背景
  - 集合容器類在設計階段/聲明階段 不能確定這個容器到底實際存放的是什麼類型的對象
  - 因為這個時候除了元素的類型不確定 其他的部分是確定的
    - 例如關於這個元素如何保存 如何管理是確定的
    - 因此此時把元素的類型設計成一個參數 這個類型參數就叫做泛型
    - Collection<E\> List<E\> ArrayList<E\>  <E\>為類型參數 即為泛型



#### 泛型的概念

- 泛型就是允許在定義類 接口時通過一個標誌表示類中某個屬性的類型 或者是某個方法的返回值及參數類型
- 這個類型參數將在使用時 (例如繼承或實現這個接口 用這個類型聲明變數 創建對象時) 確定(即傳入實際的類型參數 也稱為類型實參)



#### 在集合中使用泛型

- 集合接口或集合類在jdk5.0時都修改為帶泛型的結構
- 在實例化集合類時 可以指名具體的泛型類型
- 指名完後 在集合類或接口中凡是定義類或接口時 內部結構 (方法 建構器 屬性)使用到類的泛型的位置 都指定為實例化的泛型類型
  - 例如 : add(E e) --> 實例化 : add(Integer e)
- 泛型的類型必須是類  不能事基本數據類型 需用到基本數據的位置  包裝類

```java
/*
    jdk5.0新增的特性

    在集合中使用泛型   
 */
public class GenericTest {

    // 集合中使用泛型的情況 : ArrayList
    @Test
    public void test(){
        ArrayList<Integer> list = new ArrayList<Integer>();
        list.add(45);
        list.add(34);
        list.add(78);
        list.add(23);
        // 編譯時 就是進行類型檢查 保證數據的安全
//        list.add("DFG");

//      方式一
//        for (Integer score : list) {
//            // 避免了強轉操作
//            int stuScore = score;
//            System.out.println(stuScore);
//        }

//        方式二
        Iterator<Integer> iterator = list.iterator();
        while (iterator.hasNext()){
            Integer stuScore = iterator.next();
            System.out.println(stuScore);
        }
    }

    // 在集合中使用泛型的情況 HashMap
    @Test
    public void test2(){
        Map<String,Integer> map = new HashMap<String,Integer>();
        map.put("AAA",234);
        map.put("BBB",431);
        map.put("CCC",543);
        map.put("DDD",634);
        // 泛型嵌套
        Set<Map.Entry<String,Integer>> entry = map.entrySet();
        Iterator<Map.Entry<String,Integer>> iterator = entry.iterator();
        while (iterator.hasNext()){
            Map.Entry<String,Integer> e = iterator.next();
            String key = e.getKey();
            Integer value = e.getValue();
            System.out.println(key + "=====" + value);
        }

    }

}
```



#### TreeSet泛型實現

- 在tree的判斷中 更改 Comparable  Comparator  使用泛型

```java
public class MyDate implements Comparable<MyDate>

@Override
    public int compareTo(MyDate m) {
        int minusYear = this.getYear() - m.getYear();
            if(minusYear != 0){
                return minusYear;
            }
            int minusMonth = this.getMonth() - m.getMonth();
            if (minusMonth != 0){
                return minusMonth;
            }
            return this.getDay() - m.getDay();
        }
    }
```



```java
TreeSet treeSet = new TreeSet(new Comparator<Employee>() {
    @Override
    public int compare(Employee o1, Employee o2) {
        MyDate b1 = o1.getBirthday();
        MyDate b2 = o2.getBirthday();

        // 方式二
            return b1.compareTo(b2);
        }
    });
```



#### 自定義泛型結構

泛型類 泛型接口

- 泛型類可能有多個參數 此時應將多個參數一起放在<>中
  - 例如 <E1,E2,E3\>
- 泛型類的建構器為 public GenericClass(){}
  - 而不是 public GenericClass<E\>(){}
- 實例化後 操作原來泛型位置的結構必須與指定的泛型類型一致
- 泛型不同的引用不能相互賦值
  - 在編譯時ArrayList<String\> 和 ArrayList<integer\>是兩種類型
  - 但是在運行時只有一個ArrayList被加載到JVM中

```java
@Test
public void test3(){
    ArrayList<String> list1 = null;
    ArrayList<Integer> list2 = null;
    // 泛型不同的引用不能相互賦值
    list1 = list2;
}
```

- 泛型如果不指定 將被擦除 泛型對應的類型按照Object處理 但不等價於Object
  - 泛型要使用一路都用  不使用的話一路都不使用
- 如果泛型是一個接口或抽象類 則不可創建泛型類的對象
- jdk1.7 泛型的簡化操作 : ArrayList<Fruit\> flist = new ArrayList<>(); 類型推斷
- 泛型的指定中不能使用基本數據類型 可以使用包裝類替換
- 在類/接口上聲明的泛型 在本類或本接口中即代表某種類型 可以做為非靜態屬性的類型 非進泰方法的參數類型 非靜態方法的返回值類型
  - 但在靜態方法中不能使用類的泛型
    - 因為泛型是類創建時決定  但是靜態方法早於類創建前建立
- 異常類不能是泛型的
- 不能使用new E[]  
  - 但是可以 E[] elements = (E[]) new Object[capacity];
  - 參考 ArrayList源碼中聲明 : Object[] elementData 而非泛型參數類型陣列
- 父類有泛型 子類可以選擇保留泛型 也可以選擇指定泛型類型
  - 子類不保留父類的泛型 按需實現
    - 沒有類型 擦除
    - 具體類型
  - 子類保留父類的泛型 泛型子類
    - 全部保留
    - 部分保留

```java
class Father<T1,T2>{}
// 子類不保留父類的泛型
// 沒有類型 擦除
class Son1 entends Father{} // 等價於 class Son entends Father<Object,Object>
// 具體類型
class Son2 entends Father<Integer,String>{}
// 子類保留父類的泛型
// 全部保留
class Son3<T1,T2> entends Father<T1,T2>{}
// 部分保留
class Son4<T2> entends Father<Integer,T2>{}
```



```java
// 自定義泛型類 泛型接口
public class GenericTest2 {

    @Test
    public void test1(){
        // 如果定義了泛型類 實例化沒有指明類的泛型 則認為此泛型類型為Object類型
        // 要求 : 如果定義了類帶有泛型  建議在實例化時要指名類的泛型

        // 實例化時指名類的泛型
        Order<String> order = new Order<>("orderAA",1001,"order:AA");
        order.setOrderT("AAA");
    }

    @Test
    public void test2(){
        subOrder subOrder = new subOrder();
        // 由於子類在繼承帶泛型的父類時 指名了泛型類型 則實例化子類對象時 不再需要指名泛型
        subOrder.setOrderT(124);
    }

}
```



#### 自定義泛型方法

- 泛型方法 : 在方法中出現了泛型的結構 泛型參數與類的泛型參數沒有任何關係
  - 也就是 泛型方法所屬的類是不是泛型類都沒有關係

```java
// 泛型方法 : 方法中出現了泛型的結構 泛型參數與類的泛型參數沒有任何關係
    // 也就是 泛型方法所屬的類是不是泛型類都沒有關係
    // 泛型方法 可以聲明為靜態的 原因 : 泛型參數是在調用方法時確定的 並非在實例話類時確定
    public <E> List<E> copyFromArrayToList(E[] arr){
        ArrayList<E> list = new ArrayList<>();
        for (E e : arr) {
            list.add(e);
        }
        return list;
    }
```

- 測試

```java
// 測試泛型方法
@Test
public void test4(){
    Order<String> order = new Order<>();
    Integer[] arr = new Integer[]{1,2,4,5};
    // 泛型方法調用時  指名泛型參數的類型
    // 也就是說泛型方法可以設置為static
    // public <E> List<E> copyFromArrayToList(E[] arr){
    List<Integer> list = order.copyFromArrayToList(arr);

    System.out.println(list);
}
```





#### 泛型在繼承上的體現

- subOrder 不為一個泛型類

```
public class subOrder extends Order<Integer>{
```

- subOrder2 為一個泛型類

```
public class subOrder2<T> extends Order<T>{
```



```java
泛型在繼承方面的體現

雖然類A是類B的父類  但是 G<A> 和 G<B> 不具備子父類關係 兩者是並列關係

類A是類B的父類  A<G> 是 B<G> 的父類
    
@Test
    public void test1(){
    // 具子父類關係
        Object obj = null;
        String str = null;
        obj = str;

        Object[] arr1 = null;
        String[] arr2 = null;
        arr1 = arr2;

        List<Object> list1 = null;
        List<String> list2 = null;
        // 此時的list1和list2的類型不具有子父類關係
//         編譯不通過
//        list1 = list2;

        Date date = new Date();
//         編譯不通過
//        str = date;
    }    
```



```java
// 編譯通過
@Test
public void test2(){
    AbstractList<String> list1 = null;
    List<String> list2 = null;
    ArrayList<String> list3 = null;
    list1 = list3;
    list2 = list3;

    // list3 list2 相當於普通的泛型宣告
    List<String> list4 = new ArrayList<>();
}
```



#### 通配符的使用

- 例如 List<?\>  Map<?\>
  - List<?\>是List<String\> List<Object\>等各種泛型List的父類
- 讀取List<?\>的對象list中的元素時 永遠是安全的 因為不管list的真實類型是什麼 它包含的都是Object
- 寫入list中的元素時 不允許通過
  - 因為我們不知道c的元素類型 不能向其中添加對象
  - 唯一的例外是null 他是所有類型的成員

```java
/*
    通配符的使用
    通配符 : ?

    類A和類B的父類 G<A> 和G<B> 是沒有關係的
    兩者共同的父類是 G<?>
 */
@Test
public void test3(){
    List<Object> list1 = null;
    List<String> list2 = null;

    List<?> list = null;

    list = list1;
    list = list2;
}
public void print(List<?> list){
    Iterator<?> iterator = list.iterator();
    while (iterator.hasNext()){
        Object obj = iterator.next();
        System.out.println(obj);
    }
}
```



```java
@Test
    public void test3(){
        List<Object> list1 = null;
        List<String> list2 = null;

        List<?> list = null;

        list = list1;
        list = list2;

//        print(list1);
//        print(list2);

        List<String> list3 = new ArrayList<>();
        list3.add("AA");
        list3.add("BB");
        list3.add("CC");
        list = list3;
        // 添加操作 : 對於List<?> 不能向其內部添加數據
        // 除了添加null之外
//        list.add("DD");
//        list.add('?');
        list.add(null);

        // 獲取 (讀取) : 允許讀取數據 讀取的數據類型為Object
        Object o = list.get(0); // AA
        System.out.println(o);

    }

    public void print(List<?> list){
        Iterator<?> iterator = list.iterator();
        while (iterator.hasNext()){
            Object obj = iterator.next();
            System.out.println(obj);
        }
    }
```



#### 有限制條件的通配符

- <?\> 允許所有泛型的引用調用
- 通配符指定上限
  - 上限extends : 使用時指定的類型必須是繼承某個類 或是實現某個接口 即 <=
- 通配符指定下限
  - 下限super : 使用時指定的類型不能小於操作的類 即 >=
- 舉例
  - <? extends Number\> (無窮小,Number]
    - 只允許泛型為Number及Number子類的引用調用
  - <? super Number\> [Number,無窮大)
    - 只允許泛型為Number及Number父類的引用調用
  - <? extends Comparable\>
    - 只允許泛型為實現Comparable接口的實現類的引用調用

```java
    /*
        有限制條件的通配符的使用
        ? extends A :
                     G<? extends A> 可以作為G<A>和G<B>的父類 其中B是A的子類
        ? super A :
                     G<? super A> 可以作為G<A>和G<B>的父類 其中B是A的父類
        Student extends Person
     */
    @Test
    public void test4(){
        List<? extends Person> list1 = null; // ? <= Person
        List<? super Person> list2 = null; // ? >= Person
//        繼承情況 : Object --> Person --> Student
        List<Student> list3 = null;
        List<Person> list4 = null;
        List<Object> list5 = null;

        list1 = list3;
        list1 = list4;
//        list1 = list5;  // 不允許 需要繼承自Person 或Person自身

//        list2 = list3;   // 不允許 必須要是Person類 或以上的父類
        list2 = list4;
        list2 = list5;

        // 讀取數據
        list1 = list4;
        Person p = list1.get(0);
        // 編譯不通過
//        Student s = list1.get(0);

        list2 = list4;
        Object obj = list2.get(0);
//        Person obj = list2.get(0);

//        寫入數據
//        編譯不通過
//        list1.add(new Student()); 出現父類賦值給子類的情況

        list2.add(new Person());
        list2.add(new Student());
    }
```



#### 泛型應用舉例

- 泛型類 設計方法操作
  - save
  - get
  - update
  - list 遍歷
  - delete

```java
public class DAO<T> {
    private Map<String,T> map = new HashMap<String,T>();

    public void save(String id,T entity){
        map.put(id,entity);
    }

    public T get(String id){
        return map.get(id);
    };

    public void update(String id,T entity){
        if(map.containsKey(id)){ // 判斷id是否存在
            map.put(id,entity);
        }
    }
    // 返回map中存放的所有T對象
    public List<T> list(){
        // 錯誤
//        Collection<T> values = map.values();  // 本身返回為Collection<T>
//        return (List<T>) values;  // 不能強轉為 List<T>
        ArrayList<T> list = new ArrayList<>();
        Collection<T> values = map.values();
        for (T t : values) {
            list.add(t); // 返回對象加入list中
        }
        return list; // 回傳list
    }

    // 刪除指定id對象
    public void delete(String id){
        map.remove(id);
    }
}
```

- 實體類

```java
// 重寫equals方法
public class User {
    private int id;
    private int age;
    private String name;
 	// get set constructor equals
}
```

- 執行操作

```java
public class DAOTest {
    public static void main(String[] args) {
        DAO<User> dao = new DAO<>();
        // id,User
        dao.save("1001",new User(1001,20,"AAA"));
        dao.save("1002",new User(1002,30,"BBB"));
        dao.save("1003",new User(1003,28,"CCC"));

        dao.update("1003",new User(1003,40,"DDD"));
        dao.delete("1002");


        List<User> list = dao.list();
        Iterator<User> iterator = list.iterator();
        while (iterator.hasNext()){
            System.out.println(iterator.next());
        }
    }
}
```



# IO流



#### File類的使用

File類的理解

- File類的一個對象  代表一個文件或一個文件目錄 (資料夾)
- File類聲明在java.io包下
- File類中涉及到關於文件或文件目錄的創見 刪除 重命名 修改時間 文件大小等方法
  - 並未涉及到寫入或讀取文件內容的操作 如果需要讀取或寫入文件內容 必須使用IO流完成

- 後續File類的對象長會作為參數傳遞到流的建構器中 指名讀取或寫入的終點

File的實例化

- 常見的建構器
  - File(String filePath)
  - File(String parentPath,String childPath)
  - File(File parentFile,String childPath)
- 路徑的分類
  - 相對路徑 : 相較於某個路徑下 指名的路徑
    - 如果使用JUnit中的單元測試方法 相對路徑則為當前Module下
    - 如果使用main()測試 相對路徑即為當前的Project下
  - 絕對路徑 : 包含磁碟在內的文件或文件目錄的路徑
- 路徑分隔符號
  - windows dos預設使用 \ 
  - UNIX URL使用 / 

#### File類的常用方法

``````java
public string getAbsolutePath() : 獲取絕對路徑
public String getPath() : 獲取路徑
public String getName() : 獲取名稱
public String getParent() : 獲取上層文件目錄路徑 若無 返回null
public long length() : 獲取文件長度 (字元數) 不能獲取目錄的長度
public long lastModified() : 獲取最後一次的修改時間 毫秒數

public String[] list() : 獲取指定目錄下的所有文件或者文件目錄的名稱陣列
public File[] listFiles() : 獲取指定目錄下的所有文件或者文件目錄的File陣列
``````

File類的重命名功能

``````java
public boolean renameTo(File dest) : 把文件重命名為指定的文件路徑
``````

File類的判斷功能

``````java
public boolean isDirectory() : 判斷是否是文件目錄 
public boolean isFile() : 判斷是否是文件
public boolean exists() : 判斷是否存在
public boolean canRead() : 判斷是否可讀
public boolean canWrite() : 判斷是否可寫
public boolean isHidden() : 判斷是否隱藏
``````

File類的創建功能

``````java
public boolean createNewFile() : 創建文件 若文件存在 則不創建 返回false
public boolean mkdir() : 創建文件目錄 如果此文件目錄存在 就不創建 如果此文件目錄的上層目錄也不存在 也不創建
public boolean mkdirs() : 創建文件目錄 如果上層文件目錄不存在 一併創建 

如果創建的文件或文件目錄沒有寫磁碟路徑  預設創建在項目路徑下
``````

File類的刪除功能

``````java
public boolean delete() : 刪除文件或文件夾

刪除注意事項 : java中的刪除不走回收站  要刪除一個文件目錄 注意該文件目錄內不能包含文件或文件目錄
``````



#### IO流的原理及流的分類

- I/O input/Output的縮寫  用於處理設備之間的數據傳輸



流的分類

- 依照操作的數據單位不同分為 : byte流(8 bit)  字元流(16 bit)
- 按數據流的流向不同分為 : 輸入流 輸出流
- 按流的角色的不同分為 : 節點流 處理流
- IO流共涉及了40多個類  但都是由這4個抽象基類派生出來的



#### 節點流 (文件流)



##### 流的處理

- byte流
  - FileInputStream
  - FileOutputStream
  - 適合處理非文本文件
- char流
  - FileReader
  - FileWriter
  - 適合處理文本文件

```java
結論:
    對於文本文件(.txt .java .c .cpp)使用字元流處理  FileReader  FileWriter
    對於非文本文件(.jpg .mp3 .mp4 .avi .doc .ppt) 使用byte流處理  FileInputStream FileOutputStream
```



流的結構體系

```java
/*
    流的分類
    1.操作數據單位 : byte流 字元流
    2.數據的流向 : 輸入流 輸出流
    3.流的角色 : 節點流 處理流

    流的體系結構
    抽象基類            節點流 (文件流)            					    
    InputStream        FileInputStream (read(byte[] buffer))           
    OutputStream       FileOutputStream (write(byte[] buffer,0,len))  
    Reader             FileReader(read(char[] cbuf))  				   
    Writer             FileWriter(write(char[] cbuf,0,len)) 		   

	緩衝流(處理流的一種)
	BufferedInputStream (read(byte[] buffer)) 
	BufferedOutputStream (write(byte[] buffer,0,len))
	BufferedReader (read(char[] cbuf) / readLine())
	BufferedWriter (write(char[] cbuf,0,len))
 */
```

- 讀取數據
  - 一次讀取一個
  - FileReader   FileWriter  讀取字元

```java
// 說明
    // 1.read() : 返回讀入的一個字元 如果達到了文件末尾 返回-1
    // 2.異常的處理 : 為了保證流資源一定可以執行關閉操作 需要使用try-catch-finally處理
    // 3.讀入的文件一定要存在 否則會報FileNotFoundException
    @Test
    public void testFileReader(){
        FileReader fileReader = null;
        try {
            // 1.實例化file類的對象 指名要操作的文件
            File file = new File("hello.txt"); // 相較於當前的Module
            // 2.提供具體的流
            fileReader = new FileReader(file);
            // 3.數據的讀入
            // read() : 返回讀入的一個字元 如果達到了文件末尾 返回-1

            // 方式一
//        int read = fileReader.read();
//        while (read != -1){
//            System.out.print((char)read);
//            read = fileReader.read();
//        }

            // 方式二 : 語法上的修改
            int data;
            while ((data = fileReader.read()) != -1){
                System.out.print((char) data);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            // 4.流的關閉操作
            try {
                if (fileReader != null) // 如果對象被創立後 才關閉
                fileReader.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
```



##### 讀取數據char

- 使用 FileReader  FileWriter
- 一次讀取多個
- 注意點 最後讀的字元數可能會小於一次讀取的數量 需要特別處理

```java
// 對read()操作升級 : 使用read的重載方法
    @Test
    public void testFileReader1(){
        FileReader fr = null;
        try {
            //1.File類的實例化
            File file = new File("hello.txt");
            //2.FileReader流的實例化
            fr = new FileReader(file);
            //3.讀入的操作
            // read(char[] cbuffer) : 返回每次讀入cbuffer陣列中的字元的個數
            //                        如果達到文件末尾 返回-1
            char[] cbuffer = new char[5];
            int len;
            while ( (len = fr.read(cbuffer)) != -1){
//                方式一
//                錯誤的寫法
//                for (int i = 0; i < cbuffer.length; i++) {
//                    System.out.print(cbuffer[i]);
//                }
//                正確的寫法
//                for (int i = 0; i < len; i++) {
//                    System.out.print(cbuffer[i]);
//                }
                //方式二
                // 錯誤的寫法
//                String str = new String(cbuffer);
//                System.out.print(str);
                // 正確的寫法
                String str = new String(cbuffer,0,len);
                System.out.print(str);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            //4.資源的關閉
            try {
                if (fr != null)
                fr.close();
            } catch (IOException e) {
                e.printStackTrace();
            }

        }


    }
```



##### 寫入數據char

- FileWriter(file,false) 根據true false 決定是否將文件覆蓋
  - FileWriter


```java
/*
    從記憶體中寫入數據到文件中
    1.輸入操作 對應的File可以不存在
    2.  File對應的文件如果不存在 在輸出的過程 會自動創建此文件
        File對應的文件如果存在
            如果流使用的建構器是: FileWriter(file,false) / FileWriter(file) : 對原有文件的覆蓋
                               FileWriter(file,true) : 不會對原有文件覆蓋 對原有文件追加內容
 */
@Test
public void testFileWriter() throws IOException {
    //1.提供File類的對象 指明寫入的文件
    File file = new File("hello1.txt");
    //2.提供FileWriter的對象 用於數據的寫入
    FileWriter fw = new FileWriter(file,false); // true 添加  false覆蓋文件
    //3.寫入的操作
    fw.write("I hava a dream\n");
    fw.write("you need to have a dream");
    //4.流資源的關閉
    fw.close();
}
```

- 將一個文件寫入另一個文件
  - FileReader
  - FileWriter


```java
@Test
public void testFileReaderFileWriter(){
    FileReader fr = null;
    FileWriter fw = null;
    try {
        //1.創建File類的對象 指明讀入和寫出的文件
        File srcFile = new File("hello.txt");
        File destFile = new File("hello2.txt");
        //2.創建輸入流和輸出流的對象
        fr = new FileReader(srcFile);
        fw = new FileWriter(destFile);
        //3.數據的讀入和寫出操作
        char[] cbuf = new char[5];
        int len; // 記錄每次讀入到cbuf陣列中的字元的個數
        while ((len = fr.read(cbuf)) != -1){
            // 每次寫出len個字元
            fw.write(cbuf,0,len);
        }
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        //4.關閉流資源
        try {
            if (fr != null)
            fr.close();
        } catch (IOException e) {
            e.printStackTrace();

        }

        try {
            if (fw != null)
            fw.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```



##### 讀取數據byte

- FileInputStream   
- FileOutputStream

```java
/*
  測試FileInputStream和FileOutputStream的使用

  結論:
    對於文本文件(.txt .java .c .cpp)使用字元流處理  FileReader  FileWriter
    對於非文本文件(.jpg .mp3 .mp4 .avi .doc .ppt) 使用byte流處理  FileInputStream   FileOutputStream

 */
@Test
public void testFileInputStream(){
    FileInputStream fis = null;
    try {
        // 1.建立文件
        File file = new File("hello.txt");
        // 2.建立流
        fis = new FileInputStream(file);
        // 3.讀取數據
        byte[] buffer = new byte[5];
        int len; // 紀錄每次讀取的byte的個數
        while ((len = fis.read(buffer)) != -1){
            String str = new String(buffer, 0, len);
            System.out.print(str);
        }
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        // 4.關閉流
        try {
            fis.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```



##### 圖片複製byte

- FileInputStream
- FileOutputStream

```java
/*
    實現圖片的複製操作  非文本 : FileInputStream
 */
@Test
public void testFileInputOutputStream(){
    FileInputStream fis = null;
    FileOutputStream fos = null;
    try {
        //
        File srcFile = new File("icon.jpg");
        File destFile = new File("icon2.jpg");
        //
        fis = new FileInputStream(srcFile);
        fos = new FileOutputStream(destFile);

        // 複製過程
        byte[] buffer = new byte[5];
        int len;
        while ( (len = fis.read(buffer)) != -1){
            // 寫出
            fos.write(buffer,0,len);
        }
        System.out.println("複製成功");
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        // 關閉操作
        if (fos != null){
            try {
                fos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        if (fis != null){
            try {
                fis.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```



##### 文件複製byte

- FileInputStream
- FileOutputStream

```java
// 指定路徑下文件的複製
public static void copyFile(String srcPath,String destPath){
    FileInputStream fis = null;
    FileOutputStream fos = null;
    try {
        //
        File srcFile = new File(srcPath);
        File destFile = new File(destPath);
        //
        fis = new FileInputStream(srcFile);
        fos = new FileOutputStream(destFile);

        // 複製過程
        byte[] buffer = new byte[1024];
        int len;
        while ( (len = fis.read(buffer)) != -1){
            // 寫出
            fos.write(buffer,0,len);
        }
        System.out.println("複製成功");
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        // 關閉操作
        if (fos != null){
            try {
                fos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        if (fis != null){
            try {
                fis.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```



```java
public class FileInputOutputStreamTest {
    public static void main(String[] args) {
        long start = System.currentTimeMillis();
        System.out.println(start);

        String srcPath = "C:\\Users\\wsx03\\Desktop\\1234.mp4";
        String destPath = "C:\\Users\\wsx03\\Desktop\\123.mp4";
        copyFile(srcPath,destPath);

        long end = System.currentTimeMillis();

        System.out.println("複製操作花費的時間為" + (end - start));
    }
}
```



#### 處理流-緩衝流

- 在基本流 FileInputStream (byte) 之外 再包一層 BufferedInputStream (byte)
- 關閉流時  關閉外層流同時也會關閉內層的流



##### 非文本文件複製(byte)

- FileInputStream --> BufferedInputStream
- FileOutputStream--> BufferedOutputStream

```java
/*
    實現非文本文件的複製 (byte)
 */
@Test
public static void BufferedStreamTest(String src,String dest){
    FileInputStream fis = null;
    FileOutputStream fos = null;
    BufferedInputStream bis = null;
    BufferedOutputStream bos = null;
    try {
        // 1.創建文件
        File srcFile = new File(src);
        File destFile = new File(dest);
        // 2.創建流
        // 2.1創建節點流
        fis = new FileInputStream(srcFile);
        fos = new FileOutputStream(destFile);
        // 2.2創建緩衝流
        bis = new BufferedInputStream(fis);
        bos = new BufferedOutputStream(fos);

        // 3.複製的細節 : 讀取 寫入
        byte[] buffer = new byte[10];
        int len;
        while ( (len = bis.read(buffer)) != -1){
            bos.write(buffer,0,len);
        }
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        // 4.資源關閉  要求:先關閉外層的流
        // 關閉外層流的同時 內層流也會自動地進行關閉
        try {
            bis.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
        try {
            bos.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```



##### 文本文件複製(char)

- FileReader --> BufferedReader
- FileWriter  --> BufferedWriter

```java
/*
        使用BufferReader和BufferedWriter實現文本文件的複製
     */
    @Test
    public void testBufferedReaderBufferedWriter(){
        FileReader fr = null;
        FileWriter fw = null;
        BufferedReader br = null;
        BufferedWriter bw = null;
        try {
            // 1.創建文件
            File srcFile = new File("hello.txt");
            File destFile = new File("hello22.txt");
            // 2.創建流
            // 2.1創建節點流
            fr = new FileReader(srcFile);
            fw = new FileWriter(destFile);
            // 2.2創建緩衝流
            br = new BufferedReader(fr);
            bw = new BufferedWriter(fw);

            // 3.複製的細節 : 讀取 寫入
            // 方式一 : 使用char[]陣列
//            char[] buffer = new char[10];
//            int len;
//            while ( (len = br.read(buffer)) != -1){
//                bw.write(buffer,0,len);
//            }

            // 方式二 : 使用String
            String data;
            while ( (data = br.readLine()) != null){
                // 方法一
//                bw.write(data + "\n"); // data中不包含換行符號
                // 方法二
                bw.write(data); // 不包含換行符號
                bw.newLine();
            }

        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            // 4.資源關閉  要求:先關閉外層的流
            // 關閉外層流的同時 內層流也會自動地進行關閉
            try {
                br.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
            try {
                bw.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
```



#### 練習-圖片加密



圖片的加密

```java
// 圖片的加密
@Test
public void test1(){
    FileInputStream fis = null;
    FileOutputStream fos = null;
    try {
        fis = new FileInputStream("icon.jpg");
        fos = new FileOutputStream("iconencode.jpg");

        byte[] buffer = new byte[20];
        int len;
        while ( (len = fis.read(buffer)) != -1){
            // byte數據修改
            for (int i = 0; i < len; i++) {
                buffer[i] = (byte) (buffer[i] ^ 5);
            }

            fos.write(buffer,0,len);
        }
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        if (fos != null){
            try {
                fos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        if (fis != null){
            try {
                fis.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```



圖片的解密

- 再進行一次一樣的XOR 即可還原為原來的數據

``````java
fis = new FileInputStream("iconencode.jpg");
fos = new FileOutputStream("icodencode.jpg");
``````



#### 處理流-轉換流

```java
1.轉換流 : 屬於char流
    InputStreamReader
    OutputStreamWriter
2.作用 : 提供byte流與char流之間的轉換

3.解碼 : byte byte陣列 --> char陣列 字串
  編碼 : char陣列 字串  --> byte byte陣列
```

- InputStreamReader : 將inputStream轉換為Reader
  - 解碼 : 輸入的byte流 --> 輸入的char流
- OutputStreamWriter : 將Writer轉換為OutputStream
  - 編碼 : 輸出的char流 --> 輸出的byte流
- byte流中的數遽都是字元時 轉換成char流操作更有效率
- 轉換流通常使用處理文件亂碼問題  實現編碼和解碼功能



解碼操作

- 預設解碼 UTF-8

```java
/*
        將字串讀到記憶體中
        此時處理異常 仍然使用try-catch-finally
        InputStreamReader的使用 實現byte的輸入流到char的輸入流的轉換
     */
    @Test
    public void test1(){
        InputStreamReader isr = null; // 使用系統預設的字元集
        try {
            FileInputStream fis = new FileInputStream("hello.txt");
//        InputStreamReader isr = new InputStreamReader(fis); // 使用系統預設的字元集UTF-8
            // 指明了字元集 具體使用哪個字元集  根據文件保存時使用的字元集決定
            isr = new InputStreamReader(fis,"UTF-8"); // 使用轉換流
            char[] cbuf = new char[20];
            int len;
            while ( (len = isr.read(cbuf)) != -1){
                String str = new String(cbuf, 0, len);
                System.out.print(str);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                isr.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
```



文件的讀入和寫出

- 讀入 InputStreamReader 以utf-8的解碼形式讀取
- 寫出 OutputStreamWriter 以gbk重新對目標文件編碼

```java
/*
    綜合使用InputStreamReader 和 OutputStreamWriter
 */
@Test
public void test2(){
    InputStreamReader isr = null;
    OutputStreamWriter osw = null;

    try {
        // 1.建立文件 建造流
        File file = new File("hello.txt");
        File file2 = new File("hello_gbk.txt");

        FileInputStream fis = new FileInputStream(file);
        FileOutputStream fos = new FileOutputStream(file2);

        isr = new InputStreamReader(fis,"utf-8"); // 對 hello.txt 解碼
        osw = new OutputStreamWriter(fos,"gbk"); // 重新對 hello_gbk 編碼

        // 2.讀寫過程
        char[] cbuf = new char[20];
        int len;
        while ( (len = isr.read(cbuf)) != -1){
            osw.write(cbuf,0,len);
        }
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        // 3.關閉資源
        if (isr != null){
            try {
                isr.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        if (osw != null){
            try {
                osw.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```



#### 轉換流-字元編碼

常見的編碼表

- ASCII
  - 用一個byte的7位表示
- ISO8859-1
  - 用一個byte的8位表示
- GB2312
  -  中文編碼表 最多兩個byte編碼所有char
- GBK
  - 中文編碼表升級 最多使用兩個byte編碼
- Unicode
  - 國際標準碼 融合目前人類所有的char 為每個char分配唯一的char碼
- UTF-8
  - 變長的編碼方式 可用1-4個byte表示一個char



Unicode並不完美 有以下問題

- 英文字母只用一個byte就可以表示
- 如何才能區分Unicode和ASCII 
  - 要如何分辨兩個byte表示一個符號 而不是分別表示兩個符號
- 如果和GBK等雙byte編碼方式一樣 用最高位1或0表示兩個byte或一個byte 就少了很多值無法用於表示字元 不夠表示所有字元 



UTF

- 傳入的眾多標準 UTF (UCS Transfer Format) 
- UTF-8就是每次8個位傳輸數據   UTF-16就是每次16個位傳輸

``````
0xxxxxxx (兼容原來的ASCII)
110xxxxx 10xxxxxx
1110xxxx 10xxxxxx 10xxxxxx
11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
``````

- 在標準的UTF-8編碼中 超出基本多語言範圍的字元被編碼為4個byte的格式
- 但是在修正個UTF-8編碼中 他們由代理編碼對表示 然後這些代理編碼對在序列中分別重新編碼
  - 結果標準UTF-8編碼中需要4個byte的字元 修正後的UTF-8編碼中將需要6個byte



#### 標準輸入輸出流

```java
public class OtherStreamTest {
    /*
        1.標準的輸入輸出流
        1.1
        System.in :  標準的輸入流 預設從鍵盤輸入
        System.out : 標準的輸出流 預設從控制台輸出
        1.2
        System類的setIn(InputStream is) / setOut(PrintStream ps) 方式重新指定輸入和輸出的流
        1.3
        從鍵盤輸出字串 要求將讀取道的整行字串轉成大寫輸出 然後繼續進行輸入操作
        直到輸入 e 或 exit 結束程式

        方法一 : 使用Scanner實現 調用next()返回一個字串
        方法二 : 使用System.in實現 System.in --> 轉換流 --> BufferedReader的readLine()
     */
    public static void main(String[] args) {
        BufferedReader br = null;
        try {
            System.out.println("請輸入字串  輸入e,exit結束");
            InputStreamReader isr = new InputStreamReader(System.in); // 鍵盤輸入
            br = new BufferedReader(isr);
            while (true){
                String data = br.readLine(); // 讀取一行數據
                if ("e".equalsIgnoreCase(data) || "exit".equalsIgnoreCase(data)){
                    System.out.println("程式結束");
                    break;
                }
                
                String upperCase = data.toUpperCase();
                System.out.println(upperCase);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (br != null){
                try {
                    br.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```



#### 打印流

- 實現將基本數據類型的數據格式轉化為字串輸出
- PrintStream和PrintWriter
  - 提供一系列重載的print()和println()方法 用於多種數據類型的輸出
  - PrintStream和PrintWriter的輸出不會拋出IOException異常
  - PrintStream和PrintWriter有自動flush功能
  - PrintStream打印的所有字元都使用平台的預設字元邊碼轉換為byte
    - 在需要寫入字元而不是寫入byte的情況下 都應該使用PrintWriter類
  - System.out返回的是PrintStream的實例



儲存成文件輸出

- new FileOutputStream("路徑")
- new PrintStream(路徑,true)
- 重新指定輸出位置 System.setOut()

```java
/*
    打印流 : PrintStream 和 PrintWriter
    1.提供了一系列重載的print()和println()
    2.
 */
@Test
public void test2(){
    FileOutputStream fos = null;
    try {
        PrintStream ps = null;
        fos = new FileOutputStream(new File("C:\\Users\\wsx03\\Desktop\\stream.txt"));
        // 創建打印輸出流 設置為自動刷新模式(寫入換行符或byte '\n' 時都會刷新輸出緩衝區)
        ps = new PrintStream(fos, true);
        if (ps != null){ // 把標準輸出流(控制台輸出) 改成文件輸出
            System.setOut(ps);
        }
        for (int i = 0; i < 255; i++) {
            System.out.print((char) i);
            if (i%50 == 0){
                System.out.println();
            }
        }
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    } finally {
        if (fos != null){
            try {
                fos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```



#### 數據流

- 為了方便的操作Java語言的基本數據類型和String的數據 可以使用數據流
- 數據流有兩個類 (用於讀取和寫出基本數據類型 String類的數據)
  - DataInputStream 和 DataOutputStream
  - 分別 套接 在InputStream 和 OutputStream 子類的流上
- DataInputStream中的方法

``````java
boolean readBoolean()		byte readByte()
char readChar()			    float readFloat()
double readdouble()			short readShort()
long readLong()				int readInt()
String readUTF()			void readFully(byte[] b)
``````

- DataOutputStream中的方法
  - 將上述的方法的read改為write



將數據保存持久化

- 記憶體 --> 文件

```java
/*
    數據流
    DataInputStream 和 DataOutputStream
    作用 : 用於讀取和寫出基本數據類型的變數和字串

    將記憶體中的字串 基本數據類型的變數 寫出到文件中
    使用try-catch-finally處理異常
 */
@Test
public void test3(){
    DataOutputStream dos = null;
    try {
        //1.
        dos = new DataOutputStream(new FileOutputStream("data.txt"));
        //2.
        dos.writeUTF("AAABBBCCC");
        dos.flush(); // 刷新操作 : 一旦執行就會將記憶體中的數據寫入文件
        dos.writeInt(20);
        dos.flush();
        dos.writeBoolean(true);
        dos.flush();
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        //3.
        if (dos != null){
            try {
                dos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

讀取數據

- 文件 --> 記憶體 --> 變數

```java
/*
    將文件中儲存的基本數據類型變數和字串讀取到記憶體中 保存在變數中

    注意點 : 讀取不同類型的數據的順序 要與當初寫入文件時 保存的數據的順序一致
 */
@Test
public void test4(){
    //1.
    DataInputStream dis = null;
    try {
        dis = new DataInputStream(new FileInputStream("data.txt"));
        //2.
        String s = dis.readUTF();
        int i = dis.readInt();
        boolean b = dis.readBoolean();
        System.out.println("name = " + s);
        System.out.println("age = " + i);
        System.out.println("isMale = " + b);
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        //3.
        if (dis != null){
            try {
                dis.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```



#### 處理流-對象流

- ObjectInputStream 和 ObjectOutputStream
- 用於儲存和讀取基本數據類型或對象的處理流
  - 可以將Java中的對象寫入數據源中 也能把對象從數據源中還原
- 序列化
  - 用ObjectOutputStream類保存基本數據類型或對象的機制
  - 記憶體中的對象 --> 儲存中的文件 通過網路傳輸出去
- 反序列化
  - 用ObjectInputStream類讀取基本數據類型或對象的機制
  - 儲存中的文件 通過網路接收過來 --> 記憶體中的對象
- **ObjectOutputStream 和 ObjectInputStream不能序列化static和transient修飾的成員變數**



對象的序列化

- 對象序列化機制
  - 允許把記憶體中的java對象轉換成平台無關的二進制流
  - 從而允許把這種二進制流持久的保存在磁碟上 
  - 或通過網路將這種二進制流傳輸到另一個網路節點 
  - 當其他程式或取了這種二進制流 就可以恢復成原來的java對象
- 序列化的優點在於可將任何實現了 Serializable接口 的對象轉化為byte數據 使其在保存和傳輸時可被還原
- 序列化是 RMI(Remote Method invoke - 遠程方法調用) 過程的參數和返回值都必須實現的機制
  - 而RMI是javaEE的基礎 因此序列化機制是javaEE平台的基礎
- 如果需要讓某個對象支持序列化機制 則必須讓對象所屬的類及其屬性是可序列化的
  - 為了讓某個類是可序列化的 該類必須實現如下兩個接口之一
    - **Serializable**
    - Externalizable
- 凡是實現Serializable接口的類都有一個表示序列化版本標示符的靜態變數
  - private static final long serivalVersionUID
  - serialVersionUID用來表明類的不同版本間的尖榮幸
    - 目的是以序列化對象進行版本控制 有關各版本反序列化時是否兼容
  - 如果類沒有顯示的定義serivalVersionUID
    - 他的值是java運行時對環境根據類的內部細節自動生成的
    - 若類的實例變數做了修改  自動生成的serivalVersionUID 可能發生變化
    - 所以建議自己聲明serivalVersionUID
- java的序列化機制是通過在運行時判斷類的serivalVersionUID來驗證版本的一致性
  - 在進行反序列化時 JVM會把傳過來的byte流中的serivalVersionUID與本地相應實體類的serivalVersionUID進行比較
  - 如果相同就認為是一致的 可以進行反序列化 否則就會出現序列化版本不一致的異常 (InvalidCastException)
- 也就是在沒有**聲明serivalVersionUID時 序列化後**
  - 對類進行屬性的添加,刪除後  **進行反序列化時 就會出現錯誤** 



序列化 : ObjectOutputStream

```java
/*
    序列化過程 : 將記憶體中的Java對象保存到硬碟中或通過網路傳輸
    使用ObjectOutputStream實現
 */
@Test
public void testObjectOutputStream(){
    // ObjectOutputStream : 序列化  包存基本數據類型或對象
    ObjectOutputStream oos = null;
    try {
        // 1.
        oos = new ObjectOutputStream(new FileOutputStream("object.dat"));
        // 2.
        oos.writeObject(new String("ABCDE"));
        oos.flush(); // 刷新操作
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        // 3.
        if (oos != null){
            try {
                oos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

反序列化 : ObjectInputStream

```java
/*
    反序列化 ObjectInputStream
        將硬碟中的文件的對象還原為記憶體中的java對象
 */
@Test
public void testObjectInputStream(){
    ObjectInputStream ois = null;
    try {
        ois = new ObjectInputStream(new FileInputStream("object.dat"));
        Object obj = ois.readObject();
        String str = (String) obj;
        System.out.println(str);
    } catch (IOException e) {
        e.printStackTrace();
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    } finally {
        if (ois != null){
            try {
                ois.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```



類的序列化

```java
/*
    Person類需要滿足序列化要求
        1.實作Serializable
        2.當前類提供一個全域常數 : serivalVersionUID
        3.除了當前Person類需要實現Serializable街口之外 還必須保證其內部所有屬性
                也必須是可序列化的 (預設情況 基本數據類型可序列化)
 */
public class Person implements Serializable {
    public static final long serialVersionUID = 475463534532L;
    private String name;
    private int age;
	// get set toString    
}
```

序列化

```java
try {
    // 1.
    oos = new ObjectOutputStream(new FileOutputStream("object.dat"));
    // 2.
    oos.writeObject(new Person("ABC",20));
    oos.flush(); // 刷新
} 
```

反序列化

```java
try {
    ois = new ObjectInputStream(new FileInputStream("object.dat"));
    Person p = (Person) ois.readObject();
    System.out.println(p);

}
```



#### 隨機存取文件流

- RandomAccessFile 聲明在java.io包下 但是直接繼承於java.lang.Object類
  - 並且她實現了DataInput DataOutput倆的街口  表示這個類既可以讀也可以寫
- RandomAccessFile類支持 隨機訪問 的方式 程式可以直接跳到文件的任意地方來讀 寫文件
  - 支持只訪問文件的部分內容
  - 可以向已存在的文件後追加內容
- RandomAccessFile對象包含一個記錄指針 用以標示當前讀寫處的位置
- RandomAccessFile類對象可以自由移動記錄指針
  - long getFilePointer() : 獲取文件記錄指針的當前位置
  - void seek(long pos) : 將文件記錄指針定位到pos位置



RandomAccessFile類

- 建構器
  - public RandomAccessFile(File file,String mode)
  - public RandomAccessFile(String name,String mode)
- 創建RandomAccessFile類實例需要指定一個mode參數 該參數指定RandomAccessFile的訪問模式
  - r : 以唯獨方式開啟
  - rw : 開啟以便讀取和寫入
  - rwd : 開啟以便讀取和寫入 同步文件內容的更新
  - rws : 開啟以便讀取和寫入 同步文件內容和元數據的更新
- 如果模式為唯獨r 
  - 則不會創建文件 而是會去讀取一個已經存在的文件
  - 如果讀取的文件不存在則會出現異常
- 如果模式為rw讀寫
  - 如果文件不存在則會去創建文件
  - 如果存在則不會去創建



RandomAccessFile可以實現一個多執行緒的斷點下載功能 下載前都會建立兩個臨時文件 一個是與被下載文件大小相同的空文件 另一個是記錄文件指針的位置文件 每次暫停的時候 都會保存上一次的指針 然後斷點下載的時候 會維持從上一次的地方下載 從而實現斷點下載或上傳的功能



讀寫操作-文件複製

```java
/*
    RandomAccessFile的使用
    1.RandomAccessFile直接繼承於java.lang.Object類 實現了DataInput和DataOutput接口
    2.RandomAccessFile既可以做為一個輸入流 也可以做為一個輸出流
    3.如果RandomAccessFile作為輸出流時 寫出的文件如果不存在 則在執行中自動創建
                   如果寫出的文件存在 則會對原有文件內容進行覆蓋 (從頭覆蓋)
    4.可以通過相關的操作 實現RandomAccessFile "插入"數據的效果
 */
// 文件的複製
    @Test
    public void test1(){
        RandomAccessFile raf1 = null;
        RandomAccessFile raf2 = null;
        try {
            // 1.建立對象
            raf1 = new RandomAccessFile(new File("icon.jpg"),"r");
            raf2 = new RandomAccessFile(new File("icon2.jpg"),"rw");
            // 2.讀寫過程
            byte[] buffer = new byte[1024];
            int len;
            while ((len = raf1.read(buffer)) != -1 ){
                raf2.write(buffer,0,len);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            // 3.關閉資源
            if (raf1 != null){
                try {
                    raf1.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if (raf2 != null){
                try {
                    raf2.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
```



讀寫操作-輸出流-文件的寫入

```java
/*
	如果RandomAccessFile作為輸出流時 寫出的文件如果不存在 則在執行中自動創建
                   如果寫出的文件存在 則會對原有文件內容進行覆蓋 (從頭覆蓋)
 */
// 輸出流 文件的寫入
@Test
public void test2() throws IOException {
    RandomAccessFile raf1 = new RandomAccessFile(new File("hello.txt"), "rw");
    raf1.write("xyz".getBytes()); // 寫入xyz

    raf1.close();
}
```



實現插入操作

```java
/*
        使用RandomAccessFile實現數據的插入效果
     */
    @Test
    public void test3() throws IOException {
        RandomAccessFile raf1 = new RandomAccessFile(new File("hello1.txt"),"rw");
//        zxcsagdaherastfh
//        zxcxyzsagdaherastfh
        raf1.seek(3); // 指針調用為3的位置
        // 保存指針3後面的所有數據到StringBuilder中
        StringBuilder builder = new StringBuilder((int)new File("hello1.txt").length());
        byte[] buffer = new byte[20];
        int len;
        // StringBuilder保存數據
        while ((len = raf1.read(buffer)) != -1) {
            builder.append(new String(buffer,0,len));
        }
        // 返回指針 寫入xyz
        raf1.seek(3);
        raf1.write("xyz".getBytes());

        // 繼續寫入數據  將之前保存的數據輸出
        // 將StringBuilder中的數據寫入到文件中
        raf1.write(builder.toString().getBytes());

        raf1.close();
    }
```



# 網路編程



#### 網路通訊概述

實現網路互相通訊

- 通訊雙方地址
  - IP
  - port
- 一定的規則 (網路通訊協議)
  - OSI 模型
  - TCP/IP模型







#### 通訊要素 : IP與port



#### 通訊要素 : 網路協議



#### TCP網路編程



#### UDP網路編程



#### URL編程





# 反射機制



#### 動態語言 靜態語言

- 動態語言
  - 在運行時可以改變其結構的語言 例如新的函數 對象 甚至程式碼都可以被引進
  - 已有的函數可以被刪除或是其他結構上的變化
  - 也就是運行時程式碼可以根據某些條件改變自身結構
  - 主要動態語言 : Object-C C# JavaScript PHP Python Erlang
- 竟態語言
  - 運行時結構不可變的語言
  - 主要靜態語言 : Java C C++

但Java稱為準動態語言 因為利用反射機制可以使Java實現動態語言的特性



#### 反射機制概述

- Reflection被視為動態語言的關鍵 允許程式在執行執行期間借助Reflection API取得任何類的內部訊息 並能直接操作任意對象的內部屬性及方法
- 加載完類後 在heap記憶體的方法區就產生了一個Class類型的對象 (一個類只有一個Class對象) 這個對象包含了完整的類的結構訊息 我們可以通過這個對象看到類的結構 這個對象就像鏡子 透過這個鏡子看到類的結構 所以我們形象的稱之為 反射

一般方式 : 引入需要的包類名稱 --> 通過new實例化 --> 取得實例化對象

反射方式 : 實例化對象 --> getClass()方法 --> 得到完整的包類名稱



##### 反射機制研究及應用

- 運行時判斷任意一個對象所屬的類
- 運行時建構任意一個類的對象
- 運行時判斷任意一個類所具有的成員變數和方法
- 運行時獲取泛型訊息
- 運行時調用任意一個對象的成員變數和方法
- 運行時處理註解
- 生成動態代理



```java
// 反射之後 對Person的操作
@Test
public void test2() throws Exception{
    Class clazz = Person.class;
    // 1.通過反射 創建Person類的對象
    Constructor cons = clazz.getConstructor(String.class, int.class);
    Object obj = cons.newInstance("Tom", 12);
    Person p = (Person) obj;
    System.out.println(p.toString());
    // 2.通過反射 調用對象指定的屬性 方法
    // 調用屬性
    Field age = clazz.getDeclaredField("age");
    age.set(p,10);
    System.out.println(p.toString());

    // 調用方法
    Method show = clazz.getDeclaredMethod("show");
    show.invoke(p);

    System.out.println("=========================");
    // 通過反射 可以調用Person類的私有結構   私有的建構器 方法 屬性
    // 調用私有的建構器
    Constructor cons1 = clazz.getDeclaredConstructor(String.class);
    cons1.setAccessible(true);
    Person p1 = (Person) cons1.newInstance("Jerry");
    System.out.println(p1.toString());

    // 調用私有的屬性
    Field name = clazz.getDeclaredField("name");
    name.setAccessible(true);
    name.set(p1,"ABCDE");
    System.out.println(p1.toString());

    // 調用私有的方法
    Method showNation = clazz.getDeclaredMethod("showNation", String.class);
    showNation.setAccessible(true);
    String zzzz = (String) showNation.invoke(p1, "ZZZZ");// 相當於 String nation =  p1.showNation("ZZZZ")
    System.out.println(zzzz); // ZZZZ
}
```



```java
public class Person {
    private String name;
    public int age;

    public Person() {
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    private Person(String name){
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    public void show(){
        System.out.println("Person --- show");
    }

    private String showNation(String nation){
        System.out.println("nation --> " + nation);
        return nation;
    }
}
```



#### 反射相關的主要API

- java.lang.Class : 代表一個類
- java.lang.reflect.Method : 代表類的方法
- java.lang.reflect.Field : 代表類的成員變數
- java.lang.reflect.Constructor : 代表類的建構器

Class : 通用的描述其他class的訊息 , 類結構的類



#### Class類獲取Class實例 (掌握)

- 類的載入過程
  - 程式經過javac.exe命令後 會生成一個或多個byte文件 (.class結尾)
  - 接著我們使用java.exe命令對某個byte文件進行解釋運行 相當於將某個byte文件載入到記憶體中 此過程稱為類的載入  載入到記憶體中的類  稱為運行時類  此類運行時 就作為Class的一個實例
- 換句話說 Class的實例就對應著一個運行時類
- 載入到記憶體中的運行時類 會暫存一定的時間  在此時間之內 我們可以通過不同的方式獲取此運行時類

```java
/*
    獲取Class的實例的方式
 */
@Test
public void test3() throws ClassNotFoundException {
    // 方式一 : 調用運行時類的屬性 .class
    Class clazz1 = Person.class;
    System.out.println(clazz1); // class com.java.reflect.Person

    // 方式二 : 通過運行時類的對象 , 調用getClass()
    Person p1 = new Person();
    Class clazz2 = p1.getClass();
    System.out.println(clazz2); // class com.java.reflect.Person

    // 方式三 : 調用Class的靜態方法 : forName(String classPath)
    Class clazz3 = Class.forName("com.java.reflect.Person"); // 異常 找不到對應的資源時
    System.out.println(clazz3); // class com.java.reflect.Person
    Class<?> aClass = Class.forName("java.lang.String");
    System.out.println(aClass); // class java.lang.String

    System.out.println(clazz1 == clazz2); // true  獲取的是同一個運行時類
    System.out.println(clazz1 == clazz3); // true

    // 方式四 : 使用類的載入器 ClassLoader
    ClassLoader classLoader = ReflectionTest.class.getClassLoader();
    Class clazz4 = classLoader.loadClass("com.java.reflect.Person");
    System.out.println(clazz4);
    System.out.println(clazz1 == clazz4); // true

}
```

哪些對象可以有Class對象

- class
  - 外部類 成員(成員內部類 靜態內部類) 局部內部類 匿名內部類
- interface 
- [] : 陣列
- enum : 枚舉
- annotation : 註解 @interface
- primitive type : 基本數據類型
- void

``````java
/*
        Class實例可以是那些結構
     */
    @Test
    public void test4(){
        Class c1 = Object.class;
        Class c2 = Comparable.class;
        Class c3 = String[].class;
        Class c4 = int[][].class;
        Class c5 = ElementType.class;
        Class c6 = Override.class;
        Class c7 = int.class;
        Class c8 = void.class;
        Class c9 = Class.class;

        int[] a = new int[10];
        int[] b = new int[100];
        Class c10 = a.getClass();
        Class c11 = b.getClass();
        // 只要陣列的元素類型與維度一樣 就是同一個Class
        System.out.println(c10 == c11); // true   int  [] 相同

    }
``````



#### 類的加載與ClassLoader的理解

當程式主動使用某個類  如果該類還未被載入到記憶體中 則系統會通過如下步驟對該類進行初始化

- 類的載入 (Load)
  - 將類的.class文件(byte)讀入記憶體 並為其創建一個java.lang.Class對象  此過程由類載入器完成
- 類的連接 (Link)
  - 將類的二進制數據合併到JRE致中
- 類的初始化 (Initialize)
  - JVM負責對類進行初始化



類載入器的作用

- 類載入的作用 : 將class文件byte內容載入到記憶體中 並將這些靜態數據轉換為方法區運行時的數據結構 然後再heap中生成一個代表這個類的java.lang.Class對象 作為方法區中類數據的訪問入口
- 類暫存 : 標準的JavaSE類的載入器可以按要求查詢類 但一旦某個類備載入到類載入器中 他將維持載入(暫存) 一段時間   不過JVM垃圾回收機制可以回收這些Class對象



```java
@Test
public void test1(){

    // 對於自定義類 使用系統類載入器進行載入
    ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();
    System.out.println(classLoader); // jdk.internal.loader.ClassLoaders$AppClassLoader@66d3c617

    // 調用系統類載入器的getParent() : 獲取擴展類載入器
    ClassLoader classLoader2 = classLoader.getParent();
    System.out.println(classLoader2); // jdk.internal.loader.ClassLoaders$PlatformClassLoader@19bb089b

    // 調用擴展類載入器的getParent() : 無法獲取引導類載入器
    // 引導類載入器主要負責載入java的核心類庫 無法載入自定義類的
    ClassLoader classLoader3 = classLoader2.getParent();
    System.out.println(classLoader3); // null

    ClassLoader classLoader4 = String.class.getClassLoader();
    System.out.println(classLoader4); // null

}
```

Properties : 讀取配置文件

```java
/*
        Properties : 讀取配置文件
     */
    @Test
    public void test2() throws IOException {
        Properties pros = new Properties();
        // 此時的文件預設在當前的module下
        // 讀取配置文件的方式一:
//        路徑 當前module/
//        FileInputStream fis = new FileInputStream("src\\bbb.properties");
//        pros.load(fis);

        // 方式二 : classLoader
        ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();
        // 路徑 當前module/src/
        InputStream is = classLoader.getResourceAsStream("bbb.properties");
        pros.load(is);


        String user = pros.getProperty("user");
        String password = pros.getProperty("password");
        System.out.println("user = " + user + " password = " + password);


    }
```



#### 創建運行時類的對象 (掌握)



newInstance() ---> getDeclaredConstructor().newInstance()

```java
// 通過反射創建對應的運行時類的對象
@Test
public void test1() throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
    Class clazz = Person.class;
    /*
        newInstance() : 調用此方法創建對應的運行時類的對象 內部調用了運行時類的無參數建構器

        要想以此方式正常創建運行時類的對象
        1. 運行時類必須提供無參數的建構器
        2. 取得無參建構器的訪問權限  通常設置為public

        在javabean中要求提供一個public的無參建構器 原因
        1. 便於通過反射 創建運行時類的對象
        2. 便於子類繼承此運行時類時 預設調用super()時 保證父類有此建構器

     */
    Person obj = (Person) clazz.getDeclaredConstructor().newInstance(); // new Person 對象
    System.out.println(obj); // Person{name='null', age=0}

}
```



```java
// 反射的動態性
@Test
public void test2(){
    int num = new Random().nextInt(3);// 0 1 2
    String classPath = "";
    switch (num){
        case 0:
            classPath = "java.util.Date";
            break;
        case 1:
            classPath = "java.sql.Date";
            break;
        case 2:
            classPath = "com.java.reflect.Person";
            break;
    }
    Object obj = null;
    try {
        obj = getInstance(classPath); // 運行時 根據random創建對象
    } catch (Exception e) {
        e.printStackTrace();
    }
    System.out.println(obj);
}
```



#### 獲取運行時類的完整結構



獲取屬性結構

```java
// 屬性結構
@Test
public void test1(){
    Class clazz = Person.class;
    // 獲取屬性結構
    // getFields() : 獲取當前運行時類及其父類中聲明為public權限的屬性
    Field[] fields = clazz.getFields();
    for (Field field : fields) {
        System.out.println(field); // public int com.java.reflect.Person.age
    }

    // getDeclaredFields() 獲取當前運行時類中聲明的所有屬性
    // 不包含父類聲明的屬性
    Field[] declaredFields = clazz.getDeclaredFields();
    for (Field f : declaredFields) {
        System.out.println(f);
        // private java.lang.String com.java.reflect.Person.name
        // public int com.java.reflect.Person.age
    }
}
```



獲取 權限修飾符  數據類型  變數名

```java
// 權限修飾符  數據類型  變數名
@Test
public void test2(){
    Class clazz = Person.class;
    Field[] declaredFields = clazz.getDeclaredFields();
    for (Field f : declaredFields) {
        // 1.權限修飾符
        int modifier = f.getModifiers();
        System.out.println(Modifier.toString(modifier));
        // 2.數據類型
        Class type = f.getType();
        System.out.println(type);
        // 3.變數名
        String fName = f.getName();
        System.out.println(fName);
        System.out.println();
    }
}
```



獲取方法

```java
// 獲取方法
@Test
public void test3(){
    Class clazz = Person.class;

    // getMethods() : 獲取當前運行時類及其所有父類中聲明為public權限的方法
    Method[] methods = clazz.getMethods();
    for (Method method : methods) {
        System.out.println(method);
    }
    System.out.println();

    // getDeclaredMethods() 獲取當前運行時類中聲明的所有方法 (不包含父類)
    Method[] declaredMethods = clazz.getDeclaredMethods();
    for (Method m : declaredMethods) {
        System.out.println(m);
    }
}
```



獲取 權限修飾符  返回值類型 方法名(參數類型1 參數名1,...)

```java
/*
    權限修飾符  返回值類型 方法名(參數類型1 參數名1,...) throws XxxException()
 */
@Test
public void test4(){
    Class clazz = Person.class;
    Method[] declaredMethods = clazz.getDeclaredMethods();
    for (Method m : declaredMethods) {
        // 1.獲取方法聲明的註解
        Annotation[] annotations = m.getAnnotations();
        for (Annotation a : annotations) {
            System.out.println(a);
        }

        // 2.權限修飾符    每個方法
        System.out.print(Modifier.toString(m.getModifiers()) + "\t");

        // 3.返回值類型
        System.out.print(m.getReturnType() + "\t");

        // 4.方法名
        System.out.print(m.getName() + "\t");
        System.out.print("(");

        // 5.參數列表
        Class[] parameterTypes = m.getParameterTypes();
        if (!(parameterTypes == null || parameterTypes.length == 0)){
            for (int i = 0; i < parameterTypes.length;i++){
                if ( i == parameterTypes.length - 1){
                    System.out.print(parameterTypes[i].getName() + "args_" + i);
                    break;
                }
                System.out.print(parameterTypes[i].getName() + "args_" + i + ",");
            }
        }

        System.out.print(")");

        // 6.拋出的異常
        Class[] exceptionTypes =  m.getExceptionTypes();
        if (exceptionTypes == null || exceptionTypes.length == 0){
            System.out.println("throws ");
            for (int i = 0; i < exceptionTypes.length; i++) {
                if (i == exceptionTypes.length - 1){
                    System.out.println(exceptionTypes[i].getName());
                    break;
                }
                System.out.println(exceptionTypes[i].getName() + ",");
            }
        }
        System.out.println();
    }
}
```



獲取建構器結構

```java
/*
    獲取建構器結構
 */
@Test
public void test5(){
    Class clazz = Person.class;
    // getConstructors() : 獲取當前運行時類中聲明為public的建構器
    Constructor[] constructors = clazz.getConstructors();
    for (Constructor c : constructors) {
        System.out.println(c);
    }
    System.out.println();

    // getDeclaredConstructors() : 獲取當前運行時類中聲明的所有建構器
    Constructor[] declaredConstructors = clazz.getDeclaredConstructors();
    for (Constructor c : constructors) {
        System.out.println(c);
    }
}
```



獲取運行時類的父類

```java
/*
    獲取運行時類的父類
 */
@Test
public void test6(){
    Class clazz = Person.class;

    Class superclass = clazz.getSuperclass(); // 一般的父類
    System.out.println(superclass);

    Type genericSuperclass = clazz.getGenericSuperclass(); // 泛型的父類
    System.out.println(genericSuperclass);
}
```



獲取運行時類的帶泛型的父類的泛型

```java
/*
        獲取運行時類的帶泛型的父類的泛型
     */
    @Test
    public void test7(){
        Class clazz = Person.class;

        Type genericSuperclass = clazz.getGenericSuperclass();
        ParameterizedType paramType = (ParameterizedType) genericSuperclass;
        // 獲取泛型類型
        Type[] actualTypeArguments = paramType.getActualTypeArguments();
//        for (Type a : actualTypeArguments) {
//            System.out.println(a.getTypeName());
//        }
        System.out.println(((Class)actualTypeArguments[0]).getName());
    }
```



獲取interface

```java
/*
    獲取運行時類實現的接口
 */
@Test
public void test8(){
    Class clazz = Person.class;

    Class[] interfaces = clazz.getInterfaces();
    for (Class c : interfaces) {
        System.out.println(c);
    }

    System.out.println();

    // 獲取運行時類的父類實現的接口
    Class[] interfaces1 = clazz.getSuperclass().getInterfaces();
    for (Class c : interfaces1) {
        System.out.println(c);
    }
}
```



獲取運行時類所在的包

```java
/*
    獲取運行時類所在的包
 */
@Test
public void test9(){
    Class clazz = Person.class;

    Package pack = clazz.getPackage();
    System.out.println(pack); // package com.java.reflect
}
```



獲取運行時類聲明的註解

```java
/*
    獲取運行時類聲明的註解
 */
@Test
public void test10(){
    Class clazz = Person.class;

    Annotation[] annotations = clazz.getAnnotations();
    for (Annotation annotation : annotations) {
        System.out.println(annotation);
    }
}
```



#### 調用運行時類的指定結構(常用)



##### 獲取指定屬性

調用運行時類中指定的結構 : 屬性 方法 建構器

屬性要宣告為public  不常使用

```java
@Test
public void testField() throws Exception{
    Class clazz = Person.class;

    // 創建運行時類的對象
    Person p = (Person) clazz.getConstructor().newInstance();

    // 獲取指定的屬性 : 要求運行時類中屬性聲明為public
    // 通常不採用
    Field age = clazz.getField("age");

    /*
        設置當前屬性的值
        set() : 參數1 : 指名設置哪個對象的屬性
                參數2 : 將此屬性值設置為多少
     */

    age.set(p,100);
    /*
        獲取當前屬性的值
        get() : 參數1 : 獲取哪個對象的當前屬性值
     */
    int pAge = (int)age.get(p);
    System.out.println(pAge);
}
```



獲取指定屬性  實際使用的方式

```java
/*
    如何操作運行時類中的指定的屬性    實際使用的方式
 */
@Test
public void testField2() throws Exception{
    Class clazz = Person.class;

    // 創建運行時類的對象
    Person p = (Person) clazz.getConstructor().newInstance();

    // 1.getDeclaredField(String fieldName) : 獲取運行時類中指定變數名的屬性
    Field name = clazz.getDeclaredField("name");

    // 2.保證當前屬性是可以訪問的
    name.setAccessible(true);

    // 3.獲取 設置 指定對象的屬性值
    name.set(p,"Tom");

    System.out.println(name.get(p));

}
```



##### 獲取指定的方法

操作運行時類中的指定的方法

```java
/*
    如何操作運行時類中的指定的方法
 */
@Test
public void testMethod() throws Exception{
    Class clazz = Person.class;

    // 創建運行時類的對象
    Person p = (Person) clazz.getConstructor().newInstance();
    /*
     1.獲取指定的某個方法
        getDeclaredMethod() : 參數1 : 指名獲取的方法的名稱
                              參數2 : 指名獲取的方法的參數列表
     */

    Method show = clazz.getDeclaredMethod("show", String.class);

    // 2. 保證當前方法是可訪問的
    show.setAccessible(true);
    /*
        3.invoke() : 參數1 : 方法的調用者
                     參數2 : 給方法參數賦值的參數
        invoke()的返回值即為對應類中調用的方法的返回值
     */
    Object returnValue =  show.invoke(p, "ABC");// String aa = p.show("ABC")
    System.out.println(returnValue);

    System.out.println("=======調用靜態方法=======");

    // private static void showDesc()
    Method showDesc = clazz.getDeclaredMethod("showDesc");
    showDesc.setAccessible(true);
    Object returnVal = showDesc.invoke(Person.class); // 調用方法 (傳入類 無參數)
    System.out.println(returnVal); // null
}
```



##### 獲取建構器

調用建構器創建對象 (較少使用)

```java
/*
    如何調用運行時類中的指定的建構器
 */
@Test
public void testConstructor() throws Exception{
    Class clazz = Person.class;

    // private Person(String name)
    /*
        1.獲取指定的建構器
        getDeclaredConstructor() : 參數 : 指名建構器的參數列表
     */
    Constructor declaredConstructor = clazz.getDeclaredConstructor(String.class);

    // 2.保證此建構器是可以訪問的
    declaredConstructor.setAccessible(true);

    // 3.調用此建構器創建運行時類的對象
    Person abc = (Person) declaredConstructor.newInstance("ABC");
    System.out.println(abc); // Person{name='ABC', age=0, id=0}
}
```



#### 反射-問題

獲取Class實例的三種常見方式

``````java
Class clazz1 = string.class; // 較少使用 因為缺乏動態性  在編譯期就寫死了
Class clazz2 = person.getClass(); // 
Class clazz3 = Class.forName(String classPath) // 體現反射的動態性
``````



對Class類的理解

- Class實例對應著載入到記憶體中的一個運行時類



創建Class對應運行時類的對象的通用方法 , 需要對應的運行時類建構器方面滿足的要求

- 必須有無參數的建構器
- 權限修飾符的權限要足夠  通常設置為public

``````
clazz.getConstructor().newInstance(); // 創建了對應的運行時類的對象
``````



如何調用方法show()

``````java
package com.java;
Class User{
	public void show(){
		System.out.println("show---");
	}
}

User user = (User)clazz.newInstance();
Method show = clazz.getDeclareMethod("show");
show.setAccessiable(true);
show.invoke(user); // 放入創建實例
``````



#### 反射應用 動態代理

代理設計模式的原理

- 使用一個代理將對象包裝起來 然後用該代理對象取代原始對象 任何對原始對象的調用都要通過代理 代理對象決定是否以及何時將方法調用轉到原始對象上

動態代理

- 只通過代理類調用其他對象的方法 並且是在程式運行時根據需要動態創建目標類的代理對象

動態代理使用場合

- 調試
- 遠程方法調用

動態代理相比靜態代理的優點

- 抽象角色中 (interface) 聲明的所有方法都被轉移到一個集中的方法中處理 這樣就可以更加靈活和統一的處理眾多的方法
  - 一個代理類可以處理多個被代理類



靜態代理

```java
/*
    靜態代理
    特點 : 代理類和被代理類在編譯期間就確定下來了
 */
interface ColthFactory{
    void produceCloth();
}
// 代理類
class ProxyClothFactory implements ColthFactory{

    private ColthFactory factory; // 使用被代理類對象進行實例化

    public ProxyClothFactory() {
    }

    public ProxyClothFactory(ColthFactory factory) {
        this.factory = factory;
    }

    @Override
    public void produceCloth() {
        System.out.println("代理工廠準備工作");
        factory.produceCloth(); // 傳入的被代理類 執行方法
        System.out.println("代理工廠做一些後續的工作");
    }
}

// 被代理類
class NikeClothFactory implements ColthFactory{

    @Override
    public void produceCloth() {
        System.out.println("Nike工廠生產工作");
    }
}

public class StaticProxyTest {
    public static void main(String[] args) {
        // 創建被代理類的對象
        NikeClothFactory nike = new NikeClothFactory();
        // 創建代理類的對象 --> 傳入被代理類的對象
        ProxyClothFactory proxyClothFactory = new ProxyClothFactory(nike);

        proxyClothFactory.produceCloth();
    }
}
```



動態代理

```java
/*
    動態代理的舉例
 */
interface Human{

    String getBelief();

    void eat(String food);
}

// 被代理類
class SuperMan implements Human{
    @Override
    public String getBelief() {
        return "SuperMan --> believe I can fly";
    }

    @Override
    public void eat(String food) {
        System.out.println("SuperMan --> eat " + food);
    }
}

/*
    實現動態代理 需要解決的問題
    問題一 : 如何根據載入到記憶體中的被代理類  動態的創建一個代理類及其對象
    問題二 : 當通過代理類的對象調用方法a時 如何動態的去調用被代理類中的同名方法a

 */
class ProxyFactory{
    // 通過調用此方法 返回一個代理類的對象  解決問題一
    public static Object getProxyInstance(Object obj){ // obj : 被代理類的對象
        MyInvocationHandler handler = new MyInvocationHandler();

        handler.bind(obj);

        // 根據傳入的被代理類對象  動態的創建代理類的對象
        return Proxy.newProxyInstance(obj.getClass().getClassLoader(),obj.getClass().getInterfaces(),handler);

    }
}

class MyInvocationHandler implements InvocationHandler{

    private Object obj; // 需要使用被代理類的對象進行賦值

    public void bind(Object obj){
        this.obj = obj;
    }

    // 當我們通過代理類的對象 調用方法a時 就會自動的調用如下的方法 : invoke()
    // 將被代理類要執行的方法a的功能 生明在invoke()中
    // proxy : 代理類的對象  method : 代理類的對象調用的方法
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // method : 即為代理類對象調用的方法 此方法也就做為了被代理類對象要調用的方法
        // obj : 被代理類的對象
        Object returnValue = method.invoke(obj, args);
        // 上述方法的返回值 就作為當前類的invoke()的返回值
        return returnValue;
    }
}

public class ProxyTest {
    public static void main(String[] args) {
        SuperMan superMan = new SuperMan();
        // 創建代理類的對象  傳入被代理類的對象
        // proxyInstance : 代理類的對象
        Human proxyInstance = (Human) ProxyFactory.getProxyInstance(superMan);

        // 當通過代理類對象調用方法時 會自動的調用被代理類中同名的方法
        String belief = proxyInstance.getBelief();
        System.out.println(belief);
        proxyInstance.eat("burger");

        System.out.println("==================");
        // 被代理類
        NikeClothFactory nikeClothFactory = new NikeClothFactory();
        // 創建代理類  代理(被代理類)
        ClothFactory proxyClothFactory = (ClothFactory) ProxyFactory.getProxyInstance(nikeClothFactory);
        // 調用代理類的方法  執行被代理類中同名的方法
        proxyClothFactory.produceCloth();

    }
}
```



# java8特性



#### Lambda表達式



```java
/*
    Lambda表達式的使用
    1. (o1,o2) -> Integer.compare(o1,o2);
    2. 格式 :
        -> : Lambda操作符 , 箭頭操作符
        ->左邊 : Lambda參數列表 (就是接口中的抽象方法的參數列表)
        ->右邊 : Lambda體 (就是重寫的抽象方法的方法體)
    3. Lambda表達式的使用 : 6種情況
        總結 :
            ->左邊 : Lambda參數列表的參數類型可以省略(類型推斷) : 如果Lambda參數列表只有一個參數 其一對()也可以省略
            ->右邊 : Lambda體應該使用一對{}包覆 : 如果Lambda體只有一條執行語句 (可能是return語句) 省略這一對{}和return
    4. Lambda表達式的本質 : 作為函數式接口的實例
    
    5. 如果一個接口中 只聲明了一個抽象方法 則此接口就被稱為函數式接口
 */
public class LambdaTest2 {
    // 語法格式一 : 無參數 無返回值
    @Test
    public void test1(){
        Runnable r1 = new Runnable() {
            @Override
            public void run() {
                System.out.println();
            }
        };
        System.out.println("*************");
        // lambda  無參數 無返回值
        Runnable r2 = () -> {
            System.out.println();
        };
        r2.run();
    }
    // 語法格式二 : Lambda 需要一個參數 但是沒有返回值
    @Test
    public void test2(){
        Consumer<String> con = new Consumer<String>() {
            @Override
            public void accept(String s) {
                System.out.println(s);
            }
        };
        con.accept("123");
        System.out.println("*************");
        // lambda   一個參數 但是沒有返回值
        Consumer<String> con1 = (String s) -> {
            System.out.println(s);
        };
        con1.accept("456");
    }

    // 語法格式三 : 數據類型可以省略 因為可由編譯器推斷得出 稱為類型推斷
    @Test
    public void test3(){

        Consumer<String> con1 = (String s) -> {
            System.out.println(s);
        };
        con1.accept("456");

        System.out.println("*************");
        // 類型推斷  String s  -->  s
        Consumer<String> con2 = (s) -> {
            System.out.println(s);
        };
        con2.accept("789");
    }

    // 語法格式四 : Lambda若只需要一個參數時 參數的小括號可以省略
    @Test
    public void test4(){
        Consumer<String> con1 = (s) -> {
            System.out.println(s);
        };
        con1.accept("456");
        System.out.println("*************");
        // 一個參數時 參數的小括號可以省略
        Consumer<String> con2 = s -> {
            System.out.println(s);
        };
        con2.accept("456");
    }

    // 語法格式五 : Lambda需要兩個或以上的參數 多條執行語句 並且可以有返回值
    @Test
    public void test5(){
        Comparator<Integer> com1 = new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                System.out.println(o1);
                System.out.println(o2);
                return o1.compareTo(o2);
            }
        };
        System.out.println(com1.compare(10,15));
        System.out.println("***********************");

        Comparator<Integer> com2 = (o1,o2) -> {
            // 多條執行語句 並且可以有返回值
            System.out.println(o1);
            System.out.println(o2);
            return o1.compareTo(o2);
        };
        System.out.println(com2.compare(20,15));
    }

    // 語法格式六 : 當Lambda體只有一條語句時 return 與大括號若有 都可以省略
    @Test
    public void test6(){
        Comparator<Integer> com1 = (o1,o2) -> {
            // 多條執行語句 並且可以有返回值
            return o1.compareTo(o2);
        };
        System.out.println(com1.compare(20,15));

        System.out.println("***********************");

        // return 與大括號若有 都可以省略
        Comparator<Integer> com2 = (o1,o2) -> o1.compareTo(o2);
    }
}
```



#### 函數式(Functional)接口

- 只包含一個抽象方法的接口 稱為函數式接口
- 可以通過Lambda表達式來創建該接口的對象
  - 若Lambda表達式拋出一個受檢異常 (即 : 非運行時異常) 那麼該異常需要在目錄接口的抽象方法上進行聲明
- 可以在接口上使用 @FunctionalInterface註解 
  - 可以檢查是否是一個函數式接口  同時javadoc也會包含一條聲明 說明這個接口是一個函數式接口



java四大核心函數式接口

- Consumer<T\>消費型接口   
  - 參數類型 T  返回類型 void
  - 對類型為T的對象應用操作 
  - 包含方法 void accept(T t)
- Supplier<T\>供給型接口   
  - 參數類型 無  返回類型 T 
  - 返回類型為T的對象 
  - 包含方法 T get()
- Function<T,R\>函數型接口  
  - 參數類型  T  返回類型  R
  - 對類型為T的對象應用操作 並返回結果  結果是R類型的對象 
  - 包含方法 R apply(T t)
- Predicate<T\>斷定型接口   
  - 參數類型  T   返回類型 boolean
  - 確定類型為T的對象是否滿足某約束 並返回boolean值  
  - 包含方法  boolean test(T t)



```java
/*
    java內置的4大核心函數式接口

    消費型接口 Consumer<T>   void accept(T t)
    供給型接口 Supplier<T>   T get()
    函數型接口 Function<T,R> R apply(T t)
    斷定型接口 Predicate<T>  boolean test(T t)
 */
public class LambdaTest3 {

    @Test
    public void test1() {
        // Lambda
        happyTime(400,money -> System.out.println("Consumer interface " + money));
    }

    public void happyTime(double money, Consumer<Double> con){
        con.accept(money);
    }
   
}
```



```java
@Test
    public void test2(){
        List<String> list = Arrays.asList("ABC111","ABC222","ABC333","ABC444","AAAA","BBBB");
        List<String> filterStrs = filterString(list, new Predicate<String>() {
            @Override
            public boolean test(String s) {
                return s.contains("C"); // 包含C的對象
            }
        });
        System.out.println(filterStrs);

        System.out.println("**********************");
        // Lambda
        List<String> filterStrs1 = filterString(list,(s) -> s.contains("C"));

        System.out.println(filterStrs1);
    }

    // 根據給定的規則 過濾集合中的字串  規則由Predicate的方法決定
    public List<String> filterString(List<String> list, Predicate<String> pre){

        ArrayList<String> filterList = new ArrayList<>();

        for (String s : list){
            if (pre.test(s)){
                filterList.add(s);
            }
        }
        return filterList;
    }
```



#### 方法引用與建構器引用



#### Stream API



#### Optional類













